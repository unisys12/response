// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/responserms/response/internal/ent/deathcertificate"
	"github.com/responserms/response/internal/ent/deathcertifier"
	"github.com/responserms/response/internal/ent/deathmanner"
	"github.com/responserms/response/internal/ent/deathplace"
	"github.com/responserms/response/internal/ent/ethnicity"
	"github.com/responserms/response/internal/ent/gameserver"
	"github.com/responserms/response/internal/ent/metadata"
	"github.com/responserms/response/internal/ent/oauthconnection"
	"github.com/responserms/response/internal/ent/person"
	"github.com/responserms/response/internal/ent/player"
	"github.com/responserms/response/internal/ent/playeridentifier"
	"github.com/responserms/response/internal/ent/predicate"
	"github.com/responserms/response/internal/ent/race"
	"github.com/responserms/response/internal/ent/session"
	"github.com/responserms/response/internal/ent/setting"
	"github.com/responserms/response/internal/ent/sex"
	"github.com/responserms/response/internal/ent/state"
	"github.com/responserms/response/internal/ent/user"
	"github.com/responserms/response/internal/ent/vehicle"
	"github.com/responserms/response/internal/ent/vehicleclass"
	"github.com/responserms/response/internal/ent/vehiclecolor"
	"github.com/responserms/response/internal/ent/vehiclemake"
	"github.com/responserms/response/internal/ent/vehiclemodel"
	"github.com/responserms/response/internal/ent/vehicleregistration"
	"github.com/responserms/response/internal/structs"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDeathCertificate    = "DeathCertificate"
	TypeDeathCertifier      = "DeathCertifier"
	TypeDeathManner         = "DeathManner"
	TypeDeathPlace          = "DeathPlace"
	TypeEthnicity           = "Ethnicity"
	TypeGameServer          = "GameServer"
	TypeMetadata            = "Metadata"
	TypeOAuthConnection     = "OAuthConnection"
	TypePerson              = "Person"
	TypePlayer              = "Player"
	TypePlayerIdentifier    = "PlayerIdentifier"
	TypeRace                = "Race"
	TypeSession             = "Session"
	TypeSetting             = "Setting"
	TypeSex                 = "Sex"
	TypeState               = "State"
	TypeUser                = "User"
	TypeVehicle             = "Vehicle"
	TypeVehicleClass        = "VehicleClass"
	TypeVehicleColor        = "VehicleColor"
	TypeVehicleMake         = "VehicleMake"
	TypeVehicleModel        = "VehicleModel"
	TypeVehicleRegistration = "VehicleRegistration"
)

// DeathCertificateMutation represents an operation that mutates the DeathCertificate nodes in the graph.
type DeathCertificateMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	created_by             *int
	addcreated_by          *int
	created_with           *string
	updated_at             *time.Time
	updated_by             *int
	addupdated_by          *int
	updated_with           *string
	cause                  *string
	comments               *string
	certified_at           *time.Time
	certifier_comments     *string
	requires_certification *bool
	clearedFields          map[string]struct{}
	metadata               *int
	clearedmetadata        bool
	decedent               *int
	cleareddecedent        bool
	manner                 *int
	clearedmanner          bool
	place                  *int
	clearedplace           bool
	certifier              *int
	clearedcertifier       bool
	certified_by           *int
	clearedcertified_by    bool
	done                   bool
	oldValue               func(context.Context) (*DeathCertificate, error)
	predicates             []predicate.DeathCertificate
}

var _ ent.Mutation = (*DeathCertificateMutation)(nil)

// deathcertificateOption allows management of the mutation configuration using functional options.
type deathcertificateOption func(*DeathCertificateMutation)

// newDeathCertificateMutation creates new mutation for the DeathCertificate entity.
func newDeathCertificateMutation(c config, op Op, opts ...deathcertificateOption) *DeathCertificateMutation {
	m := &DeathCertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeDeathCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeathCertificateID sets the ID field of the mutation.
func withDeathCertificateID(id int) deathcertificateOption {
	return func(m *DeathCertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *DeathCertificate
		)
		m.oldValue = func(ctx context.Context) (*DeathCertificate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeathCertificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeathCertificate sets the old DeathCertificate of the mutation.
func withDeathCertificate(node *DeathCertificate) deathcertificateOption {
	return func(m *DeathCertificateMutation) {
		m.oldValue = func(context.Context) (*DeathCertificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeathCertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeathCertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeathCertificateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DeathCertificateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeathCertificateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeathCertificateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DeathCertificateMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeathCertificateMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeathCertificateMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeathCertificateMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DeathCertificateMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[deathcertificate.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DeathCertificateMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[deathcertificate.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeathCertificateMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, deathcertificate.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *DeathCertificateMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *DeathCertificateMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *DeathCertificateMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[deathcertificate.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *DeathCertificateMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[deathcertificate.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *DeathCertificateMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, deathcertificate.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeathCertificateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeathCertificateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeathCertificateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeathCertificateMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeathCertificateMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeathCertificateMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeathCertificateMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DeathCertificateMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[deathcertificate.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DeathCertificateMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[deathcertificate.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeathCertificateMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, deathcertificate.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *DeathCertificateMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *DeathCertificateMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *DeathCertificateMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[deathcertificate.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *DeathCertificateMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[deathcertificate.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *DeathCertificateMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, deathcertificate.FieldUpdatedWith)
}

// SetCause sets the "cause" field.
func (m *DeathCertificateMutation) SetCause(s string) {
	m.cause = &s
}

// Cause returns the value of the "cause" field in the mutation.
func (m *DeathCertificateMutation) Cause() (r string, exists bool) {
	v := m.cause
	if v == nil {
		return
	}
	return *v, true
}

// OldCause returns the old "cause" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldCause(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCause: %w", err)
	}
	return oldValue.Cause, nil
}

// ResetCause resets all changes to the "cause" field.
func (m *DeathCertificateMutation) ResetCause() {
	m.cause = nil
}

// SetComments sets the "comments" field.
func (m *DeathCertificateMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *DeathCertificateMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *DeathCertificateMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[deathcertificate.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *DeathCertificateMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[deathcertificate.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *DeathCertificateMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, deathcertificate.FieldComments)
}

// SetCertifiedAt sets the "certified_at" field.
func (m *DeathCertificateMutation) SetCertifiedAt(t time.Time) {
	m.certified_at = &t
}

// CertifiedAt returns the value of the "certified_at" field in the mutation.
func (m *DeathCertificateMutation) CertifiedAt() (r time.Time, exists bool) {
	v := m.certified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCertifiedAt returns the old "certified_at" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldCertifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCertifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCertifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertifiedAt: %w", err)
	}
	return oldValue.CertifiedAt, nil
}

// ClearCertifiedAt clears the value of the "certified_at" field.
func (m *DeathCertificateMutation) ClearCertifiedAt() {
	m.certified_at = nil
	m.clearedFields[deathcertificate.FieldCertifiedAt] = struct{}{}
}

// CertifiedAtCleared returns if the "certified_at" field was cleared in this mutation.
func (m *DeathCertificateMutation) CertifiedAtCleared() bool {
	_, ok := m.clearedFields[deathcertificate.FieldCertifiedAt]
	return ok
}

// ResetCertifiedAt resets all changes to the "certified_at" field.
func (m *DeathCertificateMutation) ResetCertifiedAt() {
	m.certified_at = nil
	delete(m.clearedFields, deathcertificate.FieldCertifiedAt)
}

// SetCertifierComments sets the "certifier_comments" field.
func (m *DeathCertificateMutation) SetCertifierComments(s string) {
	m.certifier_comments = &s
}

// CertifierComments returns the value of the "certifier_comments" field in the mutation.
func (m *DeathCertificateMutation) CertifierComments() (r string, exists bool) {
	v := m.certifier_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldCertifierComments returns the old "certifier_comments" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldCertifierComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCertifierComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCertifierComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertifierComments: %w", err)
	}
	return oldValue.CertifierComments, nil
}

// ClearCertifierComments clears the value of the "certifier_comments" field.
func (m *DeathCertificateMutation) ClearCertifierComments() {
	m.certifier_comments = nil
	m.clearedFields[deathcertificate.FieldCertifierComments] = struct{}{}
}

// CertifierCommentsCleared returns if the "certifier_comments" field was cleared in this mutation.
func (m *DeathCertificateMutation) CertifierCommentsCleared() bool {
	_, ok := m.clearedFields[deathcertificate.FieldCertifierComments]
	return ok
}

// ResetCertifierComments resets all changes to the "certifier_comments" field.
func (m *DeathCertificateMutation) ResetCertifierComments() {
	m.certifier_comments = nil
	delete(m.clearedFields, deathcertificate.FieldCertifierComments)
}

// SetRequiresCertification sets the "requires_certification" field.
func (m *DeathCertificateMutation) SetRequiresCertification(b bool) {
	m.requires_certification = &b
}

// RequiresCertification returns the value of the "requires_certification" field in the mutation.
func (m *DeathCertificateMutation) RequiresCertification() (r bool, exists bool) {
	v := m.requires_certification
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresCertification returns the old "requires_certification" field's value of the DeathCertificate entity.
// If the DeathCertificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertificateMutation) OldRequiresCertification(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequiresCertification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequiresCertification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresCertification: %w", err)
	}
	return oldValue.RequiresCertification, nil
}

// ResetRequiresCertification resets all changes to the "requires_certification" field.
func (m *DeathCertificateMutation) ResetRequiresCertification() {
	m.requires_certification = nil
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *DeathCertificateMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *DeathCertificateMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *DeathCertificateMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *DeathCertificateMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *DeathCertificateMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *DeathCertificateMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// SetDecedentID sets the "decedent" edge to the Person entity by id.
func (m *DeathCertificateMutation) SetDecedentID(id int) {
	m.decedent = &id
}

// ClearDecedent clears the "decedent" edge to the Person entity.
func (m *DeathCertificateMutation) ClearDecedent() {
	m.cleareddecedent = true
}

// DecedentCleared reports if the "decedent" edge to the Person entity was cleared.
func (m *DeathCertificateMutation) DecedentCleared() bool {
	return m.cleareddecedent
}

// DecedentID returns the "decedent" edge ID in the mutation.
func (m *DeathCertificateMutation) DecedentID() (id int, exists bool) {
	if m.decedent != nil {
		return *m.decedent, true
	}
	return
}

// DecedentIDs returns the "decedent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DecedentID instead. It exists only for internal usage by the builders.
func (m *DeathCertificateMutation) DecedentIDs() (ids []int) {
	if id := m.decedent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDecedent resets all changes to the "decedent" edge.
func (m *DeathCertificateMutation) ResetDecedent() {
	m.decedent = nil
	m.cleareddecedent = false
}

// SetMannerID sets the "manner" edge to the DeathManner entity by id.
func (m *DeathCertificateMutation) SetMannerID(id int) {
	m.manner = &id
}

// ClearManner clears the "manner" edge to the DeathManner entity.
func (m *DeathCertificateMutation) ClearManner() {
	m.clearedmanner = true
}

// MannerCleared reports if the "manner" edge to the DeathManner entity was cleared.
func (m *DeathCertificateMutation) MannerCleared() bool {
	return m.clearedmanner
}

// MannerID returns the "manner" edge ID in the mutation.
func (m *DeathCertificateMutation) MannerID() (id int, exists bool) {
	if m.manner != nil {
		return *m.manner, true
	}
	return
}

// MannerIDs returns the "manner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MannerID instead. It exists only for internal usage by the builders.
func (m *DeathCertificateMutation) MannerIDs() (ids []int) {
	if id := m.manner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManner resets all changes to the "manner" edge.
func (m *DeathCertificateMutation) ResetManner() {
	m.manner = nil
	m.clearedmanner = false
}

// SetPlaceID sets the "place" edge to the DeathPlace entity by id.
func (m *DeathCertificateMutation) SetPlaceID(id int) {
	m.place = &id
}

// ClearPlace clears the "place" edge to the DeathPlace entity.
func (m *DeathCertificateMutation) ClearPlace() {
	m.clearedplace = true
}

// PlaceCleared reports if the "place" edge to the DeathPlace entity was cleared.
func (m *DeathCertificateMutation) PlaceCleared() bool {
	return m.clearedplace
}

// PlaceID returns the "place" edge ID in the mutation.
func (m *DeathCertificateMutation) PlaceID() (id int, exists bool) {
	if m.place != nil {
		return *m.place, true
	}
	return
}

// PlaceIDs returns the "place" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaceID instead. It exists only for internal usage by the builders.
func (m *DeathCertificateMutation) PlaceIDs() (ids []int) {
	if id := m.place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlace resets all changes to the "place" edge.
func (m *DeathCertificateMutation) ResetPlace() {
	m.place = nil
	m.clearedplace = false
}

// SetCertifierID sets the "certifier" edge to the DeathCertifier entity by id.
func (m *DeathCertificateMutation) SetCertifierID(id int) {
	m.certifier = &id
}

// ClearCertifier clears the "certifier" edge to the DeathCertifier entity.
func (m *DeathCertificateMutation) ClearCertifier() {
	m.clearedcertifier = true
}

// CertifierCleared reports if the "certifier" edge to the DeathCertifier entity was cleared.
func (m *DeathCertificateMutation) CertifierCleared() bool {
	return m.clearedcertifier
}

// CertifierID returns the "certifier" edge ID in the mutation.
func (m *DeathCertificateMutation) CertifierID() (id int, exists bool) {
	if m.certifier != nil {
		return *m.certifier, true
	}
	return
}

// CertifierIDs returns the "certifier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CertifierID instead. It exists only for internal usage by the builders.
func (m *DeathCertificateMutation) CertifierIDs() (ids []int) {
	if id := m.certifier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCertifier resets all changes to the "certifier" edge.
func (m *DeathCertificateMutation) ResetCertifier() {
	m.certifier = nil
	m.clearedcertifier = false
}

// SetCertifiedByID sets the "certified_by" edge to the Person entity by id.
func (m *DeathCertificateMutation) SetCertifiedByID(id int) {
	m.certified_by = &id
}

// ClearCertifiedBy clears the "certified_by" edge to the Person entity.
func (m *DeathCertificateMutation) ClearCertifiedBy() {
	m.clearedcertified_by = true
}

// CertifiedByCleared reports if the "certified_by" edge to the Person entity was cleared.
func (m *DeathCertificateMutation) CertifiedByCleared() bool {
	return m.clearedcertified_by
}

// CertifiedByID returns the "certified_by" edge ID in the mutation.
func (m *DeathCertificateMutation) CertifiedByID() (id int, exists bool) {
	if m.certified_by != nil {
		return *m.certified_by, true
	}
	return
}

// CertifiedByIDs returns the "certified_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CertifiedByID instead. It exists only for internal usage by the builders.
func (m *DeathCertificateMutation) CertifiedByIDs() (ids []int) {
	if id := m.certified_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCertifiedBy resets all changes to the "certified_by" edge.
func (m *DeathCertificateMutation) ResetCertifiedBy() {
	m.certified_by = nil
	m.clearedcertified_by = false
}

// Where appends a list predicates to the DeathCertificateMutation builder.
func (m *DeathCertificateMutation) Where(ps ...predicate.DeathCertificate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeathCertificateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeathCertificate).
func (m *DeathCertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeathCertificateMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, deathcertificate.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, deathcertificate.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, deathcertificate.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, deathcertificate.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, deathcertificate.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, deathcertificate.FieldUpdatedWith)
	}
	if m.cause != nil {
		fields = append(fields, deathcertificate.FieldCause)
	}
	if m.comments != nil {
		fields = append(fields, deathcertificate.FieldComments)
	}
	if m.certified_at != nil {
		fields = append(fields, deathcertificate.FieldCertifiedAt)
	}
	if m.certifier_comments != nil {
		fields = append(fields, deathcertificate.FieldCertifierComments)
	}
	if m.requires_certification != nil {
		fields = append(fields, deathcertificate.FieldRequiresCertification)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeathCertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deathcertificate.FieldCreatedAt:
		return m.CreatedAt()
	case deathcertificate.FieldCreatedBy:
		return m.CreatedBy()
	case deathcertificate.FieldCreatedWith:
		return m.CreatedWith()
	case deathcertificate.FieldUpdatedAt:
		return m.UpdatedAt()
	case deathcertificate.FieldUpdatedBy:
		return m.UpdatedBy()
	case deathcertificate.FieldUpdatedWith:
		return m.UpdatedWith()
	case deathcertificate.FieldCause:
		return m.Cause()
	case deathcertificate.FieldComments:
		return m.Comments()
	case deathcertificate.FieldCertifiedAt:
		return m.CertifiedAt()
	case deathcertificate.FieldCertifierComments:
		return m.CertifierComments()
	case deathcertificate.FieldRequiresCertification:
		return m.RequiresCertification()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeathCertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deathcertificate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deathcertificate.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case deathcertificate.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case deathcertificate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deathcertificate.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case deathcertificate.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case deathcertificate.FieldCause:
		return m.OldCause(ctx)
	case deathcertificate.FieldComments:
		return m.OldComments(ctx)
	case deathcertificate.FieldCertifiedAt:
		return m.OldCertifiedAt(ctx)
	case deathcertificate.FieldCertifierComments:
		return m.OldCertifierComments(ctx)
	case deathcertificate.FieldRequiresCertification:
		return m.OldRequiresCertification(ctx)
	}
	return nil, fmt.Errorf("unknown DeathCertificate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathCertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deathcertificate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deathcertificate.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case deathcertificate.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case deathcertificate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deathcertificate.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case deathcertificate.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case deathcertificate.FieldCause:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCause(v)
		return nil
	case deathcertificate.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case deathcertificate.FieldCertifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertifiedAt(v)
		return nil
	case deathcertificate.FieldCertifierComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertifierComments(v)
		return nil
	case deathcertificate.FieldRequiresCertification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresCertification(v)
		return nil
	}
	return fmt.Errorf("unknown DeathCertificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeathCertificateMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, deathcertificate.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, deathcertificate.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeathCertificateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deathcertificate.FieldCreatedBy:
		return m.AddedCreatedBy()
	case deathcertificate.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathCertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deathcertificate.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case deathcertificate.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DeathCertificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeathCertificateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deathcertificate.FieldCreatedBy) {
		fields = append(fields, deathcertificate.FieldCreatedBy)
	}
	if m.FieldCleared(deathcertificate.FieldCreatedWith) {
		fields = append(fields, deathcertificate.FieldCreatedWith)
	}
	if m.FieldCleared(deathcertificate.FieldUpdatedBy) {
		fields = append(fields, deathcertificate.FieldUpdatedBy)
	}
	if m.FieldCleared(deathcertificate.FieldUpdatedWith) {
		fields = append(fields, deathcertificate.FieldUpdatedWith)
	}
	if m.FieldCleared(deathcertificate.FieldComments) {
		fields = append(fields, deathcertificate.FieldComments)
	}
	if m.FieldCleared(deathcertificate.FieldCertifiedAt) {
		fields = append(fields, deathcertificate.FieldCertifiedAt)
	}
	if m.FieldCleared(deathcertificate.FieldCertifierComments) {
		fields = append(fields, deathcertificate.FieldCertifierComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeathCertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeathCertificateMutation) ClearField(name string) error {
	switch name {
	case deathcertificate.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case deathcertificate.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case deathcertificate.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case deathcertificate.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case deathcertificate.FieldComments:
		m.ClearComments()
		return nil
	case deathcertificate.FieldCertifiedAt:
		m.ClearCertifiedAt()
		return nil
	case deathcertificate.FieldCertifierComments:
		m.ClearCertifierComments()
		return nil
	}
	return fmt.Errorf("unknown DeathCertificate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeathCertificateMutation) ResetField(name string) error {
	switch name {
	case deathcertificate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deathcertificate.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case deathcertificate.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case deathcertificate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deathcertificate.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case deathcertificate.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case deathcertificate.FieldCause:
		m.ResetCause()
		return nil
	case deathcertificate.FieldComments:
		m.ResetComments()
		return nil
	case deathcertificate.FieldCertifiedAt:
		m.ResetCertifiedAt()
		return nil
	case deathcertificate.FieldCertifierComments:
		m.ResetCertifierComments()
		return nil
	case deathcertificate.FieldRequiresCertification:
		m.ResetRequiresCertification()
		return nil
	}
	return fmt.Errorf("unknown DeathCertificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeathCertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.metadata != nil {
		edges = append(edges, deathcertificate.EdgeMetadata)
	}
	if m.decedent != nil {
		edges = append(edges, deathcertificate.EdgeDecedent)
	}
	if m.manner != nil {
		edges = append(edges, deathcertificate.EdgeManner)
	}
	if m.place != nil {
		edges = append(edges, deathcertificate.EdgePlace)
	}
	if m.certifier != nil {
		edges = append(edges, deathcertificate.EdgeCertifier)
	}
	if m.certified_by != nil {
		edges = append(edges, deathcertificate.EdgeCertifiedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeathCertificateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deathcertificate.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case deathcertificate.EdgeDecedent:
		if id := m.decedent; id != nil {
			return []ent.Value{*id}
		}
	case deathcertificate.EdgeManner:
		if id := m.manner; id != nil {
			return []ent.Value{*id}
		}
	case deathcertificate.EdgePlace:
		if id := m.place; id != nil {
			return []ent.Value{*id}
		}
	case deathcertificate.EdgeCertifier:
		if id := m.certifier; id != nil {
			return []ent.Value{*id}
		}
	case deathcertificate.EdgeCertifiedBy:
		if id := m.certified_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeathCertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeathCertificateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeathCertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmetadata {
		edges = append(edges, deathcertificate.EdgeMetadata)
	}
	if m.cleareddecedent {
		edges = append(edges, deathcertificate.EdgeDecedent)
	}
	if m.clearedmanner {
		edges = append(edges, deathcertificate.EdgeManner)
	}
	if m.clearedplace {
		edges = append(edges, deathcertificate.EdgePlace)
	}
	if m.clearedcertifier {
		edges = append(edges, deathcertificate.EdgeCertifier)
	}
	if m.clearedcertified_by {
		edges = append(edges, deathcertificate.EdgeCertifiedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeathCertificateMutation) EdgeCleared(name string) bool {
	switch name {
	case deathcertificate.EdgeMetadata:
		return m.clearedmetadata
	case deathcertificate.EdgeDecedent:
		return m.cleareddecedent
	case deathcertificate.EdgeManner:
		return m.clearedmanner
	case deathcertificate.EdgePlace:
		return m.clearedplace
	case deathcertificate.EdgeCertifier:
		return m.clearedcertifier
	case deathcertificate.EdgeCertifiedBy:
		return m.clearedcertified_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeathCertificateMutation) ClearEdge(name string) error {
	switch name {
	case deathcertificate.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case deathcertificate.EdgeDecedent:
		m.ClearDecedent()
		return nil
	case deathcertificate.EdgeManner:
		m.ClearManner()
		return nil
	case deathcertificate.EdgePlace:
		m.ClearPlace()
		return nil
	case deathcertificate.EdgeCertifier:
		m.ClearCertifier()
		return nil
	case deathcertificate.EdgeCertifiedBy:
		m.ClearCertifiedBy()
		return nil
	}
	return fmt.Errorf("unknown DeathCertificate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeathCertificateMutation) ResetEdge(name string) error {
	switch name {
	case deathcertificate.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case deathcertificate.EdgeDecedent:
		m.ResetDecedent()
		return nil
	case deathcertificate.EdgeManner:
		m.ResetManner()
		return nil
	case deathcertificate.EdgePlace:
		m.ResetPlace()
		return nil
	case deathcertificate.EdgeCertifier:
		m.ResetCertifier()
		return nil
	case deathcertificate.EdgeCertifiedBy:
		m.ResetCertifiedBy()
		return nil
	}
	return fmt.Errorf("unknown DeathCertificate edge %s", name)
}

// DeathCertifierMutation represents an operation that mutates the DeathCertifier nodes in the graph.
type DeathCertifierMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	created_by                *int
	addcreated_by             *int
	created_with              *string
	updated_at                *time.Time
	updated_by                *int
	addupdated_by             *int
	updated_with              *string
	short                     *string
	title                     *string
	description               *string
	clearedFields             map[string]struct{}
	metadata                  *int
	clearedmetadata           bool
	death_certificates        map[int]struct{}
	removeddeath_certificates map[int]struct{}
	cleareddeath_certificates bool
	done                      bool
	oldValue                  func(context.Context) (*DeathCertifier, error)
	predicates                []predicate.DeathCertifier
}

var _ ent.Mutation = (*DeathCertifierMutation)(nil)

// deathcertifierOption allows management of the mutation configuration using functional options.
type deathcertifierOption func(*DeathCertifierMutation)

// newDeathCertifierMutation creates new mutation for the DeathCertifier entity.
func newDeathCertifierMutation(c config, op Op, opts ...deathcertifierOption) *DeathCertifierMutation {
	m := &DeathCertifierMutation{
		config:        c,
		op:            op,
		typ:           TypeDeathCertifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeathCertifierID sets the ID field of the mutation.
func withDeathCertifierID(id int) deathcertifierOption {
	return func(m *DeathCertifierMutation) {
		var (
			err   error
			once  sync.Once
			value *DeathCertifier
		)
		m.oldValue = func(ctx context.Context) (*DeathCertifier, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeathCertifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeathCertifier sets the old DeathCertifier of the mutation.
func withDeathCertifier(node *DeathCertifier) deathcertifierOption {
	return func(m *DeathCertifierMutation) {
		m.oldValue = func(context.Context) (*DeathCertifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeathCertifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeathCertifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeathCertifierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DeathCertifierMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeathCertifierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeathCertifierMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DeathCertifierMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeathCertifierMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeathCertifierMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeathCertifierMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DeathCertifierMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[deathcertifier.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DeathCertifierMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[deathcertifier.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeathCertifierMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, deathcertifier.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *DeathCertifierMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *DeathCertifierMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *DeathCertifierMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[deathcertifier.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *DeathCertifierMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[deathcertifier.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *DeathCertifierMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, deathcertifier.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeathCertifierMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeathCertifierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeathCertifierMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeathCertifierMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeathCertifierMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeathCertifierMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeathCertifierMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DeathCertifierMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[deathcertifier.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DeathCertifierMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[deathcertifier.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeathCertifierMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, deathcertifier.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *DeathCertifierMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *DeathCertifierMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *DeathCertifierMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[deathcertifier.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *DeathCertifierMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[deathcertifier.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *DeathCertifierMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, deathcertifier.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *DeathCertifierMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *DeathCertifierMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *DeathCertifierMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *DeathCertifierMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DeathCertifierMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DeathCertifierMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *DeathCertifierMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeathCertifierMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeathCertifier entity.
// If the DeathCertifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathCertifierMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeathCertifierMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deathcertifier.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeathCertifierMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deathcertifier.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeathCertifierMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deathcertifier.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *DeathCertifierMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *DeathCertifierMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *DeathCertifierMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *DeathCertifierMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *DeathCertifierMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *DeathCertifierMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddDeathCertificateIDs adds the "death_certificates" edge to the DeathCertificate entity by ids.
func (m *DeathCertifierMutation) AddDeathCertificateIDs(ids ...int) {
	if m.death_certificates == nil {
		m.death_certificates = make(map[int]struct{})
	}
	for i := range ids {
		m.death_certificates[ids[i]] = struct{}{}
	}
}

// ClearDeathCertificates clears the "death_certificates" edge to the DeathCertificate entity.
func (m *DeathCertifierMutation) ClearDeathCertificates() {
	m.cleareddeath_certificates = true
}

// DeathCertificatesCleared reports if the "death_certificates" edge to the DeathCertificate entity was cleared.
func (m *DeathCertifierMutation) DeathCertificatesCleared() bool {
	return m.cleareddeath_certificates
}

// RemoveDeathCertificateIDs removes the "death_certificates" edge to the DeathCertificate entity by IDs.
func (m *DeathCertifierMutation) RemoveDeathCertificateIDs(ids ...int) {
	if m.removeddeath_certificates == nil {
		m.removeddeath_certificates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.death_certificates, ids[i])
		m.removeddeath_certificates[ids[i]] = struct{}{}
	}
}

// RemovedDeathCertificates returns the removed IDs of the "death_certificates" edge to the DeathCertificate entity.
func (m *DeathCertifierMutation) RemovedDeathCertificatesIDs() (ids []int) {
	for id := range m.removeddeath_certificates {
		ids = append(ids, id)
	}
	return
}

// DeathCertificatesIDs returns the "death_certificates" edge IDs in the mutation.
func (m *DeathCertifierMutation) DeathCertificatesIDs() (ids []int) {
	for id := range m.death_certificates {
		ids = append(ids, id)
	}
	return
}

// ResetDeathCertificates resets all changes to the "death_certificates" edge.
func (m *DeathCertifierMutation) ResetDeathCertificates() {
	m.death_certificates = nil
	m.cleareddeath_certificates = false
	m.removeddeath_certificates = nil
}

// Where appends a list predicates to the DeathCertifierMutation builder.
func (m *DeathCertifierMutation) Where(ps ...predicate.DeathCertifier) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeathCertifierMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeathCertifier).
func (m *DeathCertifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeathCertifierMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, deathcertifier.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, deathcertifier.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, deathcertifier.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, deathcertifier.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, deathcertifier.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, deathcertifier.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, deathcertifier.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, deathcertifier.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, deathcertifier.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeathCertifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deathcertifier.FieldCreatedAt:
		return m.CreatedAt()
	case deathcertifier.FieldCreatedBy:
		return m.CreatedBy()
	case deathcertifier.FieldCreatedWith:
		return m.CreatedWith()
	case deathcertifier.FieldUpdatedAt:
		return m.UpdatedAt()
	case deathcertifier.FieldUpdatedBy:
		return m.UpdatedBy()
	case deathcertifier.FieldUpdatedWith:
		return m.UpdatedWith()
	case deathcertifier.FieldShort:
		return m.Short()
	case deathcertifier.FieldTitle:
		return m.Title()
	case deathcertifier.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeathCertifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deathcertifier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deathcertifier.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case deathcertifier.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case deathcertifier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deathcertifier.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case deathcertifier.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case deathcertifier.FieldShort:
		return m.OldShort(ctx)
	case deathcertifier.FieldTitle:
		return m.OldTitle(ctx)
	case deathcertifier.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DeathCertifier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathCertifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deathcertifier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deathcertifier.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case deathcertifier.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case deathcertifier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deathcertifier.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case deathcertifier.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case deathcertifier.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case deathcertifier.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case deathcertifier.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DeathCertifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeathCertifierMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, deathcertifier.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, deathcertifier.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeathCertifierMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deathcertifier.FieldCreatedBy:
		return m.AddedCreatedBy()
	case deathcertifier.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathCertifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deathcertifier.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case deathcertifier.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DeathCertifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeathCertifierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deathcertifier.FieldCreatedBy) {
		fields = append(fields, deathcertifier.FieldCreatedBy)
	}
	if m.FieldCleared(deathcertifier.FieldCreatedWith) {
		fields = append(fields, deathcertifier.FieldCreatedWith)
	}
	if m.FieldCleared(deathcertifier.FieldUpdatedBy) {
		fields = append(fields, deathcertifier.FieldUpdatedBy)
	}
	if m.FieldCleared(deathcertifier.FieldUpdatedWith) {
		fields = append(fields, deathcertifier.FieldUpdatedWith)
	}
	if m.FieldCleared(deathcertifier.FieldDescription) {
		fields = append(fields, deathcertifier.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeathCertifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeathCertifierMutation) ClearField(name string) error {
	switch name {
	case deathcertifier.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case deathcertifier.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case deathcertifier.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case deathcertifier.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case deathcertifier.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DeathCertifier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeathCertifierMutation) ResetField(name string) error {
	switch name {
	case deathcertifier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deathcertifier.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case deathcertifier.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case deathcertifier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deathcertifier.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case deathcertifier.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case deathcertifier.FieldShort:
		m.ResetShort()
		return nil
	case deathcertifier.FieldTitle:
		m.ResetTitle()
		return nil
	case deathcertifier.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DeathCertifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeathCertifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, deathcertifier.EdgeMetadata)
	}
	if m.death_certificates != nil {
		edges = append(edges, deathcertifier.EdgeDeathCertificates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeathCertifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deathcertifier.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case deathcertifier.EdgeDeathCertificates:
		ids := make([]ent.Value, 0, len(m.death_certificates))
		for id := range m.death_certificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeathCertifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddeath_certificates != nil {
		edges = append(edges, deathcertifier.EdgeDeathCertificates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeathCertifierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deathcertifier.EdgeDeathCertificates:
		ids := make([]ent.Value, 0, len(m.removeddeath_certificates))
		for id := range m.removeddeath_certificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeathCertifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, deathcertifier.EdgeMetadata)
	}
	if m.cleareddeath_certificates {
		edges = append(edges, deathcertifier.EdgeDeathCertificates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeathCertifierMutation) EdgeCleared(name string) bool {
	switch name {
	case deathcertifier.EdgeMetadata:
		return m.clearedmetadata
	case deathcertifier.EdgeDeathCertificates:
		return m.cleareddeath_certificates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeathCertifierMutation) ClearEdge(name string) error {
	switch name {
	case deathcertifier.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown DeathCertifier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeathCertifierMutation) ResetEdge(name string) error {
	switch name {
	case deathcertifier.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case deathcertifier.EdgeDeathCertificates:
		m.ResetDeathCertificates()
		return nil
	}
	return fmt.Errorf("unknown DeathCertifier edge %s", name)
}

// DeathMannerMutation represents an operation that mutates the DeathManner nodes in the graph.
type DeathMannerMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	created_by                *int
	addcreated_by             *int
	created_with              *string
	updated_at                *time.Time
	updated_by                *int
	addupdated_by             *int
	updated_with              *string
	short                     *string
	title                     *string
	description               *string
	clearedFields             map[string]struct{}
	metadata                  *int
	clearedmetadata           bool
	death_certificates        map[int]struct{}
	removeddeath_certificates map[int]struct{}
	cleareddeath_certificates bool
	done                      bool
	oldValue                  func(context.Context) (*DeathManner, error)
	predicates                []predicate.DeathManner
}

var _ ent.Mutation = (*DeathMannerMutation)(nil)

// deathmannerOption allows management of the mutation configuration using functional options.
type deathmannerOption func(*DeathMannerMutation)

// newDeathMannerMutation creates new mutation for the DeathManner entity.
func newDeathMannerMutation(c config, op Op, opts ...deathmannerOption) *DeathMannerMutation {
	m := &DeathMannerMutation{
		config:        c,
		op:            op,
		typ:           TypeDeathManner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeathMannerID sets the ID field of the mutation.
func withDeathMannerID(id int) deathmannerOption {
	return func(m *DeathMannerMutation) {
		var (
			err   error
			once  sync.Once
			value *DeathManner
		)
		m.oldValue = func(ctx context.Context) (*DeathManner, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeathManner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeathManner sets the old DeathManner of the mutation.
func withDeathManner(node *DeathManner) deathmannerOption {
	return func(m *DeathMannerMutation) {
		m.oldValue = func(context.Context) (*DeathManner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeathMannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeathMannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeathMannerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DeathMannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeathMannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeathMannerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DeathMannerMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeathMannerMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeathMannerMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeathMannerMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DeathMannerMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[deathmanner.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DeathMannerMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[deathmanner.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeathMannerMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, deathmanner.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *DeathMannerMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *DeathMannerMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *DeathMannerMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[deathmanner.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *DeathMannerMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[deathmanner.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *DeathMannerMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, deathmanner.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeathMannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeathMannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeathMannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeathMannerMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeathMannerMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeathMannerMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeathMannerMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DeathMannerMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[deathmanner.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DeathMannerMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[deathmanner.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeathMannerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, deathmanner.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *DeathMannerMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *DeathMannerMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *DeathMannerMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[deathmanner.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *DeathMannerMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[deathmanner.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *DeathMannerMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, deathmanner.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *DeathMannerMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *DeathMannerMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *DeathMannerMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *DeathMannerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DeathMannerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DeathMannerMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *DeathMannerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeathMannerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeathManner entity.
// If the DeathManner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathMannerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeathMannerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deathmanner.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeathMannerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deathmanner.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeathMannerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deathmanner.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *DeathMannerMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *DeathMannerMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *DeathMannerMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *DeathMannerMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *DeathMannerMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *DeathMannerMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddDeathCertificateIDs adds the "death_certificates" edge to the DeathCertificate entity by ids.
func (m *DeathMannerMutation) AddDeathCertificateIDs(ids ...int) {
	if m.death_certificates == nil {
		m.death_certificates = make(map[int]struct{})
	}
	for i := range ids {
		m.death_certificates[ids[i]] = struct{}{}
	}
}

// ClearDeathCertificates clears the "death_certificates" edge to the DeathCertificate entity.
func (m *DeathMannerMutation) ClearDeathCertificates() {
	m.cleareddeath_certificates = true
}

// DeathCertificatesCleared reports if the "death_certificates" edge to the DeathCertificate entity was cleared.
func (m *DeathMannerMutation) DeathCertificatesCleared() bool {
	return m.cleareddeath_certificates
}

// RemoveDeathCertificateIDs removes the "death_certificates" edge to the DeathCertificate entity by IDs.
func (m *DeathMannerMutation) RemoveDeathCertificateIDs(ids ...int) {
	if m.removeddeath_certificates == nil {
		m.removeddeath_certificates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.death_certificates, ids[i])
		m.removeddeath_certificates[ids[i]] = struct{}{}
	}
}

// RemovedDeathCertificates returns the removed IDs of the "death_certificates" edge to the DeathCertificate entity.
func (m *DeathMannerMutation) RemovedDeathCertificatesIDs() (ids []int) {
	for id := range m.removeddeath_certificates {
		ids = append(ids, id)
	}
	return
}

// DeathCertificatesIDs returns the "death_certificates" edge IDs in the mutation.
func (m *DeathMannerMutation) DeathCertificatesIDs() (ids []int) {
	for id := range m.death_certificates {
		ids = append(ids, id)
	}
	return
}

// ResetDeathCertificates resets all changes to the "death_certificates" edge.
func (m *DeathMannerMutation) ResetDeathCertificates() {
	m.death_certificates = nil
	m.cleareddeath_certificates = false
	m.removeddeath_certificates = nil
}

// Where appends a list predicates to the DeathMannerMutation builder.
func (m *DeathMannerMutation) Where(ps ...predicate.DeathManner) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeathMannerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeathManner).
func (m *DeathMannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeathMannerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, deathmanner.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, deathmanner.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, deathmanner.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, deathmanner.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, deathmanner.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, deathmanner.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, deathmanner.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, deathmanner.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, deathmanner.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeathMannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deathmanner.FieldCreatedAt:
		return m.CreatedAt()
	case deathmanner.FieldCreatedBy:
		return m.CreatedBy()
	case deathmanner.FieldCreatedWith:
		return m.CreatedWith()
	case deathmanner.FieldUpdatedAt:
		return m.UpdatedAt()
	case deathmanner.FieldUpdatedBy:
		return m.UpdatedBy()
	case deathmanner.FieldUpdatedWith:
		return m.UpdatedWith()
	case deathmanner.FieldShort:
		return m.Short()
	case deathmanner.FieldTitle:
		return m.Title()
	case deathmanner.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeathMannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deathmanner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deathmanner.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case deathmanner.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case deathmanner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deathmanner.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case deathmanner.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case deathmanner.FieldShort:
		return m.OldShort(ctx)
	case deathmanner.FieldTitle:
		return m.OldTitle(ctx)
	case deathmanner.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DeathManner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathMannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deathmanner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deathmanner.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case deathmanner.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case deathmanner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deathmanner.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case deathmanner.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case deathmanner.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case deathmanner.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case deathmanner.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DeathManner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeathMannerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, deathmanner.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, deathmanner.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeathMannerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deathmanner.FieldCreatedBy:
		return m.AddedCreatedBy()
	case deathmanner.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathMannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deathmanner.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case deathmanner.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DeathManner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeathMannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deathmanner.FieldCreatedBy) {
		fields = append(fields, deathmanner.FieldCreatedBy)
	}
	if m.FieldCleared(deathmanner.FieldCreatedWith) {
		fields = append(fields, deathmanner.FieldCreatedWith)
	}
	if m.FieldCleared(deathmanner.FieldUpdatedBy) {
		fields = append(fields, deathmanner.FieldUpdatedBy)
	}
	if m.FieldCleared(deathmanner.FieldUpdatedWith) {
		fields = append(fields, deathmanner.FieldUpdatedWith)
	}
	if m.FieldCleared(deathmanner.FieldDescription) {
		fields = append(fields, deathmanner.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeathMannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeathMannerMutation) ClearField(name string) error {
	switch name {
	case deathmanner.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case deathmanner.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case deathmanner.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case deathmanner.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case deathmanner.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DeathManner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeathMannerMutation) ResetField(name string) error {
	switch name {
	case deathmanner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deathmanner.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case deathmanner.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case deathmanner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deathmanner.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case deathmanner.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case deathmanner.FieldShort:
		m.ResetShort()
		return nil
	case deathmanner.FieldTitle:
		m.ResetTitle()
		return nil
	case deathmanner.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DeathManner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeathMannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, deathmanner.EdgeMetadata)
	}
	if m.death_certificates != nil {
		edges = append(edges, deathmanner.EdgeDeathCertificates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeathMannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deathmanner.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case deathmanner.EdgeDeathCertificates:
		ids := make([]ent.Value, 0, len(m.death_certificates))
		for id := range m.death_certificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeathMannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddeath_certificates != nil {
		edges = append(edges, deathmanner.EdgeDeathCertificates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeathMannerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deathmanner.EdgeDeathCertificates:
		ids := make([]ent.Value, 0, len(m.removeddeath_certificates))
		for id := range m.removeddeath_certificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeathMannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, deathmanner.EdgeMetadata)
	}
	if m.cleareddeath_certificates {
		edges = append(edges, deathmanner.EdgeDeathCertificates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeathMannerMutation) EdgeCleared(name string) bool {
	switch name {
	case deathmanner.EdgeMetadata:
		return m.clearedmetadata
	case deathmanner.EdgeDeathCertificates:
		return m.cleareddeath_certificates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeathMannerMutation) ClearEdge(name string) error {
	switch name {
	case deathmanner.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown DeathManner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeathMannerMutation) ResetEdge(name string) error {
	switch name {
	case deathmanner.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case deathmanner.EdgeDeathCertificates:
		m.ResetDeathCertificates()
		return nil
	}
	return fmt.Errorf("unknown DeathManner edge %s", name)
}

// DeathPlaceMutation represents an operation that mutates the DeathPlace nodes in the graph.
type DeathPlaceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	created_by                *int
	addcreated_by             *int
	created_with              *string
	updated_at                *time.Time
	updated_by                *int
	addupdated_by             *int
	updated_with              *string
	short                     *string
	title                     *string
	description               *string
	clearedFields             map[string]struct{}
	metadata                  *int
	clearedmetadata           bool
	death_certificates        map[int]struct{}
	removeddeath_certificates map[int]struct{}
	cleareddeath_certificates bool
	done                      bool
	oldValue                  func(context.Context) (*DeathPlace, error)
	predicates                []predicate.DeathPlace
}

var _ ent.Mutation = (*DeathPlaceMutation)(nil)

// deathplaceOption allows management of the mutation configuration using functional options.
type deathplaceOption func(*DeathPlaceMutation)

// newDeathPlaceMutation creates new mutation for the DeathPlace entity.
func newDeathPlaceMutation(c config, op Op, opts ...deathplaceOption) *DeathPlaceMutation {
	m := &DeathPlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeDeathPlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeathPlaceID sets the ID field of the mutation.
func withDeathPlaceID(id int) deathplaceOption {
	return func(m *DeathPlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *DeathPlace
		)
		m.oldValue = func(ctx context.Context) (*DeathPlace, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeathPlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeathPlace sets the old DeathPlace of the mutation.
func withDeathPlace(node *DeathPlace) deathplaceOption {
	return func(m *DeathPlaceMutation) {
		m.oldValue = func(context.Context) (*DeathPlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeathPlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeathPlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeathPlaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DeathPlaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeathPlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeathPlaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DeathPlaceMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeathPlaceMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeathPlaceMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeathPlaceMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DeathPlaceMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[deathplace.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DeathPlaceMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[deathplace.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeathPlaceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, deathplace.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *DeathPlaceMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *DeathPlaceMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *DeathPlaceMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[deathplace.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *DeathPlaceMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[deathplace.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *DeathPlaceMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, deathplace.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeathPlaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeathPlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeathPlaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeathPlaceMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeathPlaceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeathPlaceMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeathPlaceMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DeathPlaceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[deathplace.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DeathPlaceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[deathplace.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeathPlaceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, deathplace.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *DeathPlaceMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *DeathPlaceMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *DeathPlaceMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[deathplace.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *DeathPlaceMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[deathplace.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *DeathPlaceMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, deathplace.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *DeathPlaceMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *DeathPlaceMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *DeathPlaceMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *DeathPlaceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DeathPlaceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DeathPlaceMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *DeathPlaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeathPlaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeathPlace entity.
// If the DeathPlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeathPlaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeathPlaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deathplace.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeathPlaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deathplace.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeathPlaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deathplace.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *DeathPlaceMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *DeathPlaceMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *DeathPlaceMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *DeathPlaceMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *DeathPlaceMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *DeathPlaceMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddDeathCertificateIDs adds the "death_certificates" edge to the DeathCertificate entity by ids.
func (m *DeathPlaceMutation) AddDeathCertificateIDs(ids ...int) {
	if m.death_certificates == nil {
		m.death_certificates = make(map[int]struct{})
	}
	for i := range ids {
		m.death_certificates[ids[i]] = struct{}{}
	}
}

// ClearDeathCertificates clears the "death_certificates" edge to the DeathCertificate entity.
func (m *DeathPlaceMutation) ClearDeathCertificates() {
	m.cleareddeath_certificates = true
}

// DeathCertificatesCleared reports if the "death_certificates" edge to the DeathCertificate entity was cleared.
func (m *DeathPlaceMutation) DeathCertificatesCleared() bool {
	return m.cleareddeath_certificates
}

// RemoveDeathCertificateIDs removes the "death_certificates" edge to the DeathCertificate entity by IDs.
func (m *DeathPlaceMutation) RemoveDeathCertificateIDs(ids ...int) {
	if m.removeddeath_certificates == nil {
		m.removeddeath_certificates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.death_certificates, ids[i])
		m.removeddeath_certificates[ids[i]] = struct{}{}
	}
}

// RemovedDeathCertificates returns the removed IDs of the "death_certificates" edge to the DeathCertificate entity.
func (m *DeathPlaceMutation) RemovedDeathCertificatesIDs() (ids []int) {
	for id := range m.removeddeath_certificates {
		ids = append(ids, id)
	}
	return
}

// DeathCertificatesIDs returns the "death_certificates" edge IDs in the mutation.
func (m *DeathPlaceMutation) DeathCertificatesIDs() (ids []int) {
	for id := range m.death_certificates {
		ids = append(ids, id)
	}
	return
}

// ResetDeathCertificates resets all changes to the "death_certificates" edge.
func (m *DeathPlaceMutation) ResetDeathCertificates() {
	m.death_certificates = nil
	m.cleareddeath_certificates = false
	m.removeddeath_certificates = nil
}

// Where appends a list predicates to the DeathPlaceMutation builder.
func (m *DeathPlaceMutation) Where(ps ...predicate.DeathPlace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeathPlaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeathPlace).
func (m *DeathPlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeathPlaceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, deathplace.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, deathplace.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, deathplace.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, deathplace.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, deathplace.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, deathplace.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, deathplace.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, deathplace.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, deathplace.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeathPlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deathplace.FieldCreatedAt:
		return m.CreatedAt()
	case deathplace.FieldCreatedBy:
		return m.CreatedBy()
	case deathplace.FieldCreatedWith:
		return m.CreatedWith()
	case deathplace.FieldUpdatedAt:
		return m.UpdatedAt()
	case deathplace.FieldUpdatedBy:
		return m.UpdatedBy()
	case deathplace.FieldUpdatedWith:
		return m.UpdatedWith()
	case deathplace.FieldShort:
		return m.Short()
	case deathplace.FieldTitle:
		return m.Title()
	case deathplace.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeathPlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deathplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deathplace.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case deathplace.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case deathplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deathplace.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case deathplace.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case deathplace.FieldShort:
		return m.OldShort(ctx)
	case deathplace.FieldTitle:
		return m.OldTitle(ctx)
	case deathplace.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DeathPlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathPlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deathplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deathplace.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case deathplace.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case deathplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deathplace.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case deathplace.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case deathplace.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case deathplace.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case deathplace.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DeathPlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeathPlaceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, deathplace.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, deathplace.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeathPlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deathplace.FieldCreatedBy:
		return m.AddedCreatedBy()
	case deathplace.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeathPlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deathplace.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case deathplace.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown DeathPlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeathPlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deathplace.FieldCreatedBy) {
		fields = append(fields, deathplace.FieldCreatedBy)
	}
	if m.FieldCleared(deathplace.FieldCreatedWith) {
		fields = append(fields, deathplace.FieldCreatedWith)
	}
	if m.FieldCleared(deathplace.FieldUpdatedBy) {
		fields = append(fields, deathplace.FieldUpdatedBy)
	}
	if m.FieldCleared(deathplace.FieldUpdatedWith) {
		fields = append(fields, deathplace.FieldUpdatedWith)
	}
	if m.FieldCleared(deathplace.FieldDescription) {
		fields = append(fields, deathplace.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeathPlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeathPlaceMutation) ClearField(name string) error {
	switch name {
	case deathplace.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case deathplace.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case deathplace.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case deathplace.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case deathplace.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DeathPlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeathPlaceMutation) ResetField(name string) error {
	switch name {
	case deathplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deathplace.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case deathplace.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case deathplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deathplace.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case deathplace.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case deathplace.FieldShort:
		m.ResetShort()
		return nil
	case deathplace.FieldTitle:
		m.ResetTitle()
		return nil
	case deathplace.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DeathPlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeathPlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, deathplace.EdgeMetadata)
	}
	if m.death_certificates != nil {
		edges = append(edges, deathplace.EdgeDeathCertificates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeathPlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deathplace.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case deathplace.EdgeDeathCertificates:
		ids := make([]ent.Value, 0, len(m.death_certificates))
		for id := range m.death_certificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeathPlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddeath_certificates != nil {
		edges = append(edges, deathplace.EdgeDeathCertificates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeathPlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deathplace.EdgeDeathCertificates:
		ids := make([]ent.Value, 0, len(m.removeddeath_certificates))
		for id := range m.removeddeath_certificates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeathPlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, deathplace.EdgeMetadata)
	}
	if m.cleareddeath_certificates {
		edges = append(edges, deathplace.EdgeDeathCertificates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeathPlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case deathplace.EdgeMetadata:
		return m.clearedmetadata
	case deathplace.EdgeDeathCertificates:
		return m.cleareddeath_certificates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeathPlaceMutation) ClearEdge(name string) error {
	switch name {
	case deathplace.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown DeathPlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeathPlaceMutation) ResetEdge(name string) error {
	switch name {
	case deathplace.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case deathplace.EdgeDeathCertificates:
		m.ResetDeathCertificates()
		return nil
	}
	return fmt.Errorf("unknown DeathPlace edge %s", name)
}

// EthnicityMutation represents an operation that mutates the Ethnicity nodes in the graph.
type EthnicityMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *int
	addcreated_by   *int
	created_with    *string
	updated_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_with    *string
	short           *string
	title           *string
	description     *string
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	people          map[int]struct{}
	removedpeople   map[int]struct{}
	clearedpeople   bool
	done            bool
	oldValue        func(context.Context) (*Ethnicity, error)
	predicates      []predicate.Ethnicity
}

var _ ent.Mutation = (*EthnicityMutation)(nil)

// ethnicityOption allows management of the mutation configuration using functional options.
type ethnicityOption func(*EthnicityMutation)

// newEthnicityMutation creates new mutation for the Ethnicity entity.
func newEthnicityMutation(c config, op Op, opts ...ethnicityOption) *EthnicityMutation {
	m := &EthnicityMutation{
		config:        c,
		op:            op,
		typ:           TypeEthnicity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEthnicityID sets the ID field of the mutation.
func withEthnicityID(id int) ethnicityOption {
	return func(m *EthnicityMutation) {
		var (
			err   error
			once  sync.Once
			value *Ethnicity
		)
		m.oldValue = func(ctx context.Context) (*Ethnicity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ethnicity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEthnicity sets the old Ethnicity of the mutation.
func withEthnicity(node *Ethnicity) ethnicityOption {
	return func(m *EthnicityMutation) {
		m.oldValue = func(context.Context) (*Ethnicity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EthnicityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EthnicityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EthnicityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *EthnicityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EthnicityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EthnicityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EthnicityMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EthnicityMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *EthnicityMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EthnicityMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EthnicityMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[ethnicity.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EthnicityMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[ethnicity.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EthnicityMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, ethnicity.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *EthnicityMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *EthnicityMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *EthnicityMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[ethnicity.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *EthnicityMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[ethnicity.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *EthnicityMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, ethnicity.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EthnicityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EthnicityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EthnicityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EthnicityMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EthnicityMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EthnicityMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EthnicityMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EthnicityMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[ethnicity.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EthnicityMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[ethnicity.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EthnicityMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, ethnicity.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *EthnicityMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *EthnicityMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *EthnicityMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[ethnicity.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *EthnicityMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[ethnicity.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *EthnicityMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, ethnicity.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *EthnicityMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *EthnicityMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *EthnicityMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *EthnicityMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EthnicityMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EthnicityMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *EthnicityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EthnicityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ethnicity entity.
// If the Ethnicity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnicityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EthnicityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ethnicity.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EthnicityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ethnicity.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EthnicityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ethnicity.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *EthnicityMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *EthnicityMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *EthnicityMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *EthnicityMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *EthnicityMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *EthnicityMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *EthnicityMutation) AddPersonIDs(ids ...int) {
	if m.people == nil {
		m.people = make(map[int]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *EthnicityMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *EthnicityMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *EthnicityMutation) RemovePersonIDs(ids ...int) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *EthnicityMutation) RemovedPeopleIDs() (ids []int) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *EthnicityMutation) PeopleIDs() (ids []int) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *EthnicityMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// Where appends a list predicates to the EthnicityMutation builder.
func (m *EthnicityMutation) Where(ps ...predicate.Ethnicity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EthnicityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ethnicity).
func (m *EthnicityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EthnicityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, ethnicity.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, ethnicity.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, ethnicity.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, ethnicity.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, ethnicity.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, ethnicity.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, ethnicity.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, ethnicity.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, ethnicity.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EthnicityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ethnicity.FieldCreatedAt:
		return m.CreatedAt()
	case ethnicity.FieldCreatedBy:
		return m.CreatedBy()
	case ethnicity.FieldCreatedWith:
		return m.CreatedWith()
	case ethnicity.FieldUpdatedAt:
		return m.UpdatedAt()
	case ethnicity.FieldUpdatedBy:
		return m.UpdatedBy()
	case ethnicity.FieldUpdatedWith:
		return m.UpdatedWith()
	case ethnicity.FieldShort:
		return m.Short()
	case ethnicity.FieldTitle:
		return m.Title()
	case ethnicity.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EthnicityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ethnicity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ethnicity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ethnicity.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case ethnicity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ethnicity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case ethnicity.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case ethnicity.FieldShort:
		return m.OldShort(ctx)
	case ethnicity.FieldTitle:
		return m.OldTitle(ctx)
	case ethnicity.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Ethnicity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EthnicityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ethnicity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ethnicity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ethnicity.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case ethnicity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ethnicity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case ethnicity.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case ethnicity.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case ethnicity.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case ethnicity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Ethnicity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EthnicityMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, ethnicity.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, ethnicity.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EthnicityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ethnicity.FieldCreatedBy:
		return m.AddedCreatedBy()
	case ethnicity.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EthnicityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ethnicity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case ethnicity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Ethnicity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EthnicityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ethnicity.FieldCreatedBy) {
		fields = append(fields, ethnicity.FieldCreatedBy)
	}
	if m.FieldCleared(ethnicity.FieldCreatedWith) {
		fields = append(fields, ethnicity.FieldCreatedWith)
	}
	if m.FieldCleared(ethnicity.FieldUpdatedBy) {
		fields = append(fields, ethnicity.FieldUpdatedBy)
	}
	if m.FieldCleared(ethnicity.FieldUpdatedWith) {
		fields = append(fields, ethnicity.FieldUpdatedWith)
	}
	if m.FieldCleared(ethnicity.FieldDescription) {
		fields = append(fields, ethnicity.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EthnicityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EthnicityMutation) ClearField(name string) error {
	switch name {
	case ethnicity.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case ethnicity.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case ethnicity.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case ethnicity.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case ethnicity.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Ethnicity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EthnicityMutation) ResetField(name string) error {
	switch name {
	case ethnicity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ethnicity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ethnicity.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case ethnicity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ethnicity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case ethnicity.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case ethnicity.FieldShort:
		m.ResetShort()
		return nil
	case ethnicity.FieldTitle:
		m.ResetTitle()
		return nil
	case ethnicity.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Ethnicity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EthnicityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, ethnicity.EdgeMetadata)
	}
	if m.people != nil {
		edges = append(edges, ethnicity.EdgePeople)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EthnicityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ethnicity.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case ethnicity.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EthnicityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpeople != nil {
		edges = append(edges, ethnicity.EdgePeople)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EthnicityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ethnicity.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EthnicityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, ethnicity.EdgeMetadata)
	}
	if m.clearedpeople {
		edges = append(edges, ethnicity.EdgePeople)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EthnicityMutation) EdgeCleared(name string) bool {
	switch name {
	case ethnicity.EdgeMetadata:
		return m.clearedmetadata
	case ethnicity.EdgePeople:
		return m.clearedpeople
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EthnicityMutation) ClearEdge(name string) error {
	switch name {
	case ethnicity.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Ethnicity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EthnicityMutation) ResetEdge(name string) error {
	switch name {
	case ethnicity.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case ethnicity.EdgePeople:
		m.ResetPeople()
		return nil
	}
	return fmt.Errorf("unknown Ethnicity edge %s", name)
}

// GameServerMutation represents an operation that mutates the GameServer nodes in the graph.
type GameServerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *int
	addcreated_by   *int
	created_with    *string
	updated_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_with    *string
	name            *string
	description     *string
	secret          *string
	ip_address      *string
	monitoring      *bool
	disabled_at     *time.Time
	last_contact_at *time.Time
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	players         map[int]struct{}
	removedplayers  map[int]struct{}
	clearedplayers  bool
	done            bool
	oldValue        func(context.Context) (*GameServer, error)
	predicates      []predicate.GameServer
}

var _ ent.Mutation = (*GameServerMutation)(nil)

// gameserverOption allows management of the mutation configuration using functional options.
type gameserverOption func(*GameServerMutation)

// newGameServerMutation creates new mutation for the GameServer entity.
func newGameServerMutation(c config, op Op, opts ...gameserverOption) *GameServerMutation {
	m := &GameServerMutation{
		config:        c,
		op:            op,
		typ:           TypeGameServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameServerID sets the ID field of the mutation.
func withGameServerID(id int) gameserverOption {
	return func(m *GameServerMutation) {
		var (
			err   error
			once  sync.Once
			value *GameServer
		)
		m.oldValue = func(ctx context.Context) (*GameServer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameServer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameServer sets the old GameServer of the mutation.
func withGameServer(node *GameServer) gameserverOption {
	return func(m *GameServerMutation) {
		m.oldValue = func(context.Context) (*GameServer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameServerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GameServerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameServerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameServerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *GameServerMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GameServerMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *GameServerMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *GameServerMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GameServerMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[gameserver.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GameServerMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GameServerMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, gameserver.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *GameServerMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *GameServerMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *GameServerMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[gameserver.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *GameServerMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *GameServerMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, gameserver.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GameServerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GameServerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GameServerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GameServerMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GameServerMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *GameServerMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *GameServerMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GameServerMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[gameserver.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GameServerMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GameServerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, gameserver.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *GameServerMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *GameServerMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *GameServerMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[gameserver.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *GameServerMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *GameServerMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, gameserver.FieldUpdatedWith)
}

// SetName sets the "name" field.
func (m *GameServerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GameServerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GameServerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GameServerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GameServerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *GameServerMutation) ResetDescription() {
	m.description = nil
}

// SetSecret sets the "secret" field.
func (m *GameServerMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *GameServerMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *GameServerMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[gameserver.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *GameServerMutation) SecretCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *GameServerMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, gameserver.FieldSecret)
}

// SetIPAddress sets the "ip_address" field.
func (m *GameServerMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *GameServerMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *GameServerMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetMonitoring sets the "monitoring" field.
func (m *GameServerMutation) SetMonitoring(b bool) {
	m.monitoring = &b
}

// Monitoring returns the value of the "monitoring" field in the mutation.
func (m *GameServerMutation) Monitoring() (r bool, exists bool) {
	v := m.monitoring
	if v == nil {
		return
	}
	return *v, true
}

// OldMonitoring returns the old "monitoring" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldMonitoring(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMonitoring is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMonitoring requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonitoring: %w", err)
	}
	return oldValue.Monitoring, nil
}

// ClearMonitoring clears the value of the "monitoring" field.
func (m *GameServerMutation) ClearMonitoring() {
	m.monitoring = nil
	m.clearedFields[gameserver.FieldMonitoring] = struct{}{}
}

// MonitoringCleared returns if the "monitoring" field was cleared in this mutation.
func (m *GameServerMutation) MonitoringCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldMonitoring]
	return ok
}

// ResetMonitoring resets all changes to the "monitoring" field.
func (m *GameServerMutation) ResetMonitoring() {
	m.monitoring = nil
	delete(m.clearedFields, gameserver.FieldMonitoring)
}

// SetDisabledAt sets the "disabled_at" field.
func (m *GameServerMutation) SetDisabledAt(t time.Time) {
	m.disabled_at = &t
}

// DisabledAt returns the value of the "disabled_at" field in the mutation.
func (m *GameServerMutation) DisabledAt() (r time.Time, exists bool) {
	v := m.disabled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabledAt returns the old "disabled_at" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldDisabledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabledAt: %w", err)
	}
	return oldValue.DisabledAt, nil
}

// ClearDisabledAt clears the value of the "disabled_at" field.
func (m *GameServerMutation) ClearDisabledAt() {
	m.disabled_at = nil
	m.clearedFields[gameserver.FieldDisabledAt] = struct{}{}
}

// DisabledAtCleared returns if the "disabled_at" field was cleared in this mutation.
func (m *GameServerMutation) DisabledAtCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldDisabledAt]
	return ok
}

// ResetDisabledAt resets all changes to the "disabled_at" field.
func (m *GameServerMutation) ResetDisabledAt() {
	m.disabled_at = nil
	delete(m.clearedFields, gameserver.FieldDisabledAt)
}

// SetLastContactAt sets the "last_contact_at" field.
func (m *GameServerMutation) SetLastContactAt(t time.Time) {
	m.last_contact_at = &t
}

// LastContactAt returns the value of the "last_contact_at" field in the mutation.
func (m *GameServerMutation) LastContactAt() (r time.Time, exists bool) {
	v := m.last_contact_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastContactAt returns the old "last_contact_at" field's value of the GameServer entity.
// If the GameServer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameServerMutation) OldLastContactAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastContactAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastContactAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastContactAt: %w", err)
	}
	return oldValue.LastContactAt, nil
}

// ClearLastContactAt clears the value of the "last_contact_at" field.
func (m *GameServerMutation) ClearLastContactAt() {
	m.last_contact_at = nil
	m.clearedFields[gameserver.FieldLastContactAt] = struct{}{}
}

// LastContactAtCleared returns if the "last_contact_at" field was cleared in this mutation.
func (m *GameServerMutation) LastContactAtCleared() bool {
	_, ok := m.clearedFields[gameserver.FieldLastContactAt]
	return ok
}

// ResetLastContactAt resets all changes to the "last_contact_at" field.
func (m *GameServerMutation) ResetLastContactAt() {
	m.last_contact_at = nil
	delete(m.clearedFields, gameserver.FieldLastContactAt)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *GameServerMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *GameServerMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *GameServerMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *GameServerMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *GameServerMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *GameServerMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddPlayerIDs adds the "players" edge to the Player entity by ids.
func (m *GameServerMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *GameServerMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *GameServerMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the "players" edge to the Player entity by IDs.
func (m *GameServerMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.players, ids[i])
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed IDs of the "players" edge to the Player entity.
func (m *GameServerMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
func (m *GameServerMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *GameServerMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// Where appends a list predicates to the GameServerMutation builder.
func (m *GameServerMutation) Where(ps ...predicate.GameServer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GameServerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GameServer).
func (m *GameServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameServerMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, gameserver.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, gameserver.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, gameserver.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, gameserver.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, gameserver.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, gameserver.FieldUpdatedWith)
	}
	if m.name != nil {
		fields = append(fields, gameserver.FieldName)
	}
	if m.description != nil {
		fields = append(fields, gameserver.FieldDescription)
	}
	if m.secret != nil {
		fields = append(fields, gameserver.FieldSecret)
	}
	if m.ip_address != nil {
		fields = append(fields, gameserver.FieldIPAddress)
	}
	if m.monitoring != nil {
		fields = append(fields, gameserver.FieldMonitoring)
	}
	if m.disabled_at != nil {
		fields = append(fields, gameserver.FieldDisabledAt)
	}
	if m.last_contact_at != nil {
		fields = append(fields, gameserver.FieldLastContactAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameserver.FieldCreatedAt:
		return m.CreatedAt()
	case gameserver.FieldCreatedBy:
		return m.CreatedBy()
	case gameserver.FieldCreatedWith:
		return m.CreatedWith()
	case gameserver.FieldUpdatedAt:
		return m.UpdatedAt()
	case gameserver.FieldUpdatedBy:
		return m.UpdatedBy()
	case gameserver.FieldUpdatedWith:
		return m.UpdatedWith()
	case gameserver.FieldName:
		return m.Name()
	case gameserver.FieldDescription:
		return m.Description()
	case gameserver.FieldSecret:
		return m.Secret()
	case gameserver.FieldIPAddress:
		return m.IPAddress()
	case gameserver.FieldMonitoring:
		return m.Monitoring()
	case gameserver.FieldDisabledAt:
		return m.DisabledAt()
	case gameserver.FieldLastContactAt:
		return m.LastContactAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameserver.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gameserver.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case gameserver.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case gameserver.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gameserver.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case gameserver.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case gameserver.FieldName:
		return m.OldName(ctx)
	case gameserver.FieldDescription:
		return m.OldDescription(ctx)
	case gameserver.FieldSecret:
		return m.OldSecret(ctx)
	case gameserver.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case gameserver.FieldMonitoring:
		return m.OldMonitoring(ctx)
	case gameserver.FieldDisabledAt:
		return m.OldDisabledAt(ctx)
	case gameserver.FieldLastContactAt:
		return m.OldLastContactAt(ctx)
	}
	return nil, fmt.Errorf("unknown GameServer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameserver.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gameserver.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case gameserver.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case gameserver.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gameserver.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case gameserver.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case gameserver.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case gameserver.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case gameserver.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case gameserver.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case gameserver.FieldMonitoring:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonitoring(v)
		return nil
	case gameserver.FieldDisabledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabledAt(v)
		return nil
	case gameserver.FieldLastContactAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastContactAt(v)
		return nil
	}
	return fmt.Errorf("unknown GameServer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameServerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, gameserver.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, gameserver.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameServerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gameserver.FieldCreatedBy:
		return m.AddedCreatedBy()
	case gameserver.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gameserver.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case gameserver.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown GameServer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gameserver.FieldCreatedBy) {
		fields = append(fields, gameserver.FieldCreatedBy)
	}
	if m.FieldCleared(gameserver.FieldCreatedWith) {
		fields = append(fields, gameserver.FieldCreatedWith)
	}
	if m.FieldCleared(gameserver.FieldUpdatedBy) {
		fields = append(fields, gameserver.FieldUpdatedBy)
	}
	if m.FieldCleared(gameserver.FieldUpdatedWith) {
		fields = append(fields, gameserver.FieldUpdatedWith)
	}
	if m.FieldCleared(gameserver.FieldSecret) {
		fields = append(fields, gameserver.FieldSecret)
	}
	if m.FieldCleared(gameserver.FieldMonitoring) {
		fields = append(fields, gameserver.FieldMonitoring)
	}
	if m.FieldCleared(gameserver.FieldDisabledAt) {
		fields = append(fields, gameserver.FieldDisabledAt)
	}
	if m.FieldCleared(gameserver.FieldLastContactAt) {
		fields = append(fields, gameserver.FieldLastContactAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameServerMutation) ClearField(name string) error {
	switch name {
	case gameserver.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case gameserver.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case gameserver.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case gameserver.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case gameserver.FieldSecret:
		m.ClearSecret()
		return nil
	case gameserver.FieldMonitoring:
		m.ClearMonitoring()
		return nil
	case gameserver.FieldDisabledAt:
		m.ClearDisabledAt()
		return nil
	case gameserver.FieldLastContactAt:
		m.ClearLastContactAt()
		return nil
	}
	return fmt.Errorf("unknown GameServer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameServerMutation) ResetField(name string) error {
	switch name {
	case gameserver.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gameserver.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case gameserver.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case gameserver.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gameserver.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case gameserver.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case gameserver.FieldName:
		m.ResetName()
		return nil
	case gameserver.FieldDescription:
		m.ResetDescription()
		return nil
	case gameserver.FieldSecret:
		m.ResetSecret()
		return nil
	case gameserver.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case gameserver.FieldMonitoring:
		m.ResetMonitoring()
		return nil
	case gameserver.FieldDisabledAt:
		m.ResetDisabledAt()
		return nil
	case gameserver.FieldLastContactAt:
		m.ResetLastContactAt()
		return nil
	}
	return fmt.Errorf("unknown GameServer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, gameserver.EdgeMetadata)
	}
	if m.players != nil {
		edges = append(edges, gameserver.EdgePlayers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameserver.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case gameserver.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedplayers != nil {
		edges = append(edges, gameserver.EdgePlayers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gameserver.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, gameserver.EdgeMetadata)
	}
	if m.clearedplayers {
		edges = append(edges, gameserver.EdgePlayers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameServerMutation) EdgeCleared(name string) bool {
	switch name {
	case gameserver.EdgeMetadata:
		return m.clearedmetadata
	case gameserver.EdgePlayers:
		return m.clearedplayers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameServerMutation) ClearEdge(name string) error {
	switch name {
	case gameserver.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown GameServer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameServerMutation) ResetEdge(name string) error {
	switch name {
	case gameserver.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case gameserver.EdgePlayers:
		m.ResetPlayers()
		return nil
	}
	return fmt.Errorf("unknown GameServer edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *int
	addcreated_by *int
	created_with  *string
	updated_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_with  *string
	data          *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Metadata, error)
	predicates    []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id int) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetadataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MetadataMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MetadataMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *MetadataMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *MetadataMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MetadataMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[metadata.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MetadataMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[metadata.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MetadataMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, metadata.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *MetadataMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *MetadataMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *MetadataMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[metadata.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *MetadataMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[metadata.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *MetadataMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, metadata.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MetadataMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MetadataMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *MetadataMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *MetadataMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MetadataMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[metadata.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MetadataMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[metadata.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MetadataMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, metadata.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *MetadataMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *MetadataMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *MetadataMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[metadata.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *MetadataMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[metadata.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *MetadataMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, metadata.FieldUpdatedWith)
}

// SetData sets the "data" field.
func (m *MetadataMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *MetadataMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *MetadataMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, metadata.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, metadata.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, metadata.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, metadata.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, metadata.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, metadata.FieldUpdatedWith)
	}
	if m.data != nil {
		fields = append(fields, metadata.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldCreatedAt:
		return m.CreatedAt()
	case metadata.FieldCreatedBy:
		return m.CreatedBy()
	case metadata.FieldCreatedWith:
		return m.CreatedWith()
	case metadata.FieldUpdatedAt:
		return m.UpdatedAt()
	case metadata.FieldUpdatedBy:
		return m.UpdatedBy()
	case metadata.FieldUpdatedWith:
		return m.UpdatedWith()
	case metadata.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metadata.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case metadata.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case metadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metadata.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case metadata.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case metadata.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metadata.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case metadata.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case metadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metadata.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case metadata.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case metadata.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, metadata.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, metadata.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldCreatedBy:
		return m.AddedCreatedBy()
	case metadata.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case metadata.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metadata.FieldCreatedBy) {
		fields = append(fields, metadata.FieldCreatedBy)
	}
	if m.FieldCleared(metadata.FieldCreatedWith) {
		fields = append(fields, metadata.FieldCreatedWith)
	}
	if m.FieldCleared(metadata.FieldUpdatedBy) {
		fields = append(fields, metadata.FieldUpdatedBy)
	}
	if m.FieldCleared(metadata.FieldUpdatedWith) {
		fields = append(fields, metadata.FieldUpdatedWith)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	switch name {
	case metadata.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case metadata.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case metadata.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case metadata.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	}
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metadata.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case metadata.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case metadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metadata.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case metadata.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case metadata.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// OAuthConnectionMutation represents an operation that mutates the OAuthConnection nodes in the graph.
type OAuthConnectionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	created_by       *int
	addcreated_by    *int
	created_with     *string
	updated_at       *time.Time
	updated_by       *int
	addupdated_by    *int
	updated_with     *string
	provider         *string
	provider_user_id *string
	name             *string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*OAuthConnection, error)
	predicates       []predicate.OAuthConnection
}

var _ ent.Mutation = (*OAuthConnectionMutation)(nil)

// oauthconnectionOption allows management of the mutation configuration using functional options.
type oauthconnectionOption func(*OAuthConnectionMutation)

// newOAuthConnectionMutation creates new mutation for the OAuthConnection entity.
func newOAuthConnectionMutation(c config, op Op, opts ...oauthconnectionOption) *OAuthConnectionMutation {
	m := &OAuthConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthConnectionID sets the ID field of the mutation.
func withOAuthConnectionID(id int) oauthconnectionOption {
	return func(m *OAuthConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthConnection
		)
		m.oldValue = func(ctx context.Context) (*OAuthConnection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthConnection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthConnection sets the old OAuthConnection of the mutation.
func withOAuthConnection(node *OAuthConnection) oauthconnectionOption {
	return func(m *OAuthConnectionMutation) {
		m.oldValue = func(context.Context) (*OAuthConnection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthConnectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OAuthConnectionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OAuthConnectionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OAuthConnectionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OAuthConnectionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OAuthConnectionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[oauthconnection.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OAuthConnectionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OAuthConnectionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, oauthconnection.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *OAuthConnectionMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *OAuthConnectionMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *OAuthConnectionMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[oauthconnection.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *OAuthConnectionMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *OAuthConnectionMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, oauthconnection.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthConnectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthConnectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthConnectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OAuthConnectionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OAuthConnectionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OAuthConnectionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OAuthConnectionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OAuthConnectionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[oauthconnection.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OAuthConnectionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OAuthConnectionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, oauthconnection.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *OAuthConnectionMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *OAuthConnectionMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *OAuthConnectionMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[oauthconnection.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *OAuthConnectionMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *OAuthConnectionMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, oauthconnection.FieldUpdatedWith)
}

// SetProvider sets the "provider" field.
func (m *OAuthConnectionMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *OAuthConnectionMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *OAuthConnectionMutation) ResetProvider() {
	m.provider = nil
}

// SetProviderUserID sets the "provider_user_id" field.
func (m *OAuthConnectionMutation) SetProviderUserID(s string) {
	m.provider_user_id = &s
}

// ProviderUserID returns the value of the "provider_user_id" field in the mutation.
func (m *OAuthConnectionMutation) ProviderUserID() (r string, exists bool) {
	v := m.provider_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUserID returns the old "provider_user_id" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldProviderUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProviderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProviderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUserID: %w", err)
	}
	return oldValue.ProviderUserID, nil
}

// ResetProviderUserID resets all changes to the "provider_user_id" field.
func (m *OAuthConnectionMutation) ResetProviderUserID() {
	m.provider_user_id = nil
}

// SetName sets the "name" field.
func (m *OAuthConnectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OAuthConnectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OAuthConnection entity.
// If the OAuthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthConnectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OAuthConnectionMutation) ResetName() {
	m.name = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OAuthConnectionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OAuthConnectionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OAuthConnectionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OAuthConnectionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OAuthConnectionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OAuthConnectionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OAuthConnectionMutation builder.
func (m *OAuthConnectionMutation) Where(ps ...predicate.OAuthConnection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OAuthConnectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OAuthConnection).
func (m *OAuthConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthConnectionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, oauthconnection.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, oauthconnection.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, oauthconnection.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthconnection.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, oauthconnection.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, oauthconnection.FieldUpdatedWith)
	}
	if m.provider != nil {
		fields = append(fields, oauthconnection.FieldProvider)
	}
	if m.provider_user_id != nil {
		fields = append(fields, oauthconnection.FieldProviderUserID)
	}
	if m.name != nil {
		fields = append(fields, oauthconnection.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthconnection.FieldCreatedAt:
		return m.CreatedAt()
	case oauthconnection.FieldCreatedBy:
		return m.CreatedBy()
	case oauthconnection.FieldCreatedWith:
		return m.CreatedWith()
	case oauthconnection.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthconnection.FieldUpdatedBy:
		return m.UpdatedBy()
	case oauthconnection.FieldUpdatedWith:
		return m.UpdatedWith()
	case oauthconnection.FieldProvider:
		return m.Provider()
	case oauthconnection.FieldProviderUserID:
		return m.ProviderUserID()
	case oauthconnection.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthconnection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthconnection.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case oauthconnection.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case oauthconnection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthconnection.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case oauthconnection.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case oauthconnection.FieldProvider:
		return m.OldProvider(ctx)
	case oauthconnection.FieldProviderUserID:
		return m.OldProviderUserID(ctx)
	case oauthconnection.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthConnection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthconnection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthconnection.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case oauthconnection.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case oauthconnection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthconnection.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case oauthconnection.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case oauthconnection.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case oauthconnection.FieldProviderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUserID(v)
		return nil
	case oauthconnection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthConnection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthConnectionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, oauthconnection.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, oauthconnection.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthConnectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthconnection.FieldCreatedBy:
		return m.AddedCreatedBy()
	case oauthconnection.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthconnection.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case oauthconnection.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthConnection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthconnection.FieldCreatedBy) {
		fields = append(fields, oauthconnection.FieldCreatedBy)
	}
	if m.FieldCleared(oauthconnection.FieldCreatedWith) {
		fields = append(fields, oauthconnection.FieldCreatedWith)
	}
	if m.FieldCleared(oauthconnection.FieldUpdatedBy) {
		fields = append(fields, oauthconnection.FieldUpdatedBy)
	}
	if m.FieldCleared(oauthconnection.FieldUpdatedWith) {
		fields = append(fields, oauthconnection.FieldUpdatedWith)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthConnectionMutation) ClearField(name string) error {
	switch name {
	case oauthconnection.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case oauthconnection.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case oauthconnection.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case oauthconnection.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	}
	return fmt.Errorf("unknown OAuthConnection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthConnectionMutation) ResetField(name string) error {
	switch name {
	case oauthconnection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthconnection.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case oauthconnection.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case oauthconnection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthconnection.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case oauthconnection.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case oauthconnection.FieldProvider:
		m.ResetProvider()
		return nil
	case oauthconnection.FieldProviderUserID:
		m.ResetProviderUserID()
		return nil
	case oauthconnection.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown OAuthConnection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, oauthconnection.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthconnection.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthConnectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, oauthconnection.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthconnection.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthConnectionMutation) ClearEdge(name string) error {
	switch name {
	case oauthconnection.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthConnection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthConnectionMutation) ResetEdge(name string) error {
	switch name {
	case oauthconnection.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthConnection edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *int
	addcreated_by                *int
	created_with                 *string
	updated_at                   *time.Time
	updated_by                   *int
	addupdated_by                *int
	updated_with                 *string
	first_name                   *string
	middle_name                  *string
	last_name                    *string
	suffix                       *string
	date_of_birth                *time.Time
	birthplace                   *string
	deceased_at                  *time.Time
	archived_at                  *time.Time
	clearedFields                map[string]struct{}
	metadata                     *int
	clearedmetadata              bool
	vehicle_registrations        map[int]struct{}
	removedvehicle_registrations map[int]struct{}
	clearedvehicle_registrations bool
	race                         *int
	clearedrace                  bool
	ethnicity                    *int
	clearedethnicity             bool
	sex                          *int
	clearedsex                   bool
	user                         *int
	cleareduser                  bool
	death_certificate            *int
	cleareddeath_certificate     bool
	certified_deaths             map[int]struct{}
	removedcertified_deaths      map[int]struct{}
	clearedcertified_deaths      bool
	done                         bool
	oldValue                     func(context.Context) (*Person, error)
	predicates                   []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PersonMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PersonMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PersonMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[person.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PersonMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[person.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, person.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *PersonMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *PersonMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *PersonMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[person.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *PersonMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[person.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *PersonMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, person.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PersonMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PersonMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PersonMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[person.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PersonMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[person.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, person.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *PersonMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *PersonMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *PersonMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[person.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *PersonMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[person.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *PersonMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, person.FieldUpdatedWith)
}

// SetFirstName sets the "first_name" field.
func (m *PersonMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *PersonMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *PersonMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[person.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *PersonMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[person.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *PersonMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, person.FieldFirstName)
}

// SetMiddleName sets the "middle_name" field.
func (m *PersonMutation) SetMiddleName(s string) {
	m.middle_name = &s
}

// MiddleName returns the value of the "middle_name" field in the mutation.
func (m *PersonMutation) MiddleName() (r string, exists bool) {
	v := m.middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleName returns the old "middle_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleName: %w", err)
	}
	return oldValue.MiddleName, nil
}

// ClearMiddleName clears the value of the "middle_name" field.
func (m *PersonMutation) ClearMiddleName() {
	m.middle_name = nil
	m.clearedFields[person.FieldMiddleName] = struct{}{}
}

// MiddleNameCleared returns if the "middle_name" field was cleared in this mutation.
func (m *PersonMutation) MiddleNameCleared() bool {
	_, ok := m.clearedFields[person.FieldMiddleName]
	return ok
}

// ResetMiddleName resets all changes to the "middle_name" field.
func (m *PersonMutation) ResetMiddleName() {
	m.middle_name = nil
	delete(m.clearedFields, person.FieldMiddleName)
}

// SetLastName sets the "last_name" field.
func (m *PersonMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *PersonMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *PersonMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[person.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *PersonMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[person.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *PersonMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, person.FieldLastName)
}

// SetSuffix sets the "suffix" field.
func (m *PersonMutation) SetSuffix(s string) {
	m.suffix = &s
}

// Suffix returns the value of the "suffix" field in the mutation.
func (m *PersonMutation) Suffix() (r string, exists bool) {
	v := m.suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldSuffix returns the old "suffix" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuffix: %w", err)
	}
	return oldValue.Suffix, nil
}

// ClearSuffix clears the value of the "suffix" field.
func (m *PersonMutation) ClearSuffix() {
	m.suffix = nil
	m.clearedFields[person.FieldSuffix] = struct{}{}
}

// SuffixCleared returns if the "suffix" field was cleared in this mutation.
func (m *PersonMutation) SuffixCleared() bool {
	_, ok := m.clearedFields[person.FieldSuffix]
	return ok
}

// ResetSuffix resets all changes to the "suffix" field.
func (m *PersonMutation) ResetSuffix() {
	m.suffix = nil
	delete(m.clearedFields, person.FieldSuffix)
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *PersonMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *PersonMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *PersonMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[person.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *PersonMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[person.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *PersonMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, person.FieldDateOfBirth)
}

// SetBirthplace sets the "birthplace" field.
func (m *PersonMutation) SetBirthplace(s string) {
	m.birthplace = &s
}

// Birthplace returns the value of the "birthplace" field in the mutation.
func (m *PersonMutation) Birthplace() (r string, exists bool) {
	v := m.birthplace
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthplace returns the old "birthplace" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBirthplace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthplace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthplace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthplace: %w", err)
	}
	return oldValue.Birthplace, nil
}

// ClearBirthplace clears the value of the "birthplace" field.
func (m *PersonMutation) ClearBirthplace() {
	m.birthplace = nil
	m.clearedFields[person.FieldBirthplace] = struct{}{}
}

// BirthplaceCleared returns if the "birthplace" field was cleared in this mutation.
func (m *PersonMutation) BirthplaceCleared() bool {
	_, ok := m.clearedFields[person.FieldBirthplace]
	return ok
}

// ResetBirthplace resets all changes to the "birthplace" field.
func (m *PersonMutation) ResetBirthplace() {
	m.birthplace = nil
	delete(m.clearedFields, person.FieldBirthplace)
}

// SetDeceasedAt sets the "deceased_at" field.
func (m *PersonMutation) SetDeceasedAt(t time.Time) {
	m.deceased_at = &t
}

// DeceasedAt returns the value of the "deceased_at" field in the mutation.
func (m *PersonMutation) DeceasedAt() (r time.Time, exists bool) {
	v := m.deceased_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeceasedAt returns the old "deceased_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDeceasedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeceasedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeceasedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeceasedAt: %w", err)
	}
	return oldValue.DeceasedAt, nil
}

// ClearDeceasedAt clears the value of the "deceased_at" field.
func (m *PersonMutation) ClearDeceasedAt() {
	m.deceased_at = nil
	m.clearedFields[person.FieldDeceasedAt] = struct{}{}
}

// DeceasedAtCleared returns if the "deceased_at" field was cleared in this mutation.
func (m *PersonMutation) DeceasedAtCleared() bool {
	_, ok := m.clearedFields[person.FieldDeceasedAt]
	return ok
}

// ResetDeceasedAt resets all changes to the "deceased_at" field.
func (m *PersonMutation) ResetDeceasedAt() {
	m.deceased_at = nil
	delete(m.clearedFields, person.FieldDeceasedAt)
}

// SetArchivedAt sets the "archived_at" field.
func (m *PersonMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *PersonMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldArchivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *PersonMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[person.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *PersonMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[person.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *PersonMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, person.FieldArchivedAt)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *PersonMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *PersonMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *PersonMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *PersonMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *PersonMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddVehicleRegistrationIDs adds the "vehicle_registrations" edge to the VehicleRegistration entity by ids.
func (m *PersonMutation) AddVehicleRegistrationIDs(ids ...int) {
	if m.vehicle_registrations == nil {
		m.vehicle_registrations = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicle_registrations[ids[i]] = struct{}{}
	}
}

// ClearVehicleRegistrations clears the "vehicle_registrations" edge to the VehicleRegistration entity.
func (m *PersonMutation) ClearVehicleRegistrations() {
	m.clearedvehicle_registrations = true
}

// VehicleRegistrationsCleared reports if the "vehicle_registrations" edge to the VehicleRegistration entity was cleared.
func (m *PersonMutation) VehicleRegistrationsCleared() bool {
	return m.clearedvehicle_registrations
}

// RemoveVehicleRegistrationIDs removes the "vehicle_registrations" edge to the VehicleRegistration entity by IDs.
func (m *PersonMutation) RemoveVehicleRegistrationIDs(ids ...int) {
	if m.removedvehicle_registrations == nil {
		m.removedvehicle_registrations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicle_registrations, ids[i])
		m.removedvehicle_registrations[ids[i]] = struct{}{}
	}
}

// RemovedVehicleRegistrations returns the removed IDs of the "vehicle_registrations" edge to the VehicleRegistration entity.
func (m *PersonMutation) RemovedVehicleRegistrationsIDs() (ids []int) {
	for id := range m.removedvehicle_registrations {
		ids = append(ids, id)
	}
	return
}

// VehicleRegistrationsIDs returns the "vehicle_registrations" edge IDs in the mutation.
func (m *PersonMutation) VehicleRegistrationsIDs() (ids []int) {
	for id := range m.vehicle_registrations {
		ids = append(ids, id)
	}
	return
}

// ResetVehicleRegistrations resets all changes to the "vehicle_registrations" edge.
func (m *PersonMutation) ResetVehicleRegistrations() {
	m.vehicle_registrations = nil
	m.clearedvehicle_registrations = false
	m.removedvehicle_registrations = nil
}

// SetRaceID sets the "race" edge to the Race entity by id.
func (m *PersonMutation) SetRaceID(id int) {
	m.race = &id
}

// ClearRace clears the "race" edge to the Race entity.
func (m *PersonMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *PersonMutation) RaceCleared() bool {
	return m.clearedrace
}

// RaceID returns the "race" edge ID in the mutation.
func (m *PersonMutation) RaceID() (id int, exists bool) {
	if m.race != nil {
		return *m.race, true
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RaceID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) RaceIDs() (ids []int) {
	if id := m.race; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *PersonMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
}

// SetEthnicityID sets the "ethnicity" edge to the Ethnicity entity by id.
func (m *PersonMutation) SetEthnicityID(id int) {
	m.ethnicity = &id
}

// ClearEthnicity clears the "ethnicity" edge to the Ethnicity entity.
func (m *PersonMutation) ClearEthnicity() {
	m.clearedethnicity = true
}

// EthnicityCleared reports if the "ethnicity" edge to the Ethnicity entity was cleared.
func (m *PersonMutation) EthnicityCleared() bool {
	return m.clearedethnicity
}

// EthnicityID returns the "ethnicity" edge ID in the mutation.
func (m *PersonMutation) EthnicityID() (id int, exists bool) {
	if m.ethnicity != nil {
		return *m.ethnicity, true
	}
	return
}

// EthnicityIDs returns the "ethnicity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EthnicityID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) EthnicityIDs() (ids []int) {
	if id := m.ethnicity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEthnicity resets all changes to the "ethnicity" edge.
func (m *PersonMutation) ResetEthnicity() {
	m.ethnicity = nil
	m.clearedethnicity = false
}

// SetSexID sets the "sex" edge to the Sex entity by id.
func (m *PersonMutation) SetSexID(id int) {
	m.sex = &id
}

// ClearSex clears the "sex" edge to the Sex entity.
func (m *PersonMutation) ClearSex() {
	m.clearedsex = true
}

// SexCleared reports if the "sex" edge to the Sex entity was cleared.
func (m *PersonMutation) SexCleared() bool {
	return m.clearedsex
}

// SexID returns the "sex" edge ID in the mutation.
func (m *PersonMutation) SexID() (id int, exists bool) {
	if m.sex != nil {
		return *m.sex, true
	}
	return
}

// SexIDs returns the "sex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SexID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) SexIDs() (ids []int) {
	if id := m.sex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSex resets all changes to the "sex" edge.
func (m *PersonMutation) ResetSex() {
	m.sex = nil
	m.clearedsex = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PersonMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PersonMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PersonMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PersonMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PersonMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDeathCertificateID sets the "death_certificate" edge to the DeathCertificate entity by id.
func (m *PersonMutation) SetDeathCertificateID(id int) {
	m.death_certificate = &id
}

// ClearDeathCertificate clears the "death_certificate" edge to the DeathCertificate entity.
func (m *PersonMutation) ClearDeathCertificate() {
	m.cleareddeath_certificate = true
}

// DeathCertificateCleared reports if the "death_certificate" edge to the DeathCertificate entity was cleared.
func (m *PersonMutation) DeathCertificateCleared() bool {
	return m.cleareddeath_certificate
}

// DeathCertificateID returns the "death_certificate" edge ID in the mutation.
func (m *PersonMutation) DeathCertificateID() (id int, exists bool) {
	if m.death_certificate != nil {
		return *m.death_certificate, true
	}
	return
}

// DeathCertificateIDs returns the "death_certificate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeathCertificateID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) DeathCertificateIDs() (ids []int) {
	if id := m.death_certificate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeathCertificate resets all changes to the "death_certificate" edge.
func (m *PersonMutation) ResetDeathCertificate() {
	m.death_certificate = nil
	m.cleareddeath_certificate = false
}

// AddCertifiedDeathIDs adds the "certified_deaths" edge to the DeathCertificate entity by ids.
func (m *PersonMutation) AddCertifiedDeathIDs(ids ...int) {
	if m.certified_deaths == nil {
		m.certified_deaths = make(map[int]struct{})
	}
	for i := range ids {
		m.certified_deaths[ids[i]] = struct{}{}
	}
}

// ClearCertifiedDeaths clears the "certified_deaths" edge to the DeathCertificate entity.
func (m *PersonMutation) ClearCertifiedDeaths() {
	m.clearedcertified_deaths = true
}

// CertifiedDeathsCleared reports if the "certified_deaths" edge to the DeathCertificate entity was cleared.
func (m *PersonMutation) CertifiedDeathsCleared() bool {
	return m.clearedcertified_deaths
}

// RemoveCertifiedDeathIDs removes the "certified_deaths" edge to the DeathCertificate entity by IDs.
func (m *PersonMutation) RemoveCertifiedDeathIDs(ids ...int) {
	if m.removedcertified_deaths == nil {
		m.removedcertified_deaths = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.certified_deaths, ids[i])
		m.removedcertified_deaths[ids[i]] = struct{}{}
	}
}

// RemovedCertifiedDeaths returns the removed IDs of the "certified_deaths" edge to the DeathCertificate entity.
func (m *PersonMutation) RemovedCertifiedDeathsIDs() (ids []int) {
	for id := range m.removedcertified_deaths {
		ids = append(ids, id)
	}
	return
}

// CertifiedDeathsIDs returns the "certified_deaths" edge IDs in the mutation.
func (m *PersonMutation) CertifiedDeathsIDs() (ids []int) {
	for id := range m.certified_deaths {
		ids = append(ids, id)
	}
	return
}

// ResetCertifiedDeaths resets all changes to the "certified_deaths" edge.
func (m *PersonMutation) ResetCertifiedDeaths() {
	m.certified_deaths = nil
	m.clearedcertified_deaths = false
	m.removedcertified_deaths = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, person.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, person.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, person.FieldUpdatedWith)
	}
	if m.first_name != nil {
		fields = append(fields, person.FieldFirstName)
	}
	if m.middle_name != nil {
		fields = append(fields, person.FieldMiddleName)
	}
	if m.last_name != nil {
		fields = append(fields, person.FieldLastName)
	}
	if m.suffix != nil {
		fields = append(fields, person.FieldSuffix)
	}
	if m.date_of_birth != nil {
		fields = append(fields, person.FieldDateOfBirth)
	}
	if m.birthplace != nil {
		fields = append(fields, person.FieldBirthplace)
	}
	if m.deceased_at != nil {
		fields = append(fields, person.FieldDeceasedAt)
	}
	if m.archived_at != nil {
		fields = append(fields, person.FieldArchivedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldCreatedBy:
		return m.CreatedBy()
	case person.FieldCreatedWith:
		return m.CreatedWith()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldUpdatedBy:
		return m.UpdatedBy()
	case person.FieldUpdatedWith:
		return m.UpdatedWith()
	case person.FieldFirstName:
		return m.FirstName()
	case person.FieldMiddleName:
		return m.MiddleName()
	case person.FieldLastName:
		return m.LastName()
	case person.FieldSuffix:
		return m.Suffix()
	case person.FieldDateOfBirth:
		return m.DateOfBirth()
	case person.FieldBirthplace:
		return m.Birthplace()
	case person.FieldDeceasedAt:
		return m.DeceasedAt()
	case person.FieldArchivedAt:
		return m.ArchivedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case person.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case person.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case person.FieldFirstName:
		return m.OldFirstName(ctx)
	case person.FieldMiddleName:
		return m.OldMiddleName(ctx)
	case person.FieldLastName:
		return m.OldLastName(ctx)
	case person.FieldSuffix:
		return m.OldSuffix(ctx)
	case person.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case person.FieldBirthplace:
		return m.OldBirthplace(ctx)
	case person.FieldDeceasedAt:
		return m.OldDeceasedAt(ctx)
	case person.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case person.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case person.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case person.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case person.FieldMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleName(v)
		return nil
	case person.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case person.FieldSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuffix(v)
		return nil
	case person.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case person.FieldBirthplace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthplace(v)
		return nil
	case person.FieldDeceasedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeceasedAt(v)
		return nil
	case person.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, person.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedBy:
		return m.AddedCreatedBy()
	case person.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case person.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldCreatedBy) {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.FieldCleared(person.FieldCreatedWith) {
		fields = append(fields, person.FieldCreatedWith)
	}
	if m.FieldCleared(person.FieldUpdatedBy) {
		fields = append(fields, person.FieldUpdatedBy)
	}
	if m.FieldCleared(person.FieldUpdatedWith) {
		fields = append(fields, person.FieldUpdatedWith)
	}
	if m.FieldCleared(person.FieldFirstName) {
		fields = append(fields, person.FieldFirstName)
	}
	if m.FieldCleared(person.FieldMiddleName) {
		fields = append(fields, person.FieldMiddleName)
	}
	if m.FieldCleared(person.FieldLastName) {
		fields = append(fields, person.FieldLastName)
	}
	if m.FieldCleared(person.FieldSuffix) {
		fields = append(fields, person.FieldSuffix)
	}
	if m.FieldCleared(person.FieldDateOfBirth) {
		fields = append(fields, person.FieldDateOfBirth)
	}
	if m.FieldCleared(person.FieldBirthplace) {
		fields = append(fields, person.FieldBirthplace)
	}
	if m.FieldCleared(person.FieldDeceasedAt) {
		fields = append(fields, person.FieldDeceasedAt)
	}
	if m.FieldCleared(person.FieldArchivedAt) {
		fields = append(fields, person.FieldArchivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case person.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case person.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case person.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case person.FieldFirstName:
		m.ClearFirstName()
		return nil
	case person.FieldMiddleName:
		m.ClearMiddleName()
		return nil
	case person.FieldLastName:
		m.ClearLastName()
		return nil
	case person.FieldSuffix:
		m.ClearSuffix()
		return nil
	case person.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case person.FieldBirthplace:
		m.ClearBirthplace()
		return nil
	case person.FieldDeceasedAt:
		m.ClearDeceasedAt()
		return nil
	case person.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case person.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case person.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case person.FieldFirstName:
		m.ResetFirstName()
		return nil
	case person.FieldMiddleName:
		m.ResetMiddleName()
		return nil
	case person.FieldLastName:
		m.ResetLastName()
		return nil
	case person.FieldSuffix:
		m.ResetSuffix()
		return nil
	case person.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case person.FieldBirthplace:
		m.ResetBirthplace()
		return nil
	case person.FieldDeceasedAt:
		m.ResetDeceasedAt()
		return nil
	case person.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.metadata != nil {
		edges = append(edges, person.EdgeMetadata)
	}
	if m.vehicle_registrations != nil {
		edges = append(edges, person.EdgeVehicleRegistrations)
	}
	if m.race != nil {
		edges = append(edges, person.EdgeRace)
	}
	if m.ethnicity != nil {
		edges = append(edges, person.EdgeEthnicity)
	}
	if m.sex != nil {
		edges = append(edges, person.EdgeSex)
	}
	if m.user != nil {
		edges = append(edges, person.EdgeUser)
	}
	if m.death_certificate != nil {
		edges = append(edges, person.EdgeDeathCertificate)
	}
	if m.certified_deaths != nil {
		edges = append(edges, person.EdgeCertifiedDeaths)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeVehicleRegistrations:
		ids := make([]ent.Value, 0, len(m.vehicle_registrations))
		for id := range m.vehicle_registrations {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeRace:
		if id := m.race; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeEthnicity:
		if id := m.ethnicity; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeSex:
		if id := m.sex; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeDeathCertificate:
		if id := m.death_certificate; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeCertifiedDeaths:
		ids := make([]ent.Value, 0, len(m.certified_deaths))
		for id := range m.certified_deaths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedvehicle_registrations != nil {
		edges = append(edges, person.EdgeVehicleRegistrations)
	}
	if m.removedcertified_deaths != nil {
		edges = append(edges, person.EdgeCertifiedDeaths)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeVehicleRegistrations:
		ids := make([]ent.Value, 0, len(m.removedvehicle_registrations))
		for id := range m.removedvehicle_registrations {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeCertifiedDeaths:
		ids := make([]ent.Value, 0, len(m.removedcertified_deaths))
		for id := range m.removedcertified_deaths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedmetadata {
		edges = append(edges, person.EdgeMetadata)
	}
	if m.clearedvehicle_registrations {
		edges = append(edges, person.EdgeVehicleRegistrations)
	}
	if m.clearedrace {
		edges = append(edges, person.EdgeRace)
	}
	if m.clearedethnicity {
		edges = append(edges, person.EdgeEthnicity)
	}
	if m.clearedsex {
		edges = append(edges, person.EdgeSex)
	}
	if m.cleareduser {
		edges = append(edges, person.EdgeUser)
	}
	if m.cleareddeath_certificate {
		edges = append(edges, person.EdgeDeathCertificate)
	}
	if m.clearedcertified_deaths {
		edges = append(edges, person.EdgeCertifiedDeaths)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeMetadata:
		return m.clearedmetadata
	case person.EdgeVehicleRegistrations:
		return m.clearedvehicle_registrations
	case person.EdgeRace:
		return m.clearedrace
	case person.EdgeEthnicity:
		return m.clearedethnicity
	case person.EdgeSex:
		return m.clearedsex
	case person.EdgeUser:
		return m.cleareduser
	case person.EdgeDeathCertificate:
		return m.cleareddeath_certificate
	case person.EdgeCertifiedDeaths:
		return m.clearedcertified_deaths
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	case person.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case person.EdgeRace:
		m.ClearRace()
		return nil
	case person.EdgeEthnicity:
		m.ClearEthnicity()
		return nil
	case person.EdgeSex:
		m.ClearSex()
		return nil
	case person.EdgeUser:
		m.ClearUser()
		return nil
	case person.EdgeDeathCertificate:
		m.ClearDeathCertificate()
		return nil
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case person.EdgeVehicleRegistrations:
		m.ResetVehicleRegistrations()
		return nil
	case person.EdgeRace:
		m.ResetRace()
		return nil
	case person.EdgeEthnicity:
		m.ResetEthnicity()
		return nil
	case person.EdgeSex:
		m.ResetSex()
		return nil
	case person.EdgeUser:
		m.ResetUser()
		return nil
	case person.EdgeDeathCertificate:
		m.ResetDeathCertificate()
		return nil
	case person.EdgeCertifiedDeaths:
		m.ResetCertifiedDeaths()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	created_by         *int
	addcreated_by      *int
	created_with       *string
	updated_at         *time.Time
	updated_by         *int
	addupdated_by      *int
	updated_with       *string
	name               *string
	clearedFields      map[string]struct{}
	metadata           *int
	clearedmetadata    bool
	servers            map[int]struct{}
	removedservers     map[int]struct{}
	clearedservers     bool
	identifiers        map[int]struct{}
	removedidentifiers map[int]struct{}
	clearedidentifiers bool
	done               bool
	oldValue           func(context.Context) (*Player, error)
	predicates         []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id int) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PlayerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlayerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PlayerMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PlayerMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PlayerMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PlayerMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PlayerMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[player.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PlayerMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[player.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PlayerMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, player.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *PlayerMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *PlayerMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *PlayerMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[player.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *PlayerMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[player.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *PlayerMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, player.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlayerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlayerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PlayerMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PlayerMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PlayerMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PlayerMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PlayerMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[player.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PlayerMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[player.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PlayerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, player.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *PlayerMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *PlayerMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *PlayerMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[player.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *PlayerMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[player.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *PlayerMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, player.FieldUpdatedWith)
}

// SetName sets the "name" field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *PlayerMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *PlayerMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *PlayerMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *PlayerMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *PlayerMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddServerIDs adds the "servers" edge to the GameServer entity by ids.
func (m *PlayerMutation) AddServerIDs(ids ...int) {
	if m.servers == nil {
		m.servers = make(map[int]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the "servers" edge to the GameServer entity.
func (m *PlayerMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared reports if the "servers" edge to the GameServer entity was cleared.
func (m *PlayerMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the "servers" edge to the GameServer entity by IDs.
func (m *PlayerMutation) RemoveServerIDs(ids ...int) {
	if m.removedservers == nil {
		m.removedservers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.servers, ids[i])
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed IDs of the "servers" edge to the GameServer entity.
func (m *PlayerMutation) RemovedServersIDs() (ids []int) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the "servers" edge IDs in the mutation.
func (m *PlayerMutation) ServersIDs() (ids []int) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers resets all changes to the "servers" edge.
func (m *PlayerMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// AddIdentifierIDs adds the "identifiers" edge to the PlayerIdentifier entity by ids.
func (m *PlayerMutation) AddIdentifierIDs(ids ...int) {
	if m.identifiers == nil {
		m.identifiers = make(map[int]struct{})
	}
	for i := range ids {
		m.identifiers[ids[i]] = struct{}{}
	}
}

// ClearIdentifiers clears the "identifiers" edge to the PlayerIdentifier entity.
func (m *PlayerMutation) ClearIdentifiers() {
	m.clearedidentifiers = true
}

// IdentifiersCleared reports if the "identifiers" edge to the PlayerIdentifier entity was cleared.
func (m *PlayerMutation) IdentifiersCleared() bool {
	return m.clearedidentifiers
}

// RemoveIdentifierIDs removes the "identifiers" edge to the PlayerIdentifier entity by IDs.
func (m *PlayerMutation) RemoveIdentifierIDs(ids ...int) {
	if m.removedidentifiers == nil {
		m.removedidentifiers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identifiers, ids[i])
		m.removedidentifiers[ids[i]] = struct{}{}
	}
}

// RemovedIdentifiers returns the removed IDs of the "identifiers" edge to the PlayerIdentifier entity.
func (m *PlayerMutation) RemovedIdentifiersIDs() (ids []int) {
	for id := range m.removedidentifiers {
		ids = append(ids, id)
	}
	return
}

// IdentifiersIDs returns the "identifiers" edge IDs in the mutation.
func (m *PlayerMutation) IdentifiersIDs() (ids []int) {
	for id := range m.identifiers {
		ids = append(ids, id)
	}
	return
}

// ResetIdentifiers resets all changes to the "identifiers" edge.
func (m *PlayerMutation) ResetIdentifiers() {
	m.identifiers = nil
	m.clearedidentifiers = false
	m.removedidentifiers = nil
}

// Where appends a list predicates to the PlayerMutation builder.
func (m *PlayerMutation) Where(ps ...predicate.Player) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, player.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, player.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, player.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, player.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, player.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, player.FieldUpdatedWith)
	}
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldCreatedAt:
		return m.CreatedAt()
	case player.FieldCreatedBy:
		return m.CreatedBy()
	case player.FieldCreatedWith:
		return m.CreatedWith()
	case player.FieldUpdatedAt:
		return m.UpdatedAt()
	case player.FieldUpdatedBy:
		return m.UpdatedBy()
	case player.FieldUpdatedWith:
		return m.UpdatedWith()
	case player.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case player.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case player.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case player.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case player.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case player.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case player.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case player.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case player.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case player.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case player.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case player.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, player.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, player.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case player.FieldCreatedBy:
		return m.AddedCreatedBy()
	case player.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case player.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case player.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(player.FieldCreatedBy) {
		fields = append(fields, player.FieldCreatedBy)
	}
	if m.FieldCleared(player.FieldCreatedWith) {
		fields = append(fields, player.FieldCreatedWith)
	}
	if m.FieldCleared(player.FieldUpdatedBy) {
		fields = append(fields, player.FieldUpdatedBy)
	}
	if m.FieldCleared(player.FieldUpdatedWith) {
		fields = append(fields, player.FieldUpdatedWith)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	switch name {
	case player.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case player.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case player.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case player.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	}
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case player.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case player.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case player.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case player.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case player.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case player.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.metadata != nil {
		edges = append(edges, player.EdgeMetadata)
	}
	if m.servers != nil {
		edges = append(edges, player.EdgeServers)
	}
	if m.identifiers != nil {
		edges = append(edges, player.EdgeIdentifiers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.identifiers))
		for id := range m.identifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedservers != nil {
		edges = append(edges, player.EdgeServers)
	}
	if m.removedidentifiers != nil {
		edges = append(edges, player.EdgeIdentifiers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.removedidentifiers))
		for id := range m.removedidentifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmetadata {
		edges = append(edges, player.EdgeMetadata)
	}
	if m.clearedservers {
		edges = append(edges, player.EdgeServers)
	}
	if m.clearedidentifiers {
		edges = append(edges, player.EdgeIdentifiers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeMetadata:
		return m.clearedmetadata
	case player.EdgeServers:
		return m.clearedservers
	case player.EdgeIdentifiers:
		return m.clearedidentifiers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	case player.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case player.EdgeServers:
		m.ResetServers()
		return nil
	case player.EdgeIdentifiers:
		m.ResetIdentifiers()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// PlayerIdentifierMutation represents an operation that mutates the PlayerIdentifier nodes in the graph.
type PlayerIdentifierMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *int
	addcreated_by *int
	created_with  *string
	updated_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_with  *string
	value         *string
	clearedFields map[string]struct{}
	player        *int
	clearedplayer bool
	done          bool
	oldValue      func(context.Context) (*PlayerIdentifier, error)
	predicates    []predicate.PlayerIdentifier
}

var _ ent.Mutation = (*PlayerIdentifierMutation)(nil)

// playeridentifierOption allows management of the mutation configuration using functional options.
type playeridentifierOption func(*PlayerIdentifierMutation)

// newPlayerIdentifierMutation creates new mutation for the PlayerIdentifier entity.
func newPlayerIdentifierMutation(c config, op Op, opts ...playeridentifierOption) *PlayerIdentifierMutation {
	m := &PlayerIdentifierMutation{
		config:        c,
		op:            op,
		typ:           TypePlayerIdentifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerIdentifierID sets the ID field of the mutation.
func withPlayerIdentifierID(id int) playeridentifierOption {
	return func(m *PlayerIdentifierMutation) {
		var (
			err   error
			once  sync.Once
			value *PlayerIdentifier
		)
		m.oldValue = func(ctx context.Context) (*PlayerIdentifier, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlayerIdentifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayerIdentifier sets the old PlayerIdentifier of the mutation.
func withPlayerIdentifier(node *PlayerIdentifier) playeridentifierOption {
	return func(m *PlayerIdentifierMutation) {
		m.oldValue = func(context.Context) (*PlayerIdentifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerIdentifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerIdentifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerIdentifierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PlayerIdentifierMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlayerIdentifierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlayerIdentifier entity.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerIdentifierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlayerIdentifierMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PlayerIdentifierMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PlayerIdentifierMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PlayerIdentifier entity.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerIdentifierMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PlayerIdentifierMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PlayerIdentifierMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PlayerIdentifierMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[playeridentifier.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PlayerIdentifierMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[playeridentifier.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PlayerIdentifierMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, playeridentifier.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *PlayerIdentifierMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *PlayerIdentifierMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the PlayerIdentifier entity.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerIdentifierMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *PlayerIdentifierMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[playeridentifier.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *PlayerIdentifierMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[playeridentifier.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *PlayerIdentifierMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, playeridentifier.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlayerIdentifierMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlayerIdentifierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlayerIdentifier entity.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerIdentifierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlayerIdentifierMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PlayerIdentifierMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PlayerIdentifierMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PlayerIdentifier entity.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerIdentifierMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PlayerIdentifierMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PlayerIdentifierMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PlayerIdentifierMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[playeridentifier.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PlayerIdentifierMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[playeridentifier.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PlayerIdentifierMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, playeridentifier.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *PlayerIdentifierMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *PlayerIdentifierMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the PlayerIdentifier entity.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerIdentifierMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *PlayerIdentifierMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[playeridentifier.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *PlayerIdentifierMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[playeridentifier.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *PlayerIdentifierMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, playeridentifier.FieldUpdatedWith)
}

// SetValue sets the "value" field.
func (m *PlayerIdentifierMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PlayerIdentifierMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the PlayerIdentifier entity.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerIdentifierMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PlayerIdentifierMutation) ResetValue() {
	m.value = nil
}

// SetPlayerID sets the "player" edge to the Player entity by id.
func (m *PlayerIdentifierMutation) SetPlayerID(id int) {
	m.player = &id
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *PlayerIdentifierMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *PlayerIdentifierMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// PlayerID returns the "player" edge ID in the mutation.
func (m *PlayerIdentifierMutation) PlayerID() (id int, exists bool) {
	if m.player != nil {
		return *m.player, true
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *PlayerIdentifierMutation) PlayerIDs() (ids []int) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *PlayerIdentifierMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// Where appends a list predicates to the PlayerIdentifierMutation builder.
func (m *PlayerIdentifierMutation) Where(ps ...predicate.PlayerIdentifier) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlayerIdentifierMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PlayerIdentifier).
func (m *PlayerIdentifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerIdentifierMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, playeridentifier.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, playeridentifier.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, playeridentifier.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, playeridentifier.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, playeridentifier.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, playeridentifier.FieldUpdatedWith)
	}
	if m.value != nil {
		fields = append(fields, playeridentifier.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerIdentifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playeridentifier.FieldCreatedAt:
		return m.CreatedAt()
	case playeridentifier.FieldCreatedBy:
		return m.CreatedBy()
	case playeridentifier.FieldCreatedWith:
		return m.CreatedWith()
	case playeridentifier.FieldUpdatedAt:
		return m.UpdatedAt()
	case playeridentifier.FieldUpdatedBy:
		return m.UpdatedBy()
	case playeridentifier.FieldUpdatedWith:
		return m.UpdatedWith()
	case playeridentifier.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerIdentifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playeridentifier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case playeridentifier.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case playeridentifier.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case playeridentifier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case playeridentifier.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case playeridentifier.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case playeridentifier.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown PlayerIdentifier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerIdentifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playeridentifier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case playeridentifier.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case playeridentifier.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case playeridentifier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case playeridentifier.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case playeridentifier.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case playeridentifier.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerIdentifierMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, playeridentifier.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, playeridentifier.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerIdentifierMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case playeridentifier.FieldCreatedBy:
		return m.AddedCreatedBy()
	case playeridentifier.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerIdentifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	case playeridentifier.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case playeridentifier.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerIdentifierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(playeridentifier.FieldCreatedBy) {
		fields = append(fields, playeridentifier.FieldCreatedBy)
	}
	if m.FieldCleared(playeridentifier.FieldCreatedWith) {
		fields = append(fields, playeridentifier.FieldCreatedWith)
	}
	if m.FieldCleared(playeridentifier.FieldUpdatedBy) {
		fields = append(fields, playeridentifier.FieldUpdatedBy)
	}
	if m.FieldCleared(playeridentifier.FieldUpdatedWith) {
		fields = append(fields, playeridentifier.FieldUpdatedWith)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerIdentifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerIdentifierMutation) ClearField(name string) error {
	switch name {
	case playeridentifier.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case playeridentifier.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case playeridentifier.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case playeridentifier.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerIdentifierMutation) ResetField(name string) error {
	switch name {
	case playeridentifier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case playeridentifier.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case playeridentifier.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case playeridentifier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case playeridentifier.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case playeridentifier.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case playeridentifier.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerIdentifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.player != nil {
		edges = append(edges, playeridentifier.EdgePlayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerIdentifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playeridentifier.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerIdentifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerIdentifierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerIdentifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplayer {
		edges = append(edges, playeridentifier.EdgePlayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerIdentifierMutation) EdgeCleared(name string) bool {
	switch name {
	case playeridentifier.EdgePlayer:
		return m.clearedplayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerIdentifierMutation) ClearEdge(name string) error {
	switch name {
	case playeridentifier.EdgePlayer:
		m.ClearPlayer()
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerIdentifierMutation) ResetEdge(name string) error {
	switch name {
	case playeridentifier.EdgePlayer:
		m.ResetPlayer()
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier edge %s", name)
}

// RaceMutation represents an operation that mutates the Race nodes in the graph.
type RaceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *int
	addcreated_by *int
	created_with  *string
	updated_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_with  *string
	short         *string
	title         *string
	description   *string
	clearedFields map[string]struct{}
	people        map[int]struct{}
	removedpeople map[int]struct{}
	clearedpeople bool
	done          bool
	oldValue      func(context.Context) (*Race, error)
	predicates    []predicate.Race
}

var _ ent.Mutation = (*RaceMutation)(nil)

// raceOption allows management of the mutation configuration using functional options.
type raceOption func(*RaceMutation)

// newRaceMutation creates new mutation for the Race entity.
func newRaceMutation(c config, op Op, opts ...raceOption) *RaceMutation {
	m := &RaceMutation{
		config:        c,
		op:            op,
		typ:           TypeRace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRaceID sets the ID field of the mutation.
func withRaceID(id int) raceOption {
	return func(m *RaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Race
		)
		m.oldValue = func(ctx context.Context) (*Race, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Race.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRace sets the old Race of the mutation.
func withRace(node *Race) raceOption {
	return func(m *RaceMutation) {
		m.oldValue = func(context.Context) (*Race, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *RaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RaceMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RaceMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *RaceMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *RaceMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RaceMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[race.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RaceMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[race.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RaceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, race.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *RaceMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *RaceMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *RaceMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[race.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *RaceMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[race.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *RaceMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, race.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RaceMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RaceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RaceMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RaceMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RaceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[race.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RaceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[race.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RaceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, race.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *RaceMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *RaceMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *RaceMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[race.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *RaceMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[race.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *RaceMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, race.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *RaceMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *RaceMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *RaceMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *RaceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RaceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RaceMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *RaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[race.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[race.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, race.FieldDescription)
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *RaceMutation) AddPersonIDs(ids ...int) {
	if m.people == nil {
		m.people = make(map[int]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *RaceMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *RaceMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *RaceMutation) RemovePersonIDs(ids ...int) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *RaceMutation) RemovedPeopleIDs() (ids []int) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *RaceMutation) PeopleIDs() (ids []int) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *RaceMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// Where appends a list predicates to the RaceMutation builder.
func (m *RaceMutation) Where(ps ...predicate.Race) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Race).
func (m *RaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RaceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, race.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, race.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, race.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, race.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, race.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, race.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, race.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, race.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, race.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case race.FieldCreatedAt:
		return m.CreatedAt()
	case race.FieldCreatedBy:
		return m.CreatedBy()
	case race.FieldCreatedWith:
		return m.CreatedWith()
	case race.FieldUpdatedAt:
		return m.UpdatedAt()
	case race.FieldUpdatedBy:
		return m.UpdatedBy()
	case race.FieldUpdatedWith:
		return m.UpdatedWith()
	case race.FieldShort:
		return m.Short()
	case race.FieldTitle:
		return m.Title()
	case race.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case race.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case race.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case race.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case race.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case race.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case race.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case race.FieldShort:
		return m.OldShort(ctx)
	case race.FieldTitle:
		return m.OldTitle(ctx)
	case race.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Race field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case race.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case race.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case race.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case race.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case race.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case race.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case race.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case race.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case race.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Race field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RaceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, race.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, race.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case race.FieldCreatedBy:
		return m.AddedCreatedBy()
	case race.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case race.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case race.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Race numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(race.FieldCreatedBy) {
		fields = append(fields, race.FieldCreatedBy)
	}
	if m.FieldCleared(race.FieldCreatedWith) {
		fields = append(fields, race.FieldCreatedWith)
	}
	if m.FieldCleared(race.FieldUpdatedBy) {
		fields = append(fields, race.FieldUpdatedBy)
	}
	if m.FieldCleared(race.FieldUpdatedWith) {
		fields = append(fields, race.FieldUpdatedWith)
	}
	if m.FieldCleared(race.FieldDescription) {
		fields = append(fields, race.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RaceMutation) ClearField(name string) error {
	switch name {
	case race.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case race.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case race.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case race.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case race.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Race nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RaceMutation) ResetField(name string) error {
	switch name {
	case race.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case race.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case race.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case race.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case race.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case race.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case race.FieldShort:
		m.ResetShort()
		return nil
	case race.FieldTitle:
		m.ResetTitle()
		return nil
	case race.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Race field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.people != nil {
		edges = append(edges, race.EdgePeople)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case race.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpeople != nil {
		edges = append(edges, race.EdgePeople)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case race.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpeople {
		edges = append(edges, race.EdgePeople)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RaceMutation) EdgeCleared(name string) bool {
	switch name {
	case race.EdgePeople:
		return m.clearedpeople
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Race unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RaceMutation) ResetEdge(name string) error {
	switch name {
	case race.EdgePeople:
		m.ResetPeople()
		return nil
	}
	return fmt.Errorf("unknown Race edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *int
	addcreated_by *int
	created_with  *string
	updated_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_with  *string
	started_at    *time.Time
	started_from  *string
	ip_address    *string
	ended_at      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SessionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SessionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SessionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SessionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SessionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[session.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SessionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[session.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SessionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, session.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *SessionMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *SessionMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *SessionMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[session.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *SessionMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[session.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *SessionMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, session.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SessionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SessionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SessionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SessionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SessionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[session.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SessionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[session.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SessionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, session.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *SessionMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *SessionMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *SessionMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[session.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *SessionMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[session.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *SessionMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, session.FieldUpdatedWith)
}

// SetStartedAt sets the "started_at" field.
func (m *SessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SessionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetStartedFrom sets the "started_from" field.
func (m *SessionMutation) SetStartedFrom(s string) {
	m.started_from = &s
}

// StartedFrom returns the value of the "started_from" field in the mutation.
func (m *SessionMutation) StartedFrom() (r string, exists bool) {
	v := m.started_from
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedFrom returns the old "started_from" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldStartedFrom(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedFrom: %w", err)
	}
	return oldValue.StartedFrom, nil
}

// ClearStartedFrom clears the value of the "started_from" field.
func (m *SessionMutation) ClearStartedFrom() {
	m.started_from = nil
	m.clearedFields[session.FieldStartedFrom] = struct{}{}
}

// StartedFromCleared returns if the "started_from" field was cleared in this mutation.
func (m *SessionMutation) StartedFromCleared() bool {
	_, ok := m.clearedFields[session.FieldStartedFrom]
	return ok
}

// ResetStartedFrom resets all changes to the "started_from" field.
func (m *SessionMutation) ResetStartedFrom() {
	m.started_from = nil
	delete(m.clearedFields, session.FieldStartedFrom)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetEndedAt sets the "ended_at" field.
func (m *SessionMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *SessionMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *SessionMutation) ResetEndedAt() {
	m.ended_at = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, session.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, session.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, session.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, session.FieldUpdatedWith)
	}
	if m.started_at != nil {
		fields = append(fields, session.FieldStartedAt)
	}
	if m.started_from != nil {
		fields = append(fields, session.FieldStartedFrom)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.ended_at != nil {
		fields = append(fields, session.FieldEndedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldCreatedBy:
		return m.CreatedBy()
	case session.FieldCreatedWith:
		return m.CreatedWith()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldUpdatedBy:
		return m.UpdatedBy()
	case session.FieldUpdatedWith:
		return m.UpdatedWith()
	case session.FieldStartedAt:
		return m.StartedAt()
	case session.FieldStartedFrom:
		return m.StartedFrom()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldEndedAt:
		return m.EndedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case session.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case session.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case session.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case session.FieldStartedFrom:
		return m.OldStartedFrom(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldEndedAt:
		return m.OldEndedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case session.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case session.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case session.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case session.FieldStartedFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedFrom(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, session.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, session.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedBy:
		return m.AddedCreatedBy()
	case session.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case session.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldCreatedBy) {
		fields = append(fields, session.FieldCreatedBy)
	}
	if m.FieldCleared(session.FieldCreatedWith) {
		fields = append(fields, session.FieldCreatedWith)
	}
	if m.FieldCleared(session.FieldUpdatedBy) {
		fields = append(fields, session.FieldUpdatedBy)
	}
	if m.FieldCleared(session.FieldUpdatedWith) {
		fields = append(fields, session.FieldUpdatedWith)
	}
	if m.FieldCleared(session.FieldStartedFrom) {
		fields = append(fields, session.FieldStartedFrom)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case session.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case session.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case session.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case session.FieldStartedFrom:
		m.ClearStartedFrom()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case session.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case session.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case session.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case session.FieldStartedFrom:
		m.ResetStartedFrom()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *int
	addcreated_by *int
	created_with  *string
	updated_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_with  *string
	key           *string
	data          *structs.SettingData
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SettingMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SettingMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SettingMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SettingMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SettingMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[setting.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SettingMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[setting.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SettingMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, setting.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *SettingMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *SettingMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *SettingMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[setting.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *SettingMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[setting.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *SettingMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, setting.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SettingMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SettingMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SettingMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SettingMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SettingMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[setting.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SettingMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[setting.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, setting.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *SettingMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *SettingMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *SettingMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[setting.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *SettingMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[setting.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *SettingMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, setting.FieldUpdatedWith)
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetData sets the "data" field.
func (m *SettingMutation) SetData(sd structs.SettingData) {
	m.data = &sd
}

// Data returns the value of the "data" field in the mutation.
func (m *SettingMutation) Data() (r structs.SettingData, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldData(ctx context.Context) (v structs.SettingData, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *SettingMutation) ClearData() {
	m.data = nil
	m.clearedFields[setting.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *SettingMutation) DataCleared() bool {
	_, ok := m.clearedFields[setting.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *SettingMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, setting.FieldData)
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, setting.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, setting.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, setting.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, setting.FieldUpdatedWith)
	}
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.data != nil {
		fields = append(fields, setting.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldCreatedBy:
		return m.CreatedBy()
	case setting.FieldCreatedWith:
		return m.CreatedWith()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldUpdatedBy:
		return m.UpdatedBy()
	case setting.FieldUpdatedWith:
		return m.UpdatedWith()
	case setting.FieldKey:
		return m.Key()
	case setting.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case setting.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case setting.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case setting.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case setting.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldData:
		v, ok := value.(structs.SettingData)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, setting.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, setting.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedBy:
		return m.AddedCreatedBy()
	case setting.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case setting.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldCreatedBy) {
		fields = append(fields, setting.FieldCreatedBy)
	}
	if m.FieldCleared(setting.FieldCreatedWith) {
		fields = append(fields, setting.FieldCreatedWith)
	}
	if m.FieldCleared(setting.FieldUpdatedBy) {
		fields = append(fields, setting.FieldUpdatedBy)
	}
	if m.FieldCleared(setting.FieldUpdatedWith) {
		fields = append(fields, setting.FieldUpdatedWith)
	}
	if m.FieldCleared(setting.FieldData) {
		fields = append(fields, setting.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case setting.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case setting.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case setting.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case setting.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case setting.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case setting.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SexMutation represents an operation that mutates the Sex nodes in the graph.
type SexMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *int
	addcreated_by   *int
	created_with    *string
	updated_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_with    *string
	short           *string
	title           *string
	description     *string
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	people          map[int]struct{}
	removedpeople   map[int]struct{}
	clearedpeople   bool
	done            bool
	oldValue        func(context.Context) (*Sex, error)
	predicates      []predicate.Sex
}

var _ ent.Mutation = (*SexMutation)(nil)

// sexOption allows management of the mutation configuration using functional options.
type sexOption func(*SexMutation)

// newSexMutation creates new mutation for the Sex entity.
func newSexMutation(c config, op Op, opts ...sexOption) *SexMutation {
	m := &SexMutation{
		config:        c,
		op:            op,
		typ:           TypeSex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSexID sets the ID field of the mutation.
func withSexID(id int) sexOption {
	return func(m *SexMutation) {
		var (
			err   error
			once  sync.Once
			value *Sex
		)
		m.oldValue = func(ctx context.Context) (*Sex, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSex sets the old Sex of the mutation.
func withSex(node *Sex) sexOption {
	return func(m *SexMutation) {
		m.oldValue = func(context.Context) (*Sex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SexMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SexMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SexMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SexMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SexMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SexMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *SexMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SexMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SexMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[sex.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SexMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[sex.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SexMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, sex.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *SexMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *SexMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *SexMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[sex.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *SexMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[sex.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *SexMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, sex.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SexMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SexMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SexMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SexMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SexMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *SexMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SexMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SexMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[sex.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SexMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[sex.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SexMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, sex.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *SexMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *SexMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *SexMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[sex.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *SexMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[sex.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *SexMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, sex.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *SexMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *SexMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *SexMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *SexMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SexMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SexMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *SexMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SexMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Sex entity.
// If the Sex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SexMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SexMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[sex.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SexMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[sex.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SexMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, sex.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *SexMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *SexMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *SexMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *SexMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *SexMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *SexMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *SexMutation) AddPersonIDs(ids ...int) {
	if m.people == nil {
		m.people = make(map[int]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *SexMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *SexMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *SexMutation) RemovePersonIDs(ids ...int) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *SexMutation) RemovedPeopleIDs() (ids []int) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *SexMutation) PeopleIDs() (ids []int) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *SexMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// Where appends a list predicates to the SexMutation builder.
func (m *SexMutation) Where(ps ...predicate.Sex) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SexMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Sex).
func (m *SexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SexMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, sex.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, sex.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, sex.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, sex.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, sex.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, sex.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, sex.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, sex.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, sex.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SexMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sex.FieldCreatedAt:
		return m.CreatedAt()
	case sex.FieldCreatedBy:
		return m.CreatedBy()
	case sex.FieldCreatedWith:
		return m.CreatedWith()
	case sex.FieldUpdatedAt:
		return m.UpdatedAt()
	case sex.FieldUpdatedBy:
		return m.UpdatedBy()
	case sex.FieldUpdatedWith:
		return m.UpdatedWith()
	case sex.FieldShort:
		return m.Short()
	case sex.FieldTitle:
		return m.Title()
	case sex.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sex.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sex.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case sex.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case sex.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sex.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case sex.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case sex.FieldShort:
		return m.OldShort(ctx)
	case sex.FieldTitle:
		return m.OldTitle(ctx)
	case sex.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Sex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SexMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sex.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sex.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case sex.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case sex.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sex.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case sex.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case sex.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case sex.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case sex.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Sex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SexMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, sex.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, sex.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SexMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sex.FieldCreatedBy:
		return m.AddedCreatedBy()
	case sex.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SexMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sex.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case sex.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Sex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SexMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sex.FieldCreatedBy) {
		fields = append(fields, sex.FieldCreatedBy)
	}
	if m.FieldCleared(sex.FieldCreatedWith) {
		fields = append(fields, sex.FieldCreatedWith)
	}
	if m.FieldCleared(sex.FieldUpdatedBy) {
		fields = append(fields, sex.FieldUpdatedBy)
	}
	if m.FieldCleared(sex.FieldUpdatedWith) {
		fields = append(fields, sex.FieldUpdatedWith)
	}
	if m.FieldCleared(sex.FieldDescription) {
		fields = append(fields, sex.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SexMutation) ClearField(name string) error {
	switch name {
	case sex.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case sex.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case sex.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case sex.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case sex.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Sex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SexMutation) ResetField(name string) error {
	switch name {
	case sex.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sex.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case sex.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case sex.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sex.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case sex.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case sex.FieldShort:
		m.ResetShort()
		return nil
	case sex.FieldTitle:
		m.ResetTitle()
		return nil
	case sex.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Sex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SexMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, sex.EdgeMetadata)
	}
	if m.people != nil {
		edges = append(edges, sex.EdgePeople)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SexMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sex.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case sex.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpeople != nil {
		edges = append(edges, sex.EdgePeople)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SexMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sex.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, sex.EdgeMetadata)
	}
	if m.clearedpeople {
		edges = append(edges, sex.EdgePeople)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SexMutation) EdgeCleared(name string) bool {
	switch name {
	case sex.EdgeMetadata:
		return m.clearedmetadata
	case sex.EdgePeople:
		return m.clearedpeople
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SexMutation) ClearEdge(name string) error {
	switch name {
	case sex.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Sex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SexMutation) ResetEdge(name string) error {
	switch name {
	case sex.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case sex.EdgePeople:
		m.ResetPeople()
		return nil
	}
	return fmt.Errorf("unknown Sex edge %s", name)
}

// StateMutation represents an operation that mutates the State nodes in the graph.
type StateMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *int
	addcreated_by                *int
	created_with                 *string
	updated_at                   *time.Time
	updated_by                   *int
	addupdated_by                *int
	updated_with                 *string
	short                        *string
	title                        *string
	description                  *string
	clearedFields                map[string]struct{}
	vehicle_registrations        map[int]struct{}
	removedvehicle_registrations map[int]struct{}
	clearedvehicle_registrations bool
	done                         bool
	oldValue                     func(context.Context) (*State, error)
	predicates                   []predicate.State
}

var _ ent.Mutation = (*StateMutation)(nil)

// stateOption allows management of the mutation configuration using functional options.
type stateOption func(*StateMutation)

// newStateMutation creates new mutation for the State entity.
func newStateMutation(c config, op Op, opts ...stateOption) *StateMutation {
	m := &StateMutation{
		config:        c,
		op:            op,
		typ:           TypeState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStateID sets the ID field of the mutation.
func withStateID(id int) stateOption {
	return func(m *StateMutation) {
		var (
			err   error
			once  sync.Once
			value *State
		)
		m.oldValue = func(ctx context.Context) (*State, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().State.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withState sets the old State of the mutation.
func withState(node *State) stateOption {
	return func(m *StateMutation) {
		m.oldValue = func(context.Context) (*State, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *StateMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StateMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *StateMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *StateMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StateMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[state.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StateMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[state.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StateMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, state.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *StateMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *StateMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *StateMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[state.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *StateMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[state.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *StateMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, state.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StateMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StateMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *StateMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *StateMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StateMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[state.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StateMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[state.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StateMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, state.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *StateMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *StateMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *StateMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[state.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *StateMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[state.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *StateMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, state.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *StateMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *StateMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *StateMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *StateMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *StateMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *StateMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *StateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[state.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[state.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, state.FieldDescription)
}

// AddVehicleRegistrationIDs adds the "vehicle_registrations" edge to the VehicleRegistration entity by ids.
func (m *StateMutation) AddVehicleRegistrationIDs(ids ...int) {
	if m.vehicle_registrations == nil {
		m.vehicle_registrations = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicle_registrations[ids[i]] = struct{}{}
	}
}

// ClearVehicleRegistrations clears the "vehicle_registrations" edge to the VehicleRegistration entity.
func (m *StateMutation) ClearVehicleRegistrations() {
	m.clearedvehicle_registrations = true
}

// VehicleRegistrationsCleared reports if the "vehicle_registrations" edge to the VehicleRegistration entity was cleared.
func (m *StateMutation) VehicleRegistrationsCleared() bool {
	return m.clearedvehicle_registrations
}

// RemoveVehicleRegistrationIDs removes the "vehicle_registrations" edge to the VehicleRegistration entity by IDs.
func (m *StateMutation) RemoveVehicleRegistrationIDs(ids ...int) {
	if m.removedvehicle_registrations == nil {
		m.removedvehicle_registrations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicle_registrations, ids[i])
		m.removedvehicle_registrations[ids[i]] = struct{}{}
	}
}

// RemovedVehicleRegistrations returns the removed IDs of the "vehicle_registrations" edge to the VehicleRegistration entity.
func (m *StateMutation) RemovedVehicleRegistrationsIDs() (ids []int) {
	for id := range m.removedvehicle_registrations {
		ids = append(ids, id)
	}
	return
}

// VehicleRegistrationsIDs returns the "vehicle_registrations" edge IDs in the mutation.
func (m *StateMutation) VehicleRegistrationsIDs() (ids []int) {
	for id := range m.vehicle_registrations {
		ids = append(ids, id)
	}
	return
}

// ResetVehicleRegistrations resets all changes to the "vehicle_registrations" edge.
func (m *StateMutation) ResetVehicleRegistrations() {
	m.vehicle_registrations = nil
	m.clearedvehicle_registrations = false
	m.removedvehicle_registrations = nil
}

// Where appends a list predicates to the StateMutation builder.
func (m *StateMutation) Where(ps ...predicate.State) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (State).
func (m *StateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, state.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, state.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, state.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, state.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, state.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, state.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, state.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, state.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, state.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case state.FieldCreatedAt:
		return m.CreatedAt()
	case state.FieldCreatedBy:
		return m.CreatedBy()
	case state.FieldCreatedWith:
		return m.CreatedWith()
	case state.FieldUpdatedAt:
		return m.UpdatedAt()
	case state.FieldUpdatedBy:
		return m.UpdatedBy()
	case state.FieldUpdatedWith:
		return m.UpdatedWith()
	case state.FieldShort:
		return m.Short()
	case state.FieldTitle:
		return m.Title()
	case state.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case state.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case state.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case state.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case state.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case state.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case state.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case state.FieldShort:
		return m.OldShort(ctx)
	case state.FieldTitle:
		return m.OldTitle(ctx)
	case state.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown State field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case state.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case state.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case state.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case state.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case state.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case state.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case state.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case state.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case state.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown State field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StateMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, state.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, state.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case state.FieldCreatedBy:
		return m.AddedCreatedBy()
	case state.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case state.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case state.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown State numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(state.FieldCreatedBy) {
		fields = append(fields, state.FieldCreatedBy)
	}
	if m.FieldCleared(state.FieldCreatedWith) {
		fields = append(fields, state.FieldCreatedWith)
	}
	if m.FieldCleared(state.FieldUpdatedBy) {
		fields = append(fields, state.FieldUpdatedBy)
	}
	if m.FieldCleared(state.FieldUpdatedWith) {
		fields = append(fields, state.FieldUpdatedWith)
	}
	if m.FieldCleared(state.FieldDescription) {
		fields = append(fields, state.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StateMutation) ClearField(name string) error {
	switch name {
	case state.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case state.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case state.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case state.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case state.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown State nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StateMutation) ResetField(name string) error {
	switch name {
	case state.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case state.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case state.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case state.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case state.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case state.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case state.FieldShort:
		m.ResetShort()
		return nil
	case state.FieldTitle:
		m.ResetTitle()
		return nil
	case state.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown State field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vehicle_registrations != nil {
		edges = append(edges, state.EdgeVehicleRegistrations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case state.EdgeVehicleRegistrations:
		ids := make([]ent.Value, 0, len(m.vehicle_registrations))
		for id := range m.vehicle_registrations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvehicle_registrations != nil {
		edges = append(edges, state.EdgeVehicleRegistrations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case state.EdgeVehicleRegistrations:
		ids := make([]ent.Value, 0, len(m.removedvehicle_registrations))
		for id := range m.removedvehicle_registrations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvehicle_registrations {
		edges = append(edges, state.EdgeVehicleRegistrations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StateMutation) EdgeCleared(name string) bool {
	switch name {
	case state.EdgeVehicleRegistrations:
		return m.clearedvehicle_registrations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown State unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StateMutation) ResetEdge(name string) error {
	switch name {
	case state.EdgeVehicleRegistrations:
		m.ResetVehicleRegistrations()
		return nil
	}
	return fmt.Errorf("unknown State edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	created_by               *int
	addcreated_by            *int
	created_with             *string
	updated_at               *time.Time
	updated_by               *int
	addupdated_by            *int
	updated_with             *string
	name                     *string
	email                    *string
	password                 *string
	avatar_url               *string
	permissions              *[]int
	first_setup_at           *time.Time
	clearedFields            map[string]struct{}
	metadata                 *int
	clearedmetadata          bool
	oauth_connections        map[int]struct{}
	removedoauth_connections map[int]struct{}
	clearedoauth_connections bool
	people                   map[int]struct{}
	removedpeople            map[int]struct{}
	clearedpeople            bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[user.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, user.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *UserMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *UserMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *UserMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[user.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *UserMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *UserMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, user.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *UserMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *UserMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *UserMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[user.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *UserMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *UserMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, user.FieldUpdatedWith)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetPermissions sets the "permissions" field.
func (m *UserMutation) SetPermissions(i []int) {
	m.permissions = &i
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserMutation) Permissions() (r []int, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPermissions(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ClearPermissions clears the value of the "permissions" field.
func (m *UserMutation) ClearPermissions() {
	m.permissions = nil
	m.clearedFields[user.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *UserMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[user.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	delete(m.clearedFields, user.FieldPermissions)
}

// SetFirstSetupAt sets the "first_setup_at" field.
func (m *UserMutation) SetFirstSetupAt(t time.Time) {
	m.first_setup_at = &t
}

// FirstSetupAt returns the value of the "first_setup_at" field in the mutation.
func (m *UserMutation) FirstSetupAt() (r time.Time, exists bool) {
	v := m.first_setup_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstSetupAt returns the old "first_setup_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstSetupAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstSetupAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstSetupAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstSetupAt: %w", err)
	}
	return oldValue.FirstSetupAt, nil
}

// ClearFirstSetupAt clears the value of the "first_setup_at" field.
func (m *UserMutation) ClearFirstSetupAt() {
	m.first_setup_at = nil
	m.clearedFields[user.FieldFirstSetupAt] = struct{}{}
}

// FirstSetupAtCleared returns if the "first_setup_at" field was cleared in this mutation.
func (m *UserMutation) FirstSetupAtCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstSetupAt]
	return ok
}

// ResetFirstSetupAt resets all changes to the "first_setup_at" field.
func (m *UserMutation) ResetFirstSetupAt() {
	m.first_setup_at = nil
	delete(m.clearedFields, user.FieldFirstSetupAt)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *UserMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *UserMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *UserMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *UserMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddOauthConnectionIDs adds the "oauth_connections" edge to the OAuthConnection entity by ids.
func (m *UserMutation) AddOauthConnectionIDs(ids ...int) {
	if m.oauth_connections == nil {
		m.oauth_connections = make(map[int]struct{})
	}
	for i := range ids {
		m.oauth_connections[ids[i]] = struct{}{}
	}
}

// ClearOauthConnections clears the "oauth_connections" edge to the OAuthConnection entity.
func (m *UserMutation) ClearOauthConnections() {
	m.clearedoauth_connections = true
}

// OauthConnectionsCleared reports if the "oauth_connections" edge to the OAuthConnection entity was cleared.
func (m *UserMutation) OauthConnectionsCleared() bool {
	return m.clearedoauth_connections
}

// RemoveOauthConnectionIDs removes the "oauth_connections" edge to the OAuthConnection entity by IDs.
func (m *UserMutation) RemoveOauthConnectionIDs(ids ...int) {
	if m.removedoauth_connections == nil {
		m.removedoauth_connections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.oauth_connections, ids[i])
		m.removedoauth_connections[ids[i]] = struct{}{}
	}
}

// RemovedOauthConnections returns the removed IDs of the "oauth_connections" edge to the OAuthConnection entity.
func (m *UserMutation) RemovedOauthConnectionsIDs() (ids []int) {
	for id := range m.removedoauth_connections {
		ids = append(ids, id)
	}
	return
}

// OauthConnectionsIDs returns the "oauth_connections" edge IDs in the mutation.
func (m *UserMutation) OauthConnectionsIDs() (ids []int) {
	for id := range m.oauth_connections {
		ids = append(ids, id)
	}
	return
}

// ResetOauthConnections resets all changes to the "oauth_connections" edge.
func (m *UserMutation) ResetOauthConnections() {
	m.oauth_connections = nil
	m.clearedoauth_connections = false
	m.removedoauth_connections = nil
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *UserMutation) AddPersonIDs(ids ...int) {
	if m.people == nil {
		m.people = make(map[int]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *UserMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *UserMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *UserMutation) RemovePersonIDs(ids ...int) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *UserMutation) RemovedPeopleIDs() (ids []int) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *UserMutation) PeopleIDs() (ids []int) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *UserMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, user.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, user.FieldUpdatedWith)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.permissions != nil {
		fields = append(fields, user.FieldPermissions)
	}
	if m.first_setup_at != nil {
		fields = append(fields, user.FieldFirstSetupAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldCreatedWith:
		return m.CreatedWith()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldUpdatedWith:
		return m.UpdatedWith()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldPermissions:
		return m.Permissions()
	case user.FieldFirstSetupAt:
		return m.FirstSetupAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldPermissions:
		return m.OldPermissions(ctx)
	case user.FieldFirstSetupAt:
		return m.OldFirstSetupAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldPermissions:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case user.FieldFirstSetupAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstSetupAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedBy) {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.FieldCleared(user.FieldCreatedWith) {
		fields = append(fields, user.FieldCreatedWith)
	}
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedWith) {
		fields = append(fields, user.FieldUpdatedWith)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldPermissions) {
		fields = append(fields, user.FieldPermissions)
	}
	if m.FieldCleared(user.FieldFirstSetupAt) {
		fields = append(fields, user.FieldFirstSetupAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldPermissions:
		m.ClearPermissions()
		return nil
	case user.FieldFirstSetupAt:
		m.ClearFirstSetupAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldPermissions:
		m.ResetPermissions()
		return nil
	case user.FieldFirstSetupAt:
		m.ResetFirstSetupAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.metadata != nil {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.oauth_connections != nil {
		edges = append(edges, user.EdgeOauthConnections)
	}
	if m.people != nil {
		edges = append(edges, user.EdgePeople)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOauthConnections:
		ids := make([]ent.Value, 0, len(m.oauth_connections))
		for id := range m.oauth_connections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedoauth_connections != nil {
		edges = append(edges, user.EdgeOauthConnections)
	}
	if m.removedpeople != nil {
		edges = append(edges, user.EdgePeople)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOauthConnections:
		ids := make([]ent.Value, 0, len(m.removedoauth_connections))
		for id := range m.removedoauth_connections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmetadata {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.clearedoauth_connections {
		edges = append(edges, user.EdgeOauthConnections)
	}
	if m.clearedpeople {
		edges = append(edges, user.EdgePeople)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeMetadata:
		return m.clearedmetadata
	case user.EdgeOauthConnections:
		return m.clearedoauth_connections
	case user.EdgePeople:
		return m.clearedpeople
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case user.EdgeOauthConnections:
		m.ResetOauthConnections()
		return nil
	case user.EdgePeople:
		m.ResetPeople()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VehicleMutation represents an operation that mutates the Vehicle nodes in the graph.
type VehicleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *int
	addcreated_by        *int
	created_with         *string
	updated_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_with         *string
	vin                  *string
	style                *string
	extra_features       *time.Time
	private_notes        *string
	clearedFields        map[string]struct{}
	metadata             *int
	clearedmetadata      bool
	registrations        map[int]struct{}
	removedregistrations map[int]struct{}
	clearedregistrations bool
	make                 *int
	clearedmake          bool
	model                *int
	clearedmodel         bool
	major_color          *int
	clearedmajor_color   bool
	minor_color          *int
	clearedminor_color   bool
	class                *int
	clearedclass         bool
	done                 bool
	oldValue             func(context.Context) (*Vehicle, error)
	predicates           []predicate.Vehicle
}

var _ ent.Mutation = (*VehicleMutation)(nil)

// vehicleOption allows management of the mutation configuration using functional options.
type vehicleOption func(*VehicleMutation)

// newVehicleMutation creates new mutation for the Vehicle entity.
func newVehicleMutation(c config, op Op, opts ...vehicleOption) *VehicleMutation {
	m := &VehicleMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleID sets the ID field of the mutation.
func withVehicleID(id int) vehicleOption {
	return func(m *VehicleMutation) {
		var (
			err   error
			once  sync.Once
			value *Vehicle
		)
		m.oldValue = func(ctx context.Context) (*Vehicle, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vehicle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicle sets the old Vehicle of the mutation.
func withVehicle(node *Vehicle) vehicleOption {
	return func(m *VehicleMutation) {
		m.oldValue = func(context.Context) (*Vehicle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VehicleMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VehicleMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VehicleMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VehicleMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VehicleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[vehicle.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VehicleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VehicleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, vehicle.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *VehicleMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *VehicleMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *VehicleMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[vehicle.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *VehicleMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *VehicleMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, vehicle.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VehicleMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VehicleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VehicleMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VehicleMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VehicleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[vehicle.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VehicleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VehicleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, vehicle.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *VehicleMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *VehicleMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *VehicleMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[vehicle.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *VehicleMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *VehicleMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, vehicle.FieldUpdatedWith)
}

// SetVin sets the "vin" field.
func (m *VehicleMutation) SetVin(s string) {
	m.vin = &s
}

// Vin returns the value of the "vin" field in the mutation.
func (m *VehicleMutation) Vin() (r string, exists bool) {
	v := m.vin
	if v == nil {
		return
	}
	return *v, true
}

// OldVin returns the old "vin" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldVin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVin: %w", err)
	}
	return oldValue.Vin, nil
}

// ClearVin clears the value of the "vin" field.
func (m *VehicleMutation) ClearVin() {
	m.vin = nil
	m.clearedFields[vehicle.FieldVin] = struct{}{}
}

// VinCleared returns if the "vin" field was cleared in this mutation.
func (m *VehicleMutation) VinCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldVin]
	return ok
}

// ResetVin resets all changes to the "vin" field.
func (m *VehicleMutation) ResetVin() {
	m.vin = nil
	delete(m.clearedFields, vehicle.FieldVin)
}

// SetStyle sets the "style" field.
func (m *VehicleMutation) SetStyle(s string) {
	m.style = &s
}

// Style returns the value of the "style" field in the mutation.
func (m *VehicleMutation) Style() (r string, exists bool) {
	v := m.style
	if v == nil {
		return
	}
	return *v, true
}

// OldStyle returns the old "style" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldStyle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStyle: %w", err)
	}
	return oldValue.Style, nil
}

// ClearStyle clears the value of the "style" field.
func (m *VehicleMutation) ClearStyle() {
	m.style = nil
	m.clearedFields[vehicle.FieldStyle] = struct{}{}
}

// StyleCleared returns if the "style" field was cleared in this mutation.
func (m *VehicleMutation) StyleCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldStyle]
	return ok
}

// ResetStyle resets all changes to the "style" field.
func (m *VehicleMutation) ResetStyle() {
	m.style = nil
	delete(m.clearedFields, vehicle.FieldStyle)
}

// SetExtraFeatures sets the "extra_features" field.
func (m *VehicleMutation) SetExtraFeatures(t time.Time) {
	m.extra_features = &t
}

// ExtraFeatures returns the value of the "extra_features" field in the mutation.
func (m *VehicleMutation) ExtraFeatures() (r time.Time, exists bool) {
	v := m.extra_features
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraFeatures returns the old "extra_features" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldExtraFeatures(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExtraFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExtraFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraFeatures: %w", err)
	}
	return oldValue.ExtraFeatures, nil
}

// ClearExtraFeatures clears the value of the "extra_features" field.
func (m *VehicleMutation) ClearExtraFeatures() {
	m.extra_features = nil
	m.clearedFields[vehicle.FieldExtraFeatures] = struct{}{}
}

// ExtraFeaturesCleared returns if the "extra_features" field was cleared in this mutation.
func (m *VehicleMutation) ExtraFeaturesCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldExtraFeatures]
	return ok
}

// ResetExtraFeatures resets all changes to the "extra_features" field.
func (m *VehicleMutation) ResetExtraFeatures() {
	m.extra_features = nil
	delete(m.clearedFields, vehicle.FieldExtraFeatures)
}

// SetPrivateNotes sets the "private_notes" field.
func (m *VehicleMutation) SetPrivateNotes(s string) {
	m.private_notes = &s
}

// PrivateNotes returns the value of the "private_notes" field in the mutation.
func (m *VehicleMutation) PrivateNotes() (r string, exists bool) {
	v := m.private_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateNotes returns the old "private_notes" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldPrivateNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrivateNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrivateNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateNotes: %w", err)
	}
	return oldValue.PrivateNotes, nil
}

// ClearPrivateNotes clears the value of the "private_notes" field.
func (m *VehicleMutation) ClearPrivateNotes() {
	m.private_notes = nil
	m.clearedFields[vehicle.FieldPrivateNotes] = struct{}{}
}

// PrivateNotesCleared returns if the "private_notes" field was cleared in this mutation.
func (m *VehicleMutation) PrivateNotesCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldPrivateNotes]
	return ok
}

// ResetPrivateNotes resets all changes to the "private_notes" field.
func (m *VehicleMutation) ResetPrivateNotes() {
	m.private_notes = nil
	delete(m.clearedFields, vehicle.FieldPrivateNotes)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *VehicleMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *VehicleMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *VehicleMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *VehicleMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *VehicleMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddRegistrationIDs adds the "registrations" edge to the VehicleRegistration entity by ids.
func (m *VehicleMutation) AddRegistrationIDs(ids ...int) {
	if m.registrations == nil {
		m.registrations = make(map[int]struct{})
	}
	for i := range ids {
		m.registrations[ids[i]] = struct{}{}
	}
}

// ClearRegistrations clears the "registrations" edge to the VehicleRegistration entity.
func (m *VehicleMutation) ClearRegistrations() {
	m.clearedregistrations = true
}

// RegistrationsCleared reports if the "registrations" edge to the VehicleRegistration entity was cleared.
func (m *VehicleMutation) RegistrationsCleared() bool {
	return m.clearedregistrations
}

// RemoveRegistrationIDs removes the "registrations" edge to the VehicleRegistration entity by IDs.
func (m *VehicleMutation) RemoveRegistrationIDs(ids ...int) {
	if m.removedregistrations == nil {
		m.removedregistrations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrations, ids[i])
		m.removedregistrations[ids[i]] = struct{}{}
	}
}

// RemovedRegistrations returns the removed IDs of the "registrations" edge to the VehicleRegistration entity.
func (m *VehicleMutation) RemovedRegistrationsIDs() (ids []int) {
	for id := range m.removedregistrations {
		ids = append(ids, id)
	}
	return
}

// RegistrationsIDs returns the "registrations" edge IDs in the mutation.
func (m *VehicleMutation) RegistrationsIDs() (ids []int) {
	for id := range m.registrations {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrations resets all changes to the "registrations" edge.
func (m *VehicleMutation) ResetRegistrations() {
	m.registrations = nil
	m.clearedregistrations = false
	m.removedregistrations = nil
}

// SetMakeID sets the "make" edge to the VehicleMake entity by id.
func (m *VehicleMutation) SetMakeID(id int) {
	m.make = &id
}

// ClearMake clears the "make" edge to the VehicleMake entity.
func (m *VehicleMutation) ClearMake() {
	m.clearedmake = true
}

// MakeCleared reports if the "make" edge to the VehicleMake entity was cleared.
func (m *VehicleMutation) MakeCleared() bool {
	return m.clearedmake
}

// MakeID returns the "make" edge ID in the mutation.
func (m *VehicleMutation) MakeID() (id int, exists bool) {
	if m.make != nil {
		return *m.make, true
	}
	return
}

// MakeIDs returns the "make" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MakeID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) MakeIDs() (ids []int) {
	if id := m.make; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMake resets all changes to the "make" edge.
func (m *VehicleMutation) ResetMake() {
	m.make = nil
	m.clearedmake = false
}

// SetModelID sets the "model" edge to the VehicleModel entity by id.
func (m *VehicleMutation) SetModelID(id int) {
	m.model = &id
}

// ClearModel clears the "model" edge to the VehicleModel entity.
func (m *VehicleMutation) ClearModel() {
	m.clearedmodel = true
}

// ModelCleared reports if the "model" edge to the VehicleModel entity was cleared.
func (m *VehicleMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelID returns the "model" edge ID in the mutation.
func (m *VehicleMutation) ModelID() (id int, exists bool) {
	if m.model != nil {
		return *m.model, true
	}
	return
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) ModelIDs() (ids []int) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *VehicleMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// SetMajorColorID sets the "major_color" edge to the VehicleColor entity by id.
func (m *VehicleMutation) SetMajorColorID(id int) {
	m.major_color = &id
}

// ClearMajorColor clears the "major_color" edge to the VehicleColor entity.
func (m *VehicleMutation) ClearMajorColor() {
	m.clearedmajor_color = true
}

// MajorColorCleared reports if the "major_color" edge to the VehicleColor entity was cleared.
func (m *VehicleMutation) MajorColorCleared() bool {
	return m.clearedmajor_color
}

// MajorColorID returns the "major_color" edge ID in the mutation.
func (m *VehicleMutation) MajorColorID() (id int, exists bool) {
	if m.major_color != nil {
		return *m.major_color, true
	}
	return
}

// MajorColorIDs returns the "major_color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorColorID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) MajorColorIDs() (ids []int) {
	if id := m.major_color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajorColor resets all changes to the "major_color" edge.
func (m *VehicleMutation) ResetMajorColor() {
	m.major_color = nil
	m.clearedmajor_color = false
}

// SetMinorColorID sets the "minor_color" edge to the VehicleColor entity by id.
func (m *VehicleMutation) SetMinorColorID(id int) {
	m.minor_color = &id
}

// ClearMinorColor clears the "minor_color" edge to the VehicleColor entity.
func (m *VehicleMutation) ClearMinorColor() {
	m.clearedminor_color = true
}

// MinorColorCleared reports if the "minor_color" edge to the VehicleColor entity was cleared.
func (m *VehicleMutation) MinorColorCleared() bool {
	return m.clearedminor_color
}

// MinorColorID returns the "minor_color" edge ID in the mutation.
func (m *VehicleMutation) MinorColorID() (id int, exists bool) {
	if m.minor_color != nil {
		return *m.minor_color, true
	}
	return
}

// MinorColorIDs returns the "minor_color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MinorColorID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) MinorColorIDs() (ids []int) {
	if id := m.minor_color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMinorColor resets all changes to the "minor_color" edge.
func (m *VehicleMutation) ResetMinorColor() {
	m.minor_color = nil
	m.clearedminor_color = false
}

// SetClassID sets the "class" edge to the VehicleClass entity by id.
func (m *VehicleMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the VehicleClass entity.
func (m *VehicleMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the VehicleClass entity was cleared.
func (m *VehicleMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *VehicleMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *VehicleMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the VehicleMutation builder.
func (m *VehicleMutation) Where(ps ...predicate.Vehicle) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VehicleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vehicle).
func (m *VehicleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, vehicle.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, vehicle.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, vehicle.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicle.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, vehicle.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, vehicle.FieldUpdatedWith)
	}
	if m.vin != nil {
		fields = append(fields, vehicle.FieldVin)
	}
	if m.style != nil {
		fields = append(fields, vehicle.FieldStyle)
	}
	if m.extra_features != nil {
		fields = append(fields, vehicle.FieldExtraFeatures)
	}
	if m.private_notes != nil {
		fields = append(fields, vehicle.FieldPrivateNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldCreatedAt:
		return m.CreatedAt()
	case vehicle.FieldCreatedBy:
		return m.CreatedBy()
	case vehicle.FieldCreatedWith:
		return m.CreatedWith()
	case vehicle.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehicle.FieldUpdatedBy:
		return m.UpdatedBy()
	case vehicle.FieldUpdatedWith:
		return m.UpdatedWith()
	case vehicle.FieldVin:
		return m.Vin()
	case vehicle.FieldStyle:
		return m.Style()
	case vehicle.FieldExtraFeatures:
		return m.ExtraFeatures()
	case vehicle.FieldPrivateNotes:
		return m.PrivateNotes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vehicle.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case vehicle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehicle.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vehicle.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case vehicle.FieldVin:
		return m.OldVin(ctx)
	case vehicle.FieldStyle:
		return m.OldStyle(ctx)
	case vehicle.FieldExtraFeatures:
		return m.OldExtraFeatures(ctx)
	case vehicle.FieldPrivateNotes:
		return m.OldPrivateNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Vehicle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicle.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vehicle.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case vehicle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehicle.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vehicle.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case vehicle.FieldVin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVin(v)
		return nil
	case vehicle.FieldStyle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStyle(v)
		return nil
	case vehicle.FieldExtraFeatures:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraFeatures(v)
		return nil
	case vehicle.FieldPrivateNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vehicle.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vehicle.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vehicle.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vehicle.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehicle.FieldCreatedBy) {
		fields = append(fields, vehicle.FieldCreatedBy)
	}
	if m.FieldCleared(vehicle.FieldCreatedWith) {
		fields = append(fields, vehicle.FieldCreatedWith)
	}
	if m.FieldCleared(vehicle.FieldUpdatedBy) {
		fields = append(fields, vehicle.FieldUpdatedBy)
	}
	if m.FieldCleared(vehicle.FieldUpdatedWith) {
		fields = append(fields, vehicle.FieldUpdatedWith)
	}
	if m.FieldCleared(vehicle.FieldVin) {
		fields = append(fields, vehicle.FieldVin)
	}
	if m.FieldCleared(vehicle.FieldStyle) {
		fields = append(fields, vehicle.FieldStyle)
	}
	if m.FieldCleared(vehicle.FieldExtraFeatures) {
		fields = append(fields, vehicle.FieldExtraFeatures)
	}
	if m.FieldCleared(vehicle.FieldPrivateNotes) {
		fields = append(fields, vehicle.FieldPrivateNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMutation) ClearField(name string) error {
	switch name {
	case vehicle.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case vehicle.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case vehicle.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case vehicle.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case vehicle.FieldVin:
		m.ClearVin()
		return nil
	case vehicle.FieldStyle:
		m.ClearStyle()
		return nil
	case vehicle.FieldExtraFeatures:
		m.ClearExtraFeatures()
		return nil
	case vehicle.FieldPrivateNotes:
		m.ClearPrivateNotes()
		return nil
	}
	return fmt.Errorf("unknown Vehicle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMutation) ResetField(name string) error {
	switch name {
	case vehicle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vehicle.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case vehicle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehicle.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vehicle.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case vehicle.FieldVin:
		m.ResetVin()
		return nil
	case vehicle.FieldStyle:
		m.ResetStyle()
		return nil
	case vehicle.FieldExtraFeatures:
		m.ResetExtraFeatures()
		return nil
	case vehicle.FieldPrivateNotes:
		m.ResetPrivateNotes()
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.metadata != nil {
		edges = append(edges, vehicle.EdgeMetadata)
	}
	if m.registrations != nil {
		edges = append(edges, vehicle.EdgeRegistrations)
	}
	if m.make != nil {
		edges = append(edges, vehicle.EdgeMake)
	}
	if m.model != nil {
		edges = append(edges, vehicle.EdgeModel)
	}
	if m.major_color != nil {
		edges = append(edges, vehicle.EdgeMajorColor)
	}
	if m.minor_color != nil {
		edges = append(edges, vehicle.EdgeMinorColor)
	}
	if m.class != nil {
		edges = append(edges, vehicle.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeRegistrations:
		ids := make([]ent.Value, 0, len(m.registrations))
		for id := range m.registrations {
			ids = append(ids, id)
		}
		return ids
	case vehicle.EdgeMake:
		if id := m.make; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeMajorColor:
		if id := m.major_color; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeMinorColor:
		if id := m.minor_color; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedregistrations != nil {
		edges = append(edges, vehicle.EdgeRegistrations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeRegistrations:
		ids := make([]ent.Value, 0, len(m.removedregistrations))
		for id := range m.removedregistrations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedmetadata {
		edges = append(edges, vehicle.EdgeMetadata)
	}
	if m.clearedregistrations {
		edges = append(edges, vehicle.EdgeRegistrations)
	}
	if m.clearedmake {
		edges = append(edges, vehicle.EdgeMake)
	}
	if m.clearedmodel {
		edges = append(edges, vehicle.EdgeModel)
	}
	if m.clearedmajor_color {
		edges = append(edges, vehicle.EdgeMajorColor)
	}
	if m.clearedminor_color {
		edges = append(edges, vehicle.EdgeMinorColor)
	}
	if m.clearedclass {
		edges = append(edges, vehicle.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicle.EdgeMetadata:
		return m.clearedmetadata
	case vehicle.EdgeRegistrations:
		return m.clearedregistrations
	case vehicle.EdgeMake:
		return m.clearedmake
	case vehicle.EdgeModel:
		return m.clearedmodel
	case vehicle.EdgeMajorColor:
		return m.clearedmajor_color
	case vehicle.EdgeMinorColor:
		return m.clearedminor_color
	case vehicle.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMutation) ClearEdge(name string) error {
	switch name {
	case vehicle.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case vehicle.EdgeMake:
		m.ClearMake()
		return nil
	case vehicle.EdgeModel:
		m.ClearModel()
		return nil
	case vehicle.EdgeMajorColor:
		m.ClearMajorColor()
		return nil
	case vehicle.EdgeMinorColor:
		m.ClearMinorColor()
		return nil
	case vehicle.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Vehicle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMutation) ResetEdge(name string) error {
	switch name {
	case vehicle.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case vehicle.EdgeRegistrations:
		m.ResetRegistrations()
		return nil
	case vehicle.EdgeMake:
		m.ResetMake()
		return nil
	case vehicle.EdgeModel:
		m.ResetModel()
		return nil
	case vehicle.EdgeMajorColor:
		m.ResetMajorColor()
		return nil
	case vehicle.EdgeMinorColor:
		m.ResetMinorColor()
		return nil
	case vehicle.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Vehicle edge %s", name)
}

// VehicleClassMutation represents an operation that mutates the VehicleClass nodes in the graph.
type VehicleClassMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *int
	addcreated_by   *int
	created_with    *string
	updated_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_with    *string
	short           *string
	title           *string
	description     *string
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	vehicles        map[int]struct{}
	removedvehicles map[int]struct{}
	clearedvehicles bool
	done            bool
	oldValue        func(context.Context) (*VehicleClass, error)
	predicates      []predicate.VehicleClass
}

var _ ent.Mutation = (*VehicleClassMutation)(nil)

// vehicleclassOption allows management of the mutation configuration using functional options.
type vehicleclassOption func(*VehicleClassMutation)

// newVehicleClassMutation creates new mutation for the VehicleClass entity.
func newVehicleClassMutation(c config, op Op, opts ...vehicleclassOption) *VehicleClassMutation {
	m := &VehicleClassMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleClassID sets the ID field of the mutation.
func withVehicleClassID(id int) vehicleclassOption {
	return func(m *VehicleClassMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleClass
		)
		m.oldValue = func(ctx context.Context) (*VehicleClass, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleClass sets the old VehicleClass of the mutation.
func withVehicleClass(node *VehicleClass) vehicleclassOption {
	return func(m *VehicleClassMutation) {
		m.oldValue = func(context.Context) (*VehicleClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleClassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VehicleClassMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VehicleClassMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VehicleClassMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VehicleClassMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VehicleClassMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[vehicleclass.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VehicleClassMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[vehicleclass.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VehicleClassMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, vehicleclass.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *VehicleClassMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *VehicleClassMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *VehicleClassMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[vehicleclass.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *VehicleClassMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[vehicleclass.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *VehicleClassMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, vehicleclass.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VehicleClassMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VehicleClassMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VehicleClassMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VehicleClassMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VehicleClassMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[vehicleclass.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VehicleClassMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[vehicleclass.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VehicleClassMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, vehicleclass.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *VehicleClassMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *VehicleClassMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *VehicleClassMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[vehicleclass.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *VehicleClassMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[vehicleclass.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *VehicleClassMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, vehicleclass.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *VehicleClassMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *VehicleClassMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *VehicleClassMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *VehicleClassMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VehicleClassMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VehicleClassMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VehicleClassMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VehicleClassMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VehicleClass entity.
// If the VehicleClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleClassMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VehicleClassMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vehicleclass.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VehicleClassMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vehicleclass.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VehicleClassMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vehicleclass.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *VehicleClassMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *VehicleClassMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *VehicleClassMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *VehicleClassMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *VehicleClassMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *VehicleClassMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddVehicleIDs adds the "vehicles" edge to the Vehicle entity by ids.
func (m *VehicleClassMutation) AddVehicleIDs(ids ...int) {
	if m.vehicles == nil {
		m.vehicles = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicles[ids[i]] = struct{}{}
	}
}

// ClearVehicles clears the "vehicles" edge to the Vehicle entity.
func (m *VehicleClassMutation) ClearVehicles() {
	m.clearedvehicles = true
}

// VehiclesCleared reports if the "vehicles" edge to the Vehicle entity was cleared.
func (m *VehicleClassMutation) VehiclesCleared() bool {
	return m.clearedvehicles
}

// RemoveVehicleIDs removes the "vehicles" edge to the Vehicle entity by IDs.
func (m *VehicleClassMutation) RemoveVehicleIDs(ids ...int) {
	if m.removedvehicles == nil {
		m.removedvehicles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicles, ids[i])
		m.removedvehicles[ids[i]] = struct{}{}
	}
}

// RemovedVehicles returns the removed IDs of the "vehicles" edge to the Vehicle entity.
func (m *VehicleClassMutation) RemovedVehiclesIDs() (ids []int) {
	for id := range m.removedvehicles {
		ids = append(ids, id)
	}
	return
}

// VehiclesIDs returns the "vehicles" edge IDs in the mutation.
func (m *VehicleClassMutation) VehiclesIDs() (ids []int) {
	for id := range m.vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetVehicles resets all changes to the "vehicles" edge.
func (m *VehicleClassMutation) ResetVehicles() {
	m.vehicles = nil
	m.clearedvehicles = false
	m.removedvehicles = nil
}

// Where appends a list predicates to the VehicleClassMutation builder.
func (m *VehicleClassMutation) Where(ps ...predicate.VehicleClass) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VehicleClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VehicleClass).
func (m *VehicleClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleClassMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, vehicleclass.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, vehicleclass.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, vehicleclass.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicleclass.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, vehicleclass.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, vehicleclass.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, vehicleclass.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, vehicleclass.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, vehicleclass.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicleclass.FieldCreatedAt:
		return m.CreatedAt()
	case vehicleclass.FieldCreatedBy:
		return m.CreatedBy()
	case vehicleclass.FieldCreatedWith:
		return m.CreatedWith()
	case vehicleclass.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehicleclass.FieldUpdatedBy:
		return m.UpdatedBy()
	case vehicleclass.FieldUpdatedWith:
		return m.UpdatedWith()
	case vehicleclass.FieldShort:
		return m.Short()
	case vehicleclass.FieldTitle:
		return m.Title()
	case vehicleclass.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicleclass.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicleclass.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vehicleclass.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case vehicleclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehicleclass.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vehicleclass.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case vehicleclass.FieldShort:
		return m.OldShort(ctx)
	case vehicleclass.FieldTitle:
		return m.OldTitle(ctx)
	case vehicleclass.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicleclass.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicleclass.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vehicleclass.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case vehicleclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehicleclass.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vehicleclass.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case vehicleclass.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case vehicleclass.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case vehicleclass.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleClassMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vehicleclass.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vehicleclass.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicleclass.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vehicleclass.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicleclass.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vehicleclass.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehicleclass.FieldCreatedBy) {
		fields = append(fields, vehicleclass.FieldCreatedBy)
	}
	if m.FieldCleared(vehicleclass.FieldCreatedWith) {
		fields = append(fields, vehicleclass.FieldCreatedWith)
	}
	if m.FieldCleared(vehicleclass.FieldUpdatedBy) {
		fields = append(fields, vehicleclass.FieldUpdatedBy)
	}
	if m.FieldCleared(vehicleclass.FieldUpdatedWith) {
		fields = append(fields, vehicleclass.FieldUpdatedWith)
	}
	if m.FieldCleared(vehicleclass.FieldDescription) {
		fields = append(fields, vehicleclass.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleClassMutation) ClearField(name string) error {
	switch name {
	case vehicleclass.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case vehicleclass.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case vehicleclass.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case vehicleclass.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case vehicleclass.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleClassMutation) ResetField(name string) error {
	switch name {
	case vehicleclass.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicleclass.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vehicleclass.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case vehicleclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehicleclass.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vehicleclass.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case vehicleclass.FieldShort:
		m.ResetShort()
		return nil
	case vehicleclass.FieldTitle:
		m.ResetTitle()
		return nil
	case vehicleclass.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, vehicleclass.EdgeMetadata)
	}
	if m.vehicles != nil {
		edges = append(edges, vehicleclass.EdgeVehicles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicleclass.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case vehicleclass.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.vehicles))
		for id := range m.vehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvehicles != nil {
		edges = append(edges, vehicleclass.EdgeVehicles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehicleclass.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.removedvehicles))
		for id := range m.removedvehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, vehicleclass.EdgeMetadata)
	}
	if m.clearedvehicles {
		edges = append(edges, vehicleclass.EdgeVehicles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleClassMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicleclass.EdgeMetadata:
		return m.clearedmetadata
	case vehicleclass.EdgeVehicles:
		return m.clearedvehicles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleClassMutation) ClearEdge(name string) error {
	switch name {
	case vehicleclass.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown VehicleClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleClassMutation) ResetEdge(name string) error {
	switch name {
	case vehicleclass.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case vehicleclass.EdgeVehicles:
		m.ResetVehicles()
		return nil
	}
	return fmt.Errorf("unknown VehicleClass edge %s", name)
}

// VehicleColorMutation represents an operation that mutates the VehicleColor nodes in the graph.
type VehicleColorMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	created_by            *int
	addcreated_by         *int
	created_with          *string
	updated_at            *time.Time
	updated_by            *int
	addupdated_by         *int
	updated_with          *string
	short                 *string
	title                 *string
	description           *string
	clearedFields         map[string]struct{}
	metadata              *int
	clearedmetadata       bool
	vehicles_major        map[int]struct{}
	removedvehicles_major map[int]struct{}
	clearedvehicles_major bool
	vehicles_minor        map[int]struct{}
	removedvehicles_minor map[int]struct{}
	clearedvehicles_minor bool
	done                  bool
	oldValue              func(context.Context) (*VehicleColor, error)
	predicates            []predicate.VehicleColor
}

var _ ent.Mutation = (*VehicleColorMutation)(nil)

// vehiclecolorOption allows management of the mutation configuration using functional options.
type vehiclecolorOption func(*VehicleColorMutation)

// newVehicleColorMutation creates new mutation for the VehicleColor entity.
func newVehicleColorMutation(c config, op Op, opts ...vehiclecolorOption) *VehicleColorMutation {
	m := &VehicleColorMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleColorID sets the ID field of the mutation.
func withVehicleColorID(id int) vehiclecolorOption {
	return func(m *VehicleColorMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleColor
		)
		m.oldValue = func(ctx context.Context) (*VehicleColor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleColor sets the old VehicleColor of the mutation.
func withVehicleColor(node *VehicleColor) vehiclecolorOption {
	return func(m *VehicleColorMutation) {
		m.oldValue = func(context.Context) (*VehicleColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleColorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleColorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleColorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleColorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VehicleColorMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VehicleColorMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VehicleColorMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VehicleColorMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VehicleColorMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[vehiclecolor.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VehicleColorMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[vehiclecolor.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VehicleColorMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, vehiclecolor.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *VehicleColorMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *VehicleColorMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *VehicleColorMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[vehiclecolor.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *VehicleColorMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[vehiclecolor.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *VehicleColorMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, vehiclecolor.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleColorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleColorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleColorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VehicleColorMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VehicleColorMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VehicleColorMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VehicleColorMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VehicleColorMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[vehiclecolor.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VehicleColorMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[vehiclecolor.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VehicleColorMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, vehiclecolor.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *VehicleColorMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *VehicleColorMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *VehicleColorMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[vehiclecolor.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *VehicleColorMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[vehiclecolor.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *VehicleColorMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, vehiclecolor.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *VehicleColorMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *VehicleColorMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *VehicleColorMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *VehicleColorMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VehicleColorMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VehicleColorMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VehicleColorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VehicleColorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VehicleColor entity.
// If the VehicleColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleColorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VehicleColorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vehiclecolor.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VehicleColorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vehiclecolor.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VehicleColorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vehiclecolor.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *VehicleColorMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *VehicleColorMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *VehicleColorMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *VehicleColorMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *VehicleColorMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *VehicleColorMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddVehiclesMajorIDs adds the "vehicles_major" edge to the Vehicle entity by ids.
func (m *VehicleColorMutation) AddVehiclesMajorIDs(ids ...int) {
	if m.vehicles_major == nil {
		m.vehicles_major = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicles_major[ids[i]] = struct{}{}
	}
}

// ClearVehiclesMajor clears the "vehicles_major" edge to the Vehicle entity.
func (m *VehicleColorMutation) ClearVehiclesMajor() {
	m.clearedvehicles_major = true
}

// VehiclesMajorCleared reports if the "vehicles_major" edge to the Vehicle entity was cleared.
func (m *VehicleColorMutation) VehiclesMajorCleared() bool {
	return m.clearedvehicles_major
}

// RemoveVehiclesMajorIDs removes the "vehicles_major" edge to the Vehicle entity by IDs.
func (m *VehicleColorMutation) RemoveVehiclesMajorIDs(ids ...int) {
	if m.removedvehicles_major == nil {
		m.removedvehicles_major = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicles_major, ids[i])
		m.removedvehicles_major[ids[i]] = struct{}{}
	}
}

// RemovedVehiclesMajor returns the removed IDs of the "vehicles_major" edge to the Vehicle entity.
func (m *VehicleColorMutation) RemovedVehiclesMajorIDs() (ids []int) {
	for id := range m.removedvehicles_major {
		ids = append(ids, id)
	}
	return
}

// VehiclesMajorIDs returns the "vehicles_major" edge IDs in the mutation.
func (m *VehicleColorMutation) VehiclesMajorIDs() (ids []int) {
	for id := range m.vehicles_major {
		ids = append(ids, id)
	}
	return
}

// ResetVehiclesMajor resets all changes to the "vehicles_major" edge.
func (m *VehicleColorMutation) ResetVehiclesMajor() {
	m.vehicles_major = nil
	m.clearedvehicles_major = false
	m.removedvehicles_major = nil
}

// AddVehiclesMinorIDs adds the "vehicles_minor" edge to the Vehicle entity by ids.
func (m *VehicleColorMutation) AddVehiclesMinorIDs(ids ...int) {
	if m.vehicles_minor == nil {
		m.vehicles_minor = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicles_minor[ids[i]] = struct{}{}
	}
}

// ClearVehiclesMinor clears the "vehicles_minor" edge to the Vehicle entity.
func (m *VehicleColorMutation) ClearVehiclesMinor() {
	m.clearedvehicles_minor = true
}

// VehiclesMinorCleared reports if the "vehicles_minor" edge to the Vehicle entity was cleared.
func (m *VehicleColorMutation) VehiclesMinorCleared() bool {
	return m.clearedvehicles_minor
}

// RemoveVehiclesMinorIDs removes the "vehicles_minor" edge to the Vehicle entity by IDs.
func (m *VehicleColorMutation) RemoveVehiclesMinorIDs(ids ...int) {
	if m.removedvehicles_minor == nil {
		m.removedvehicles_minor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicles_minor, ids[i])
		m.removedvehicles_minor[ids[i]] = struct{}{}
	}
}

// RemovedVehiclesMinor returns the removed IDs of the "vehicles_minor" edge to the Vehicle entity.
func (m *VehicleColorMutation) RemovedVehiclesMinorIDs() (ids []int) {
	for id := range m.removedvehicles_minor {
		ids = append(ids, id)
	}
	return
}

// VehiclesMinorIDs returns the "vehicles_minor" edge IDs in the mutation.
func (m *VehicleColorMutation) VehiclesMinorIDs() (ids []int) {
	for id := range m.vehicles_minor {
		ids = append(ids, id)
	}
	return
}

// ResetVehiclesMinor resets all changes to the "vehicles_minor" edge.
func (m *VehicleColorMutation) ResetVehiclesMinor() {
	m.vehicles_minor = nil
	m.clearedvehicles_minor = false
	m.removedvehicles_minor = nil
}

// Where appends a list predicates to the VehicleColorMutation builder.
func (m *VehicleColorMutation) Where(ps ...predicate.VehicleColor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VehicleColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VehicleColor).
func (m *VehicleColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleColorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, vehiclecolor.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, vehiclecolor.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, vehiclecolor.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, vehiclecolor.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, vehiclecolor.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, vehiclecolor.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, vehiclecolor.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, vehiclecolor.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, vehiclecolor.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehiclecolor.FieldCreatedAt:
		return m.CreatedAt()
	case vehiclecolor.FieldCreatedBy:
		return m.CreatedBy()
	case vehiclecolor.FieldCreatedWith:
		return m.CreatedWith()
	case vehiclecolor.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehiclecolor.FieldUpdatedBy:
		return m.UpdatedBy()
	case vehiclecolor.FieldUpdatedWith:
		return m.UpdatedWith()
	case vehiclecolor.FieldShort:
		return m.Short()
	case vehiclecolor.FieldTitle:
		return m.Title()
	case vehiclecolor.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehiclecolor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehiclecolor.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vehiclecolor.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case vehiclecolor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehiclecolor.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vehiclecolor.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case vehiclecolor.FieldShort:
		return m.OldShort(ctx)
	case vehiclecolor.FieldTitle:
		return m.OldTitle(ctx)
	case vehiclecolor.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleColor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehiclecolor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehiclecolor.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vehiclecolor.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case vehiclecolor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehiclecolor.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vehiclecolor.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case vehiclecolor.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case vehiclecolor.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case vehiclecolor.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleColorMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vehiclecolor.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vehiclecolor.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleColorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehiclecolor.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vehiclecolor.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehiclecolor.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vehiclecolor.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleColorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehiclecolor.FieldCreatedBy) {
		fields = append(fields, vehiclecolor.FieldCreatedBy)
	}
	if m.FieldCleared(vehiclecolor.FieldCreatedWith) {
		fields = append(fields, vehiclecolor.FieldCreatedWith)
	}
	if m.FieldCleared(vehiclecolor.FieldUpdatedBy) {
		fields = append(fields, vehiclecolor.FieldUpdatedBy)
	}
	if m.FieldCleared(vehiclecolor.FieldUpdatedWith) {
		fields = append(fields, vehiclecolor.FieldUpdatedWith)
	}
	if m.FieldCleared(vehiclecolor.FieldDescription) {
		fields = append(fields, vehiclecolor.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleColorMutation) ClearField(name string) error {
	switch name {
	case vehiclecolor.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case vehiclecolor.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case vehiclecolor.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case vehiclecolor.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case vehiclecolor.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleColor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleColorMutation) ResetField(name string) error {
	switch name {
	case vehiclecolor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehiclecolor.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vehiclecolor.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case vehiclecolor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehiclecolor.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vehiclecolor.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case vehiclecolor.FieldShort:
		m.ResetShort()
		return nil
	case vehiclecolor.FieldTitle:
		m.ResetTitle()
		return nil
	case vehiclecolor.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.metadata != nil {
		edges = append(edges, vehiclecolor.EdgeMetadata)
	}
	if m.vehicles_major != nil {
		edges = append(edges, vehiclecolor.EdgeVehiclesMajor)
	}
	if m.vehicles_minor != nil {
		edges = append(edges, vehiclecolor.EdgeVehiclesMinor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleColorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehiclecolor.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case vehiclecolor.EdgeVehiclesMajor:
		ids := make([]ent.Value, 0, len(m.vehicles_major))
		for id := range m.vehicles_major {
			ids = append(ids, id)
		}
		return ids
	case vehiclecolor.EdgeVehiclesMinor:
		ids := make([]ent.Value, 0, len(m.vehicles_minor))
		for id := range m.vehicles_minor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvehicles_major != nil {
		edges = append(edges, vehiclecolor.EdgeVehiclesMajor)
	}
	if m.removedvehicles_minor != nil {
		edges = append(edges, vehiclecolor.EdgeVehiclesMinor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleColorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehiclecolor.EdgeVehiclesMajor:
		ids := make([]ent.Value, 0, len(m.removedvehicles_major))
		for id := range m.removedvehicles_major {
			ids = append(ids, id)
		}
		return ids
	case vehiclecolor.EdgeVehiclesMinor:
		ids := make([]ent.Value, 0, len(m.removedvehicles_minor))
		for id := range m.removedvehicles_minor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmetadata {
		edges = append(edges, vehiclecolor.EdgeMetadata)
	}
	if m.clearedvehicles_major {
		edges = append(edges, vehiclecolor.EdgeVehiclesMajor)
	}
	if m.clearedvehicles_minor {
		edges = append(edges, vehiclecolor.EdgeVehiclesMinor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleColorMutation) EdgeCleared(name string) bool {
	switch name {
	case vehiclecolor.EdgeMetadata:
		return m.clearedmetadata
	case vehiclecolor.EdgeVehiclesMajor:
		return m.clearedvehicles_major
	case vehiclecolor.EdgeVehiclesMinor:
		return m.clearedvehicles_minor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleColorMutation) ClearEdge(name string) error {
	switch name {
	case vehiclecolor.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown VehicleColor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleColorMutation) ResetEdge(name string) error {
	switch name {
	case vehiclecolor.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case vehiclecolor.EdgeVehiclesMajor:
		m.ResetVehiclesMajor()
		return nil
	case vehiclecolor.EdgeVehiclesMinor:
		m.ResetVehiclesMinor()
		return nil
	}
	return fmt.Errorf("unknown VehicleColor edge %s", name)
}

// VehicleMakeMutation represents an operation that mutates the VehicleMake nodes in the graph.
type VehicleMakeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *int
	addcreated_by   *int
	created_with    *string
	updated_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_with    *string
	short           *string
	title           *string
	description     *string
	clearedFields   map[string]struct{}
	vehicles        map[int]struct{}
	removedvehicles map[int]struct{}
	clearedvehicles bool
	done            bool
	oldValue        func(context.Context) (*VehicleMake, error)
	predicates      []predicate.VehicleMake
}

var _ ent.Mutation = (*VehicleMakeMutation)(nil)

// vehiclemakeOption allows management of the mutation configuration using functional options.
type vehiclemakeOption func(*VehicleMakeMutation)

// newVehicleMakeMutation creates new mutation for the VehicleMake entity.
func newVehicleMakeMutation(c config, op Op, opts ...vehiclemakeOption) *VehicleMakeMutation {
	m := &VehicleMakeMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleMake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleMakeID sets the ID field of the mutation.
func withVehicleMakeID(id int) vehiclemakeOption {
	return func(m *VehicleMakeMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleMake
		)
		m.oldValue = func(ctx context.Context) (*VehicleMake, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleMake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleMake sets the old VehicleMake of the mutation.
func withVehicleMake(node *VehicleMake) vehiclemakeOption {
	return func(m *VehicleMakeMutation) {
		m.oldValue = func(context.Context) (*VehicleMake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleMakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleMakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleMakeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VehicleMakeMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VehicleMakeMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VehicleMakeMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VehicleMakeMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VehicleMakeMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[vehiclemake.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VehicleMakeMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[vehiclemake.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VehicleMakeMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, vehiclemake.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *VehicleMakeMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *VehicleMakeMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *VehicleMakeMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[vehiclemake.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *VehicleMakeMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[vehiclemake.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *VehicleMakeMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, vehiclemake.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleMakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleMakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleMakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VehicleMakeMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VehicleMakeMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VehicleMakeMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VehicleMakeMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VehicleMakeMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[vehiclemake.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VehicleMakeMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[vehiclemake.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VehicleMakeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, vehiclemake.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *VehicleMakeMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *VehicleMakeMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *VehicleMakeMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[vehiclemake.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *VehicleMakeMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[vehiclemake.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *VehicleMakeMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, vehiclemake.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *VehicleMakeMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *VehicleMakeMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *VehicleMakeMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *VehicleMakeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VehicleMakeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VehicleMakeMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VehicleMakeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VehicleMakeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VehicleMake entity.
// If the VehicleMake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMakeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VehicleMakeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vehiclemake.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VehicleMakeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vehiclemake.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VehicleMakeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vehiclemake.FieldDescription)
}

// AddVehicleIDs adds the "vehicles" edge to the Vehicle entity by ids.
func (m *VehicleMakeMutation) AddVehicleIDs(ids ...int) {
	if m.vehicles == nil {
		m.vehicles = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicles[ids[i]] = struct{}{}
	}
}

// ClearVehicles clears the "vehicles" edge to the Vehicle entity.
func (m *VehicleMakeMutation) ClearVehicles() {
	m.clearedvehicles = true
}

// VehiclesCleared reports if the "vehicles" edge to the Vehicle entity was cleared.
func (m *VehicleMakeMutation) VehiclesCleared() bool {
	return m.clearedvehicles
}

// RemoveVehicleIDs removes the "vehicles" edge to the Vehicle entity by IDs.
func (m *VehicleMakeMutation) RemoveVehicleIDs(ids ...int) {
	if m.removedvehicles == nil {
		m.removedvehicles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicles, ids[i])
		m.removedvehicles[ids[i]] = struct{}{}
	}
}

// RemovedVehicles returns the removed IDs of the "vehicles" edge to the Vehicle entity.
func (m *VehicleMakeMutation) RemovedVehiclesIDs() (ids []int) {
	for id := range m.removedvehicles {
		ids = append(ids, id)
	}
	return
}

// VehiclesIDs returns the "vehicles" edge IDs in the mutation.
func (m *VehicleMakeMutation) VehiclesIDs() (ids []int) {
	for id := range m.vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetVehicles resets all changes to the "vehicles" edge.
func (m *VehicleMakeMutation) ResetVehicles() {
	m.vehicles = nil
	m.clearedvehicles = false
	m.removedvehicles = nil
}

// Where appends a list predicates to the VehicleMakeMutation builder.
func (m *VehicleMakeMutation) Where(ps ...predicate.VehicleMake) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VehicleMakeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VehicleMake).
func (m *VehicleMakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMakeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, vehiclemake.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, vehiclemake.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, vehiclemake.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, vehiclemake.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, vehiclemake.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, vehiclemake.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, vehiclemake.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, vehiclemake.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, vehiclemake.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehiclemake.FieldCreatedAt:
		return m.CreatedAt()
	case vehiclemake.FieldCreatedBy:
		return m.CreatedBy()
	case vehiclemake.FieldCreatedWith:
		return m.CreatedWith()
	case vehiclemake.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehiclemake.FieldUpdatedBy:
		return m.UpdatedBy()
	case vehiclemake.FieldUpdatedWith:
		return m.UpdatedWith()
	case vehiclemake.FieldShort:
		return m.Short()
	case vehiclemake.FieldTitle:
		return m.Title()
	case vehiclemake.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehiclemake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehiclemake.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vehiclemake.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case vehiclemake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehiclemake.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vehiclemake.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case vehiclemake.FieldShort:
		return m.OldShort(ctx)
	case vehiclemake.FieldTitle:
		return m.OldTitle(ctx)
	case vehiclemake.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleMake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehiclemake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehiclemake.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vehiclemake.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case vehiclemake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehiclemake.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vehiclemake.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case vehiclemake.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case vehiclemake.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case vehiclemake.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleMake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMakeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vehiclemake.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vehiclemake.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehiclemake.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vehiclemake.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehiclemake.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vehiclemake.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleMake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehiclemake.FieldCreatedBy) {
		fields = append(fields, vehiclemake.FieldCreatedBy)
	}
	if m.FieldCleared(vehiclemake.FieldCreatedWith) {
		fields = append(fields, vehiclemake.FieldCreatedWith)
	}
	if m.FieldCleared(vehiclemake.FieldUpdatedBy) {
		fields = append(fields, vehiclemake.FieldUpdatedBy)
	}
	if m.FieldCleared(vehiclemake.FieldUpdatedWith) {
		fields = append(fields, vehiclemake.FieldUpdatedWith)
	}
	if m.FieldCleared(vehiclemake.FieldDescription) {
		fields = append(fields, vehiclemake.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMakeMutation) ClearField(name string) error {
	switch name {
	case vehiclemake.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case vehiclemake.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case vehiclemake.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case vehiclemake.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case vehiclemake.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleMake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMakeMutation) ResetField(name string) error {
	switch name {
	case vehiclemake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehiclemake.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vehiclemake.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case vehiclemake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehiclemake.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vehiclemake.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case vehiclemake.FieldShort:
		m.ResetShort()
		return nil
	case vehiclemake.FieldTitle:
		m.ResetTitle()
		return nil
	case vehiclemake.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleMake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vehicles != nil {
		edges = append(edges, vehiclemake.EdgeVehicles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehiclemake.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.vehicles))
		for id := range m.vehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvehicles != nil {
		edges = append(edges, vehiclemake.EdgeVehicles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMakeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehiclemake.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.removedvehicles))
		for id := range m.removedvehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvehicles {
		edges = append(edges, vehiclemake.EdgeVehicles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMakeMutation) EdgeCleared(name string) bool {
	switch name {
	case vehiclemake.EdgeVehicles:
		return m.clearedvehicles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMakeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VehicleMake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMakeMutation) ResetEdge(name string) error {
	switch name {
	case vehiclemake.EdgeVehicles:
		m.ResetVehicles()
		return nil
	}
	return fmt.Errorf("unknown VehicleMake edge %s", name)
}

// VehicleModelMutation represents an operation that mutates the VehicleModel nodes in the graph.
type VehicleModelMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *int
	addcreated_by   *int
	created_with    *string
	updated_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_with    *string
	short           *string
	title           *string
	description     *string
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	vehicles        map[int]struct{}
	removedvehicles map[int]struct{}
	clearedvehicles bool
	done            bool
	oldValue        func(context.Context) (*VehicleModel, error)
	predicates      []predicate.VehicleModel
}

var _ ent.Mutation = (*VehicleModelMutation)(nil)

// vehiclemodelOption allows management of the mutation configuration using functional options.
type vehiclemodelOption func(*VehicleModelMutation)

// newVehicleModelMutation creates new mutation for the VehicleModel entity.
func newVehicleModelMutation(c config, op Op, opts ...vehiclemodelOption) *VehicleModelMutation {
	m := &VehicleModelMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleModelID sets the ID field of the mutation.
func withVehicleModelID(id int) vehiclemodelOption {
	return func(m *VehicleModelMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleModel
		)
		m.oldValue = func(ctx context.Context) (*VehicleModel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleModel sets the old VehicleModel of the mutation.
func withVehicleModel(node *VehicleModel) vehiclemodelOption {
	return func(m *VehicleModelMutation) {
		m.oldValue = func(context.Context) (*VehicleModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleModelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VehicleModelMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VehicleModelMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VehicleModelMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VehicleModelMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VehicleModelMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[vehiclemodel.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VehicleModelMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[vehiclemodel.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VehicleModelMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, vehiclemodel.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *VehicleModelMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *VehicleModelMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *VehicleModelMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[vehiclemodel.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *VehicleModelMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[vehiclemodel.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *VehicleModelMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, vehiclemodel.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VehicleModelMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VehicleModelMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VehicleModelMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VehicleModelMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VehicleModelMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[vehiclemodel.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VehicleModelMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[vehiclemodel.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VehicleModelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, vehiclemodel.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *VehicleModelMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *VehicleModelMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *VehicleModelMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[vehiclemodel.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *VehicleModelMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[vehiclemodel.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *VehicleModelMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, vehiclemodel.FieldUpdatedWith)
}

// SetShort sets the "short" field.
func (m *VehicleModelMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *VehicleModelMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *VehicleModelMutation) ResetShort() {
	m.short = nil
}

// SetTitle sets the "title" field.
func (m *VehicleModelMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VehicleModelMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VehicleModelMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VehicleModelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VehicleModelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VehicleModel entity.
// If the VehicleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleModelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VehicleModelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vehiclemodel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VehicleModelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vehiclemodel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VehicleModelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vehiclemodel.FieldDescription)
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *VehicleModelMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *VehicleModelMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *VehicleModelMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *VehicleModelMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *VehicleModelMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *VehicleModelMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddVehicleIDs adds the "vehicles" edge to the Vehicle entity by ids.
func (m *VehicleModelMutation) AddVehicleIDs(ids ...int) {
	if m.vehicles == nil {
		m.vehicles = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicles[ids[i]] = struct{}{}
	}
}

// ClearVehicles clears the "vehicles" edge to the Vehicle entity.
func (m *VehicleModelMutation) ClearVehicles() {
	m.clearedvehicles = true
}

// VehiclesCleared reports if the "vehicles" edge to the Vehicle entity was cleared.
func (m *VehicleModelMutation) VehiclesCleared() bool {
	return m.clearedvehicles
}

// RemoveVehicleIDs removes the "vehicles" edge to the Vehicle entity by IDs.
func (m *VehicleModelMutation) RemoveVehicleIDs(ids ...int) {
	if m.removedvehicles == nil {
		m.removedvehicles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicles, ids[i])
		m.removedvehicles[ids[i]] = struct{}{}
	}
}

// RemovedVehicles returns the removed IDs of the "vehicles" edge to the Vehicle entity.
func (m *VehicleModelMutation) RemovedVehiclesIDs() (ids []int) {
	for id := range m.removedvehicles {
		ids = append(ids, id)
	}
	return
}

// VehiclesIDs returns the "vehicles" edge IDs in the mutation.
func (m *VehicleModelMutation) VehiclesIDs() (ids []int) {
	for id := range m.vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetVehicles resets all changes to the "vehicles" edge.
func (m *VehicleModelMutation) ResetVehicles() {
	m.vehicles = nil
	m.clearedvehicles = false
	m.removedvehicles = nil
}

// Where appends a list predicates to the VehicleModelMutation builder.
func (m *VehicleModelMutation) Where(ps ...predicate.VehicleModel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VehicleModelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VehicleModel).
func (m *VehicleModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleModelMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, vehiclemodel.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, vehiclemodel.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, vehiclemodel.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, vehiclemodel.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, vehiclemodel.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, vehiclemodel.FieldUpdatedWith)
	}
	if m.short != nil {
		fields = append(fields, vehiclemodel.FieldShort)
	}
	if m.title != nil {
		fields = append(fields, vehiclemodel.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, vehiclemodel.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehiclemodel.FieldCreatedAt:
		return m.CreatedAt()
	case vehiclemodel.FieldCreatedBy:
		return m.CreatedBy()
	case vehiclemodel.FieldCreatedWith:
		return m.CreatedWith()
	case vehiclemodel.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehiclemodel.FieldUpdatedBy:
		return m.UpdatedBy()
	case vehiclemodel.FieldUpdatedWith:
		return m.UpdatedWith()
	case vehiclemodel.FieldShort:
		return m.Short()
	case vehiclemodel.FieldTitle:
		return m.Title()
	case vehiclemodel.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehiclemodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehiclemodel.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vehiclemodel.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case vehiclemodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehiclemodel.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vehiclemodel.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case vehiclemodel.FieldShort:
		return m.OldShort(ctx)
	case vehiclemodel.FieldTitle:
		return m.OldTitle(ctx)
	case vehiclemodel.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehiclemodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehiclemodel.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vehiclemodel.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case vehiclemodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehiclemodel.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vehiclemodel.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case vehiclemodel.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case vehiclemodel.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case vehiclemodel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleModelMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vehiclemodel.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vehiclemodel.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehiclemodel.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vehiclemodel.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehiclemodel.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vehiclemodel.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehiclemodel.FieldCreatedBy) {
		fields = append(fields, vehiclemodel.FieldCreatedBy)
	}
	if m.FieldCleared(vehiclemodel.FieldCreatedWith) {
		fields = append(fields, vehiclemodel.FieldCreatedWith)
	}
	if m.FieldCleared(vehiclemodel.FieldUpdatedBy) {
		fields = append(fields, vehiclemodel.FieldUpdatedBy)
	}
	if m.FieldCleared(vehiclemodel.FieldUpdatedWith) {
		fields = append(fields, vehiclemodel.FieldUpdatedWith)
	}
	if m.FieldCleared(vehiclemodel.FieldDescription) {
		fields = append(fields, vehiclemodel.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleModelMutation) ClearField(name string) error {
	switch name {
	case vehiclemodel.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case vehiclemodel.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case vehiclemodel.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case vehiclemodel.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	case vehiclemodel.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleModelMutation) ResetField(name string) error {
	switch name {
	case vehiclemodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehiclemodel.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vehiclemodel.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case vehiclemodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehiclemodel.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vehiclemodel.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case vehiclemodel.FieldShort:
		m.ResetShort()
		return nil
	case vehiclemodel.FieldTitle:
		m.ResetTitle()
		return nil
	case vehiclemodel.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown VehicleModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, vehiclemodel.EdgeMetadata)
	}
	if m.vehicles != nil {
		edges = append(edges, vehiclemodel.EdgeVehicles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehiclemodel.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case vehiclemodel.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.vehicles))
		for id := range m.vehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvehicles != nil {
		edges = append(edges, vehiclemodel.EdgeVehicles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehiclemodel.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.removedvehicles))
		for id := range m.removedvehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, vehiclemodel.EdgeMetadata)
	}
	if m.clearedvehicles {
		edges = append(edges, vehiclemodel.EdgeVehicles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleModelMutation) EdgeCleared(name string) bool {
	switch name {
	case vehiclemodel.EdgeMetadata:
		return m.clearedmetadata
	case vehiclemodel.EdgeVehicles:
		return m.clearedvehicles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleModelMutation) ClearEdge(name string) error {
	switch name {
	case vehiclemodel.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown VehicleModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleModelMutation) ResetEdge(name string) error {
	switch name {
	case vehiclemodel.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case vehiclemodel.EdgeVehicles:
		m.ResetVehicles()
		return nil
	}
	return fmt.Errorf("unknown VehicleModel edge %s", name)
}

// VehicleRegistrationMutation represents an operation that mutates the VehicleRegistration nodes in the graph.
type VehicleRegistrationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *int
	addcreated_by   *int
	created_with    *string
	updated_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_with    *string
	plate           *string
	expired_at      *time.Time
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	state           *int
	clearedstate    bool
	person          *int
	clearedperson   bool
	vehicle         *int
	clearedvehicle  bool
	done            bool
	oldValue        func(context.Context) (*VehicleRegistration, error)
	predicates      []predicate.VehicleRegistration
}

var _ ent.Mutation = (*VehicleRegistrationMutation)(nil)

// vehicleregistrationOption allows management of the mutation configuration using functional options.
type vehicleregistrationOption func(*VehicleRegistrationMutation)

// newVehicleRegistrationMutation creates new mutation for the VehicleRegistration entity.
func newVehicleRegistrationMutation(c config, op Op, opts ...vehicleregistrationOption) *VehicleRegistrationMutation {
	m := &VehicleRegistrationMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleRegistration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleRegistrationID sets the ID field of the mutation.
func withVehicleRegistrationID(id int) vehicleregistrationOption {
	return func(m *VehicleRegistrationMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleRegistration
		)
		m.oldValue = func(ctx context.Context) (*VehicleRegistration, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleRegistration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleRegistration sets the old VehicleRegistration of the mutation.
func withVehicleRegistration(node *VehicleRegistration) vehicleregistrationOption {
	return func(m *VehicleRegistrationMutation) {
		m.oldValue = func(context.Context) (*VehicleRegistration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleRegistrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleRegistrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleRegistrationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleRegistrationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleRegistrationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleRegistrationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VehicleRegistrationMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VehicleRegistrationMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *VehicleRegistrationMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *VehicleRegistrationMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VehicleRegistrationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[vehicleregistration.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VehicleRegistrationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[vehicleregistration.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VehicleRegistrationMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, vehicleregistration.FieldCreatedBy)
}

// SetCreatedWith sets the "created_with" field.
func (m *VehicleRegistrationMutation) SetCreatedWith(s string) {
	m.created_with = &s
}

// CreatedWith returns the value of the "created_with" field in the mutation.
func (m *VehicleRegistrationMutation) CreatedWith() (r string, exists bool) {
	v := m.created_with
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedWith returns the old "created_with" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldCreatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedWith: %w", err)
	}
	return oldValue.CreatedWith, nil
}

// ClearCreatedWith clears the value of the "created_with" field.
func (m *VehicleRegistrationMutation) ClearCreatedWith() {
	m.created_with = nil
	m.clearedFields[vehicleregistration.FieldCreatedWith] = struct{}{}
}

// CreatedWithCleared returns if the "created_with" field was cleared in this mutation.
func (m *VehicleRegistrationMutation) CreatedWithCleared() bool {
	_, ok := m.clearedFields[vehicleregistration.FieldCreatedWith]
	return ok
}

// ResetCreatedWith resets all changes to the "created_with" field.
func (m *VehicleRegistrationMutation) ResetCreatedWith() {
	m.created_with = nil
	delete(m.clearedFields, vehicleregistration.FieldCreatedWith)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleRegistrationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleRegistrationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleRegistrationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VehicleRegistrationMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VehicleRegistrationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *VehicleRegistrationMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *VehicleRegistrationMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VehicleRegistrationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[vehicleregistration.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VehicleRegistrationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[vehicleregistration.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VehicleRegistrationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, vehicleregistration.FieldUpdatedBy)
}

// SetUpdatedWith sets the "updated_with" field.
func (m *VehicleRegistrationMutation) SetUpdatedWith(s string) {
	m.updated_with = &s
}

// UpdatedWith returns the value of the "updated_with" field in the mutation.
func (m *VehicleRegistrationMutation) UpdatedWith() (r string, exists bool) {
	v := m.updated_with
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedWith returns the old "updated_with" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldUpdatedWith(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedWith: %w", err)
	}
	return oldValue.UpdatedWith, nil
}

// ClearUpdatedWith clears the value of the "updated_with" field.
func (m *VehicleRegistrationMutation) ClearUpdatedWith() {
	m.updated_with = nil
	m.clearedFields[vehicleregistration.FieldUpdatedWith] = struct{}{}
}

// UpdatedWithCleared returns if the "updated_with" field was cleared in this mutation.
func (m *VehicleRegistrationMutation) UpdatedWithCleared() bool {
	_, ok := m.clearedFields[vehicleregistration.FieldUpdatedWith]
	return ok
}

// ResetUpdatedWith resets all changes to the "updated_with" field.
func (m *VehicleRegistrationMutation) ResetUpdatedWith() {
	m.updated_with = nil
	delete(m.clearedFields, vehicleregistration.FieldUpdatedWith)
}

// SetPlate sets the "plate" field.
func (m *VehicleRegistrationMutation) SetPlate(s string) {
	m.plate = &s
}

// Plate returns the value of the "plate" field in the mutation.
func (m *VehicleRegistrationMutation) Plate() (r string, exists bool) {
	v := m.plate
	if v == nil {
		return
	}
	return *v, true
}

// OldPlate returns the old "plate" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldPlate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlate: %w", err)
	}
	return oldValue.Plate, nil
}

// ResetPlate resets all changes to the "plate" field.
func (m *VehicleRegistrationMutation) ResetPlate() {
	m.plate = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *VehicleRegistrationMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *VehicleRegistrationMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the VehicleRegistration entity.
// If the VehicleRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleRegistrationMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *VehicleRegistrationMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetMetadataID sets the "metadata" edge to the Metadata entity by id.
func (m *VehicleRegistrationMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *VehicleRegistrationMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *VehicleRegistrationMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the "metadata" edge ID in the mutation.
func (m *VehicleRegistrationMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *VehicleRegistrationMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *VehicleRegistrationMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// SetStateID sets the "state" edge to the State entity by id.
func (m *VehicleRegistrationMutation) SetStateID(id int) {
	m.state = &id
}

// ClearState clears the "state" edge to the State entity.
func (m *VehicleRegistrationMutation) ClearState() {
	m.clearedstate = true
}

// StateCleared reports if the "state" edge to the State entity was cleared.
func (m *VehicleRegistrationMutation) StateCleared() bool {
	return m.clearedstate
}

// StateID returns the "state" edge ID in the mutation.
func (m *VehicleRegistrationMutation) StateID() (id int, exists bool) {
	if m.state != nil {
		return *m.state, true
	}
	return
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *VehicleRegistrationMutation) StateIDs() (ids []int) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *VehicleRegistrationMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// SetPersonID sets the "person" edge to the Person entity by id.
func (m *VehicleRegistrationMutation) SetPersonID(id int) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *VehicleRegistrationMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *VehicleRegistrationMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *VehicleRegistrationMutation) PersonID() (id int, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *VehicleRegistrationMutation) PersonIDs() (ids []int) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *VehicleRegistrationMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// SetVehicleID sets the "vehicle" edge to the Vehicle entity by id.
func (m *VehicleRegistrationMutation) SetVehicleID(id int) {
	m.vehicle = &id
}

// ClearVehicle clears the "vehicle" edge to the Vehicle entity.
func (m *VehicleRegistrationMutation) ClearVehicle() {
	m.clearedvehicle = true
}

// VehicleCleared reports if the "vehicle" edge to the Vehicle entity was cleared.
func (m *VehicleRegistrationMutation) VehicleCleared() bool {
	return m.clearedvehicle
}

// VehicleID returns the "vehicle" edge ID in the mutation.
func (m *VehicleRegistrationMutation) VehicleID() (id int, exists bool) {
	if m.vehicle != nil {
		return *m.vehicle, true
	}
	return
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *VehicleRegistrationMutation) VehicleIDs() (ids []int) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *VehicleRegistrationMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// Where appends a list predicates to the VehicleRegistrationMutation builder.
func (m *VehicleRegistrationMutation) Where(ps ...predicate.VehicleRegistration) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VehicleRegistrationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VehicleRegistration).
func (m *VehicleRegistrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleRegistrationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, vehicleregistration.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, vehicleregistration.FieldCreatedBy)
	}
	if m.created_with != nil {
		fields = append(fields, vehicleregistration.FieldCreatedWith)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicleregistration.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, vehicleregistration.FieldUpdatedBy)
	}
	if m.updated_with != nil {
		fields = append(fields, vehicleregistration.FieldUpdatedWith)
	}
	if m.plate != nil {
		fields = append(fields, vehicleregistration.FieldPlate)
	}
	if m.expired_at != nil {
		fields = append(fields, vehicleregistration.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleRegistrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicleregistration.FieldCreatedAt:
		return m.CreatedAt()
	case vehicleregistration.FieldCreatedBy:
		return m.CreatedBy()
	case vehicleregistration.FieldCreatedWith:
		return m.CreatedWith()
	case vehicleregistration.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehicleregistration.FieldUpdatedBy:
		return m.UpdatedBy()
	case vehicleregistration.FieldUpdatedWith:
		return m.UpdatedWith()
	case vehicleregistration.FieldPlate:
		return m.Plate()
	case vehicleregistration.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleRegistrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicleregistration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicleregistration.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vehicleregistration.FieldCreatedWith:
		return m.OldCreatedWith(ctx)
	case vehicleregistration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehicleregistration.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case vehicleregistration.FieldUpdatedWith:
		return m.OldUpdatedWith(ctx)
	case vehicleregistration.FieldPlate:
		return m.OldPlate(ctx)
	case vehicleregistration.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleRegistration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleRegistrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicleregistration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicleregistration.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vehicleregistration.FieldCreatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedWith(v)
		return nil
	case vehicleregistration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehicleregistration.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case vehicleregistration.FieldUpdatedWith:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedWith(v)
		return nil
	case vehicleregistration.FieldPlate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlate(v)
		return nil
	case vehicleregistration.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleRegistration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleRegistrationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, vehicleregistration.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, vehicleregistration.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleRegistrationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicleregistration.FieldCreatedBy:
		return m.AddedCreatedBy()
	case vehicleregistration.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleRegistrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicleregistration.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case vehicleregistration.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleRegistration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleRegistrationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehicleregistration.FieldCreatedBy) {
		fields = append(fields, vehicleregistration.FieldCreatedBy)
	}
	if m.FieldCleared(vehicleregistration.FieldCreatedWith) {
		fields = append(fields, vehicleregistration.FieldCreatedWith)
	}
	if m.FieldCleared(vehicleregistration.FieldUpdatedBy) {
		fields = append(fields, vehicleregistration.FieldUpdatedBy)
	}
	if m.FieldCleared(vehicleregistration.FieldUpdatedWith) {
		fields = append(fields, vehicleregistration.FieldUpdatedWith)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleRegistrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleRegistrationMutation) ClearField(name string) error {
	switch name {
	case vehicleregistration.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case vehicleregistration.FieldCreatedWith:
		m.ClearCreatedWith()
		return nil
	case vehicleregistration.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case vehicleregistration.FieldUpdatedWith:
		m.ClearUpdatedWith()
		return nil
	}
	return fmt.Errorf("unknown VehicleRegistration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleRegistrationMutation) ResetField(name string) error {
	switch name {
	case vehicleregistration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicleregistration.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vehicleregistration.FieldCreatedWith:
		m.ResetCreatedWith()
		return nil
	case vehicleregistration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehicleregistration.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case vehicleregistration.FieldUpdatedWith:
		m.ResetUpdatedWith()
		return nil
	case vehicleregistration.FieldPlate:
		m.ResetPlate()
		return nil
	case vehicleregistration.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown VehicleRegistration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleRegistrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.metadata != nil {
		edges = append(edges, vehicleregistration.EdgeMetadata)
	}
	if m.state != nil {
		edges = append(edges, vehicleregistration.EdgeState)
	}
	if m.person != nil {
		edges = append(edges, vehicleregistration.EdgePerson)
	}
	if m.vehicle != nil {
		edges = append(edges, vehicleregistration.EdgeVehicle)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleRegistrationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicleregistration.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case vehicleregistration.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case vehicleregistration.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case vehicleregistration.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleRegistrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleRegistrationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleRegistrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmetadata {
		edges = append(edges, vehicleregistration.EdgeMetadata)
	}
	if m.clearedstate {
		edges = append(edges, vehicleregistration.EdgeState)
	}
	if m.clearedperson {
		edges = append(edges, vehicleregistration.EdgePerson)
	}
	if m.clearedvehicle {
		edges = append(edges, vehicleregistration.EdgeVehicle)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleRegistrationMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicleregistration.EdgeMetadata:
		return m.clearedmetadata
	case vehicleregistration.EdgeState:
		return m.clearedstate
	case vehicleregistration.EdgePerson:
		return m.clearedperson
	case vehicleregistration.EdgeVehicle:
		return m.clearedvehicle
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleRegistrationMutation) ClearEdge(name string) error {
	switch name {
	case vehicleregistration.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case vehicleregistration.EdgeState:
		m.ClearState()
		return nil
	case vehicleregistration.EdgePerson:
		m.ClearPerson()
		return nil
	case vehicleregistration.EdgeVehicle:
		m.ClearVehicle()
		return nil
	}
	return fmt.Errorf("unknown VehicleRegistration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleRegistrationMutation) ResetEdge(name string) error {
	switch name {
	case vehicleregistration.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case vehicleregistration.EdgeState:
		m.ResetState()
		return nil
	case vehicleregistration.EdgePerson:
		m.ResetPerson()
		return nil
	case vehicleregistration.EdgeVehicle:
		m.ResetVehicle()
		return nil
	}
	return fmt.Errorf("unknown VehicleRegistration edge %s", name)
}
