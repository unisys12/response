// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/responserms/response/internal/ent/deathcertificate"
	"github.com/responserms/response/internal/ent/deathcertifier"
	"github.com/responserms/response/internal/ent/deathmanner"
	"github.com/responserms/response/internal/ent/deathplace"
	"github.com/responserms/response/internal/ent/ethnicity"
	"github.com/responserms/response/internal/ent/gameserver"
	"github.com/responserms/response/internal/ent/metadata"
	"github.com/responserms/response/internal/ent/oauthconnection"
	"github.com/responserms/response/internal/ent/person"
	"github.com/responserms/response/internal/ent/player"
	"github.com/responserms/response/internal/ent/playeridentifier"
	"github.com/responserms/response/internal/ent/race"
	"github.com/responserms/response/internal/ent/session"
	"github.com/responserms/response/internal/ent/setting"
	"github.com/responserms/response/internal/ent/sex"
	"github.com/responserms/response/internal/ent/state"
	"github.com/responserms/response/internal/ent/user"
	"github.com/responserms/response/internal/ent/vehicle"
	"github.com/responserms/response/internal/ent/vehicleclass"
	"github.com/responserms/response/internal/ent/vehiclecolor"
	"github.com/responserms/response/internal/ent/vehiclemake"
	"github.com/responserms/response/internal/ent/vehiclemodel"
	"github.com/responserms/response/internal/ent/vehicleregistration"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// DeathCertificateEdge is the edge representation of DeathCertificate.
type DeathCertificateEdge struct {
	Node   *DeathCertificate `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DeathCertificateConnection is the connection containing edges to DeathCertificate.
type DeathCertificateConnection struct {
	Edges      []*DeathCertificateEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// DeathCertificatePaginateOption enables pagination customization.
type DeathCertificatePaginateOption func(*deathCertificatePager) error

// WithDeathCertificateOrder configures pagination ordering.
func WithDeathCertificateOrder(order *DeathCertificateOrder) DeathCertificatePaginateOption {
	if order == nil {
		order = DefaultDeathCertificateOrder
	}
	o := *order
	return func(pager *deathCertificatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeathCertificateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeathCertificateFilter configures pagination filter.
func WithDeathCertificateFilter(filter func(*DeathCertificateQuery) (*DeathCertificateQuery, error)) DeathCertificatePaginateOption {
	return func(pager *deathCertificatePager) error {
		if filter == nil {
			return errors.New("DeathCertificateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deathCertificatePager struct {
	order  *DeathCertificateOrder
	filter func(*DeathCertificateQuery) (*DeathCertificateQuery, error)
}

func newDeathCertificatePager(opts []DeathCertificatePaginateOption) (*deathCertificatePager, error) {
	pager := &deathCertificatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeathCertificateOrder
	}
	return pager, nil
}

func (p *deathCertificatePager) applyFilter(query *DeathCertificateQuery) (*DeathCertificateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deathCertificatePager) toCursor(dc *DeathCertificate) Cursor {
	return p.order.Field.toCursor(dc)
}

func (p *deathCertificatePager) applyCursors(query *DeathCertificateQuery, after, before *Cursor) *DeathCertificateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDeathCertificateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *deathCertificatePager) applyOrder(query *DeathCertificateQuery, reverse bool) *DeathCertificateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDeathCertificateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDeathCertificateOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DeathCertificate.
func (dc *DeathCertificateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeathCertificatePaginateOption,
) (*DeathCertificateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeathCertificatePager(opts)
	if err != nil {
		return nil, err
	}

	if dc, err = pager.applyFilter(dc); err != nil {
		return nil, err
	}

	conn := &DeathCertificateConnection{Edges: []*DeathCertificateEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := dc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := dc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	dc = pager.applyCursors(dc, after, before)
	dc = pager.applyOrder(dc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		dc = dc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		dc = dc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := dc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DeathCertificate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeathCertificate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeathCertificate {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DeathCertificateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DeathCertificateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// DeathCertificateOrderFieldCreatedAt orders DeathCertificate by created_at.
	DeathCertificateOrderFieldCreatedAt = &DeathCertificateOrderField{
		field: deathcertificate.FieldCreatedAt,
		toCursor: func(dc *DeathCertificate) Cursor {
			return Cursor{
				ID:    dc.ID,
				Value: dc.CreatedAt,
			}
		},
	}
	// DeathCertificateOrderFieldUpdatedAt orders DeathCertificate by updated_at.
	DeathCertificateOrderFieldUpdatedAt = &DeathCertificateOrderField{
		field: deathcertificate.FieldUpdatedAt,
		toCursor: func(dc *DeathCertificate) Cursor {
			return Cursor{
				ID:    dc.ID,
				Value: dc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DeathCertificateOrderField) String() string {
	var str string
	switch f.field {
	case deathcertificate.FieldCreatedAt:
		str = "CREATED_AT"
	case deathcertificate.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DeathCertificateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DeathCertificateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DeathCertificateOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DeathCertificateOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DeathCertificateOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DeathCertificateOrderField", str)
	}
	return nil
}

// DeathCertificateOrderField defines the ordering field of DeathCertificate.
type DeathCertificateOrderField struct {
	field    string
	toCursor func(*DeathCertificate) Cursor
}

// DeathCertificateOrder defines the ordering of DeathCertificate.
type DeathCertificateOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DeathCertificateOrderField `json:"field"`
}

// DefaultDeathCertificateOrder is the default ordering of DeathCertificate.
var DefaultDeathCertificateOrder = &DeathCertificateOrder{
	Direction: OrderDirectionAsc,
	Field: &DeathCertificateOrderField{
		field: deathcertificate.FieldID,
		toCursor: func(dc *DeathCertificate) Cursor {
			return Cursor{ID: dc.ID}
		},
	},
}

// ToEdge converts DeathCertificate into DeathCertificateEdge.
func (dc *DeathCertificate) ToEdge(order *DeathCertificateOrder) *DeathCertificateEdge {
	if order == nil {
		order = DefaultDeathCertificateOrder
	}
	return &DeathCertificateEdge{
		Node:   dc,
		Cursor: order.Field.toCursor(dc),
	}
}

// DeathCertifierEdge is the edge representation of DeathCertifier.
type DeathCertifierEdge struct {
	Node   *DeathCertifier `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// DeathCertifierConnection is the connection containing edges to DeathCertifier.
type DeathCertifierConnection struct {
	Edges      []*DeathCertifierEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// DeathCertifierPaginateOption enables pagination customization.
type DeathCertifierPaginateOption func(*deathCertifierPager) error

// WithDeathCertifierOrder configures pagination ordering.
func WithDeathCertifierOrder(order *DeathCertifierOrder) DeathCertifierPaginateOption {
	if order == nil {
		order = DefaultDeathCertifierOrder
	}
	o := *order
	return func(pager *deathCertifierPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeathCertifierOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeathCertifierFilter configures pagination filter.
func WithDeathCertifierFilter(filter func(*DeathCertifierQuery) (*DeathCertifierQuery, error)) DeathCertifierPaginateOption {
	return func(pager *deathCertifierPager) error {
		if filter == nil {
			return errors.New("DeathCertifierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deathCertifierPager struct {
	order  *DeathCertifierOrder
	filter func(*DeathCertifierQuery) (*DeathCertifierQuery, error)
}

func newDeathCertifierPager(opts []DeathCertifierPaginateOption) (*deathCertifierPager, error) {
	pager := &deathCertifierPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeathCertifierOrder
	}
	return pager, nil
}

func (p *deathCertifierPager) applyFilter(query *DeathCertifierQuery) (*DeathCertifierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deathCertifierPager) toCursor(dc *DeathCertifier) Cursor {
	return p.order.Field.toCursor(dc)
}

func (p *deathCertifierPager) applyCursors(query *DeathCertifierQuery, after, before *Cursor) *DeathCertifierQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDeathCertifierOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *deathCertifierPager) applyOrder(query *DeathCertifierQuery, reverse bool) *DeathCertifierQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDeathCertifierOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDeathCertifierOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DeathCertifier.
func (dc *DeathCertifierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeathCertifierPaginateOption,
) (*DeathCertifierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeathCertifierPager(opts)
	if err != nil {
		return nil, err
	}

	if dc, err = pager.applyFilter(dc); err != nil {
		return nil, err
	}

	conn := &DeathCertifierConnection{Edges: []*DeathCertifierEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := dc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := dc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	dc = pager.applyCursors(dc, after, before)
	dc = pager.applyOrder(dc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		dc = dc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		dc = dc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := dc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DeathCertifier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeathCertifier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeathCertifier {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DeathCertifierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DeathCertifierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// DeathCertifierOrderFieldCreatedAt orders DeathCertifier by created_at.
	DeathCertifierOrderFieldCreatedAt = &DeathCertifierOrderField{
		field: deathcertifier.FieldCreatedAt,
		toCursor: func(dc *DeathCertifier) Cursor {
			return Cursor{
				ID:    dc.ID,
				Value: dc.CreatedAt,
			}
		},
	}
	// DeathCertifierOrderFieldUpdatedAt orders DeathCertifier by updated_at.
	DeathCertifierOrderFieldUpdatedAt = &DeathCertifierOrderField{
		field: deathcertifier.FieldUpdatedAt,
		toCursor: func(dc *DeathCertifier) Cursor {
			return Cursor{
				ID:    dc.ID,
				Value: dc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DeathCertifierOrderField) String() string {
	var str string
	switch f.field {
	case deathcertifier.FieldCreatedAt:
		str = "CREATED_AT"
	case deathcertifier.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DeathCertifierOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DeathCertifierOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DeathCertifierOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DeathCertifierOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DeathCertifierOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DeathCertifierOrderField", str)
	}
	return nil
}

// DeathCertifierOrderField defines the ordering field of DeathCertifier.
type DeathCertifierOrderField struct {
	field    string
	toCursor func(*DeathCertifier) Cursor
}

// DeathCertifierOrder defines the ordering of DeathCertifier.
type DeathCertifierOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *DeathCertifierOrderField `json:"field"`
}

// DefaultDeathCertifierOrder is the default ordering of DeathCertifier.
var DefaultDeathCertifierOrder = &DeathCertifierOrder{
	Direction: OrderDirectionAsc,
	Field: &DeathCertifierOrderField{
		field: deathcertifier.FieldID,
		toCursor: func(dc *DeathCertifier) Cursor {
			return Cursor{ID: dc.ID}
		},
	},
}

// ToEdge converts DeathCertifier into DeathCertifierEdge.
func (dc *DeathCertifier) ToEdge(order *DeathCertifierOrder) *DeathCertifierEdge {
	if order == nil {
		order = DefaultDeathCertifierOrder
	}
	return &DeathCertifierEdge{
		Node:   dc,
		Cursor: order.Field.toCursor(dc),
	}
}

// DeathMannerEdge is the edge representation of DeathManner.
type DeathMannerEdge struct {
	Node   *DeathManner `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// DeathMannerConnection is the connection containing edges to DeathManner.
type DeathMannerConnection struct {
	Edges      []*DeathMannerEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// DeathMannerPaginateOption enables pagination customization.
type DeathMannerPaginateOption func(*deathMannerPager) error

// WithDeathMannerOrder configures pagination ordering.
func WithDeathMannerOrder(order *DeathMannerOrder) DeathMannerPaginateOption {
	if order == nil {
		order = DefaultDeathMannerOrder
	}
	o := *order
	return func(pager *deathMannerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeathMannerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeathMannerFilter configures pagination filter.
func WithDeathMannerFilter(filter func(*DeathMannerQuery) (*DeathMannerQuery, error)) DeathMannerPaginateOption {
	return func(pager *deathMannerPager) error {
		if filter == nil {
			return errors.New("DeathMannerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deathMannerPager struct {
	order  *DeathMannerOrder
	filter func(*DeathMannerQuery) (*DeathMannerQuery, error)
}

func newDeathMannerPager(opts []DeathMannerPaginateOption) (*deathMannerPager, error) {
	pager := &deathMannerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeathMannerOrder
	}
	return pager, nil
}

func (p *deathMannerPager) applyFilter(query *DeathMannerQuery) (*DeathMannerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deathMannerPager) toCursor(dm *DeathManner) Cursor {
	return p.order.Field.toCursor(dm)
}

func (p *deathMannerPager) applyCursors(query *DeathMannerQuery, after, before *Cursor) *DeathMannerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDeathMannerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *deathMannerPager) applyOrder(query *DeathMannerQuery, reverse bool) *DeathMannerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDeathMannerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDeathMannerOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DeathManner.
func (dm *DeathMannerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeathMannerPaginateOption,
) (*DeathMannerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeathMannerPager(opts)
	if err != nil {
		return nil, err
	}

	if dm, err = pager.applyFilter(dm); err != nil {
		return nil, err
	}

	conn := &DeathMannerConnection{Edges: []*DeathMannerEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := dm.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := dm.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	dm = pager.applyCursors(dm, after, before)
	dm = pager.applyOrder(dm, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		dm = dm.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		dm = dm.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := dm.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DeathManner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeathManner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeathManner {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DeathMannerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DeathMannerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// DeathMannerOrderFieldCreatedAt orders DeathManner by created_at.
	DeathMannerOrderFieldCreatedAt = &DeathMannerOrderField{
		field: deathmanner.FieldCreatedAt,
		toCursor: func(dm *DeathManner) Cursor {
			return Cursor{
				ID:    dm.ID,
				Value: dm.CreatedAt,
			}
		},
	}
	// DeathMannerOrderFieldUpdatedAt orders DeathManner by updated_at.
	DeathMannerOrderFieldUpdatedAt = &DeathMannerOrderField{
		field: deathmanner.FieldUpdatedAt,
		toCursor: func(dm *DeathManner) Cursor {
			return Cursor{
				ID:    dm.ID,
				Value: dm.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DeathMannerOrderField) String() string {
	var str string
	switch f.field {
	case deathmanner.FieldCreatedAt:
		str = "CREATED_AT"
	case deathmanner.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DeathMannerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DeathMannerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DeathMannerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DeathMannerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DeathMannerOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DeathMannerOrderField", str)
	}
	return nil
}

// DeathMannerOrderField defines the ordering field of DeathManner.
type DeathMannerOrderField struct {
	field    string
	toCursor func(*DeathManner) Cursor
}

// DeathMannerOrder defines the ordering of DeathManner.
type DeathMannerOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *DeathMannerOrderField `json:"field"`
}

// DefaultDeathMannerOrder is the default ordering of DeathManner.
var DefaultDeathMannerOrder = &DeathMannerOrder{
	Direction: OrderDirectionAsc,
	Field: &DeathMannerOrderField{
		field: deathmanner.FieldID,
		toCursor: func(dm *DeathManner) Cursor {
			return Cursor{ID: dm.ID}
		},
	},
}

// ToEdge converts DeathManner into DeathMannerEdge.
func (dm *DeathManner) ToEdge(order *DeathMannerOrder) *DeathMannerEdge {
	if order == nil {
		order = DefaultDeathMannerOrder
	}
	return &DeathMannerEdge{
		Node:   dm,
		Cursor: order.Field.toCursor(dm),
	}
}

// DeathPlaceEdge is the edge representation of DeathPlace.
type DeathPlaceEdge struct {
	Node   *DeathPlace `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// DeathPlaceConnection is the connection containing edges to DeathPlace.
type DeathPlaceConnection struct {
	Edges      []*DeathPlaceEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// DeathPlacePaginateOption enables pagination customization.
type DeathPlacePaginateOption func(*deathPlacePager) error

// WithDeathPlaceOrder configures pagination ordering.
func WithDeathPlaceOrder(order *DeathPlaceOrder) DeathPlacePaginateOption {
	if order == nil {
		order = DefaultDeathPlaceOrder
	}
	o := *order
	return func(pager *deathPlacePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeathPlaceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeathPlaceFilter configures pagination filter.
func WithDeathPlaceFilter(filter func(*DeathPlaceQuery) (*DeathPlaceQuery, error)) DeathPlacePaginateOption {
	return func(pager *deathPlacePager) error {
		if filter == nil {
			return errors.New("DeathPlaceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deathPlacePager struct {
	order  *DeathPlaceOrder
	filter func(*DeathPlaceQuery) (*DeathPlaceQuery, error)
}

func newDeathPlacePager(opts []DeathPlacePaginateOption) (*deathPlacePager, error) {
	pager := &deathPlacePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeathPlaceOrder
	}
	return pager, nil
}

func (p *deathPlacePager) applyFilter(query *DeathPlaceQuery) (*DeathPlaceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deathPlacePager) toCursor(dp *DeathPlace) Cursor {
	return p.order.Field.toCursor(dp)
}

func (p *deathPlacePager) applyCursors(query *DeathPlaceQuery, after, before *Cursor) *DeathPlaceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDeathPlaceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *deathPlacePager) applyOrder(query *DeathPlaceQuery, reverse bool) *DeathPlaceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDeathPlaceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDeathPlaceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DeathPlace.
func (dp *DeathPlaceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeathPlacePaginateOption,
) (*DeathPlaceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeathPlacePager(opts)
	if err != nil {
		return nil, err
	}

	if dp, err = pager.applyFilter(dp); err != nil {
		return nil, err
	}

	conn := &DeathPlaceConnection{Edges: []*DeathPlaceEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := dp.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := dp.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	dp = pager.applyCursors(dp, after, before)
	dp = pager.applyOrder(dp, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		dp = dp.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		dp = dp.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := dp.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DeathPlace
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeathPlace {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeathPlace {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DeathPlaceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DeathPlaceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// DeathPlaceOrderFieldCreatedAt orders DeathPlace by created_at.
	DeathPlaceOrderFieldCreatedAt = &DeathPlaceOrderField{
		field: deathplace.FieldCreatedAt,
		toCursor: func(dp *DeathPlace) Cursor {
			return Cursor{
				ID:    dp.ID,
				Value: dp.CreatedAt,
			}
		},
	}
	// DeathPlaceOrderFieldUpdatedAt orders DeathPlace by updated_at.
	DeathPlaceOrderFieldUpdatedAt = &DeathPlaceOrderField{
		field: deathplace.FieldUpdatedAt,
		toCursor: func(dp *DeathPlace) Cursor {
			return Cursor{
				ID:    dp.ID,
				Value: dp.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DeathPlaceOrderField) String() string {
	var str string
	switch f.field {
	case deathplace.FieldCreatedAt:
		str = "CREATED_AT"
	case deathplace.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DeathPlaceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DeathPlaceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DeathPlaceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DeathPlaceOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DeathPlaceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DeathPlaceOrderField", str)
	}
	return nil
}

// DeathPlaceOrderField defines the ordering field of DeathPlace.
type DeathPlaceOrderField struct {
	field    string
	toCursor func(*DeathPlace) Cursor
}

// DeathPlaceOrder defines the ordering of DeathPlace.
type DeathPlaceOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *DeathPlaceOrderField `json:"field"`
}

// DefaultDeathPlaceOrder is the default ordering of DeathPlace.
var DefaultDeathPlaceOrder = &DeathPlaceOrder{
	Direction: OrderDirectionAsc,
	Field: &DeathPlaceOrderField{
		field: deathplace.FieldID,
		toCursor: func(dp *DeathPlace) Cursor {
			return Cursor{ID: dp.ID}
		},
	},
}

// ToEdge converts DeathPlace into DeathPlaceEdge.
func (dp *DeathPlace) ToEdge(order *DeathPlaceOrder) *DeathPlaceEdge {
	if order == nil {
		order = DefaultDeathPlaceOrder
	}
	return &DeathPlaceEdge{
		Node:   dp,
		Cursor: order.Field.toCursor(dp),
	}
}

// EthnicityEdge is the edge representation of Ethnicity.
type EthnicityEdge struct {
	Node   *Ethnicity `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// EthnicityConnection is the connection containing edges to Ethnicity.
type EthnicityConnection struct {
	Edges      []*EthnicityEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// EthnicityPaginateOption enables pagination customization.
type EthnicityPaginateOption func(*ethnicityPager) error

// WithEthnicityOrder configures pagination ordering.
func WithEthnicityOrder(order *EthnicityOrder) EthnicityPaginateOption {
	if order == nil {
		order = DefaultEthnicityOrder
	}
	o := *order
	return func(pager *ethnicityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEthnicityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEthnicityFilter configures pagination filter.
func WithEthnicityFilter(filter func(*EthnicityQuery) (*EthnicityQuery, error)) EthnicityPaginateOption {
	return func(pager *ethnicityPager) error {
		if filter == nil {
			return errors.New("EthnicityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ethnicityPager struct {
	order  *EthnicityOrder
	filter func(*EthnicityQuery) (*EthnicityQuery, error)
}

func newEthnicityPager(opts []EthnicityPaginateOption) (*ethnicityPager, error) {
	pager := &ethnicityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEthnicityOrder
	}
	return pager, nil
}

func (p *ethnicityPager) applyFilter(query *EthnicityQuery) (*EthnicityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ethnicityPager) toCursor(e *Ethnicity) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *ethnicityPager) applyCursors(query *EthnicityQuery, after, before *Cursor) *EthnicityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEthnicityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *ethnicityPager) applyOrder(query *EthnicityQuery, reverse bool) *EthnicityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEthnicityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEthnicityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Ethnicity.
func (e *EthnicityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EthnicityPaginateOption,
) (*EthnicityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEthnicityPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}

	conn := &EthnicityConnection{Edges: []*EthnicityEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := e.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := e.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		e = e.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := e.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Ethnicity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Ethnicity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Ethnicity {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EthnicityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EthnicityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// EthnicityOrderFieldCreatedAt orders Ethnicity by created_at.
	EthnicityOrderFieldCreatedAt = &EthnicityOrderField{
		field: ethnicity.FieldCreatedAt,
		toCursor: func(e *Ethnicity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// EthnicityOrderFieldUpdatedAt orders Ethnicity by updated_at.
	EthnicityOrderFieldUpdatedAt = &EthnicityOrderField{
		field: ethnicity.FieldUpdatedAt,
		toCursor: func(e *Ethnicity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EthnicityOrderField) String() string {
	var str string
	switch f.field {
	case ethnicity.FieldCreatedAt:
		str = "CREATED_AT"
	case ethnicity.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EthnicityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EthnicityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EthnicityOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *EthnicityOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *EthnicityOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid EthnicityOrderField", str)
	}
	return nil
}

// EthnicityOrderField defines the ordering field of Ethnicity.
type EthnicityOrderField struct {
	field    string
	toCursor func(*Ethnicity) Cursor
}

// EthnicityOrder defines the ordering of Ethnicity.
type EthnicityOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *EthnicityOrderField `json:"field"`
}

// DefaultEthnicityOrder is the default ordering of Ethnicity.
var DefaultEthnicityOrder = &EthnicityOrder{
	Direction: OrderDirectionAsc,
	Field: &EthnicityOrderField{
		field: ethnicity.FieldID,
		toCursor: func(e *Ethnicity) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Ethnicity into EthnicityEdge.
func (e *Ethnicity) ToEdge(order *EthnicityOrder) *EthnicityEdge {
	if order == nil {
		order = DefaultEthnicityOrder
	}
	return &EthnicityEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// GameServerEdge is the edge representation of GameServer.
type GameServerEdge struct {
	Node   *GameServer `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// GameServerConnection is the connection containing edges to GameServer.
type GameServerConnection struct {
	Edges      []*GameServerEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// GameServerPaginateOption enables pagination customization.
type GameServerPaginateOption func(*gameServerPager) error

// WithGameServerOrder configures pagination ordering.
func WithGameServerOrder(order *GameServerOrder) GameServerPaginateOption {
	if order == nil {
		order = DefaultGameServerOrder
	}
	o := *order
	return func(pager *gameServerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameServerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameServerFilter configures pagination filter.
func WithGameServerFilter(filter func(*GameServerQuery) (*GameServerQuery, error)) GameServerPaginateOption {
	return func(pager *gameServerPager) error {
		if filter == nil {
			return errors.New("GameServerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gameServerPager struct {
	order  *GameServerOrder
	filter func(*GameServerQuery) (*GameServerQuery, error)
}

func newGameServerPager(opts []GameServerPaginateOption) (*gameServerPager, error) {
	pager := &gameServerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameServerOrder
	}
	return pager, nil
}

func (p *gameServerPager) applyFilter(query *GameServerQuery) (*GameServerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gameServerPager) toCursor(gs *GameServer) Cursor {
	return p.order.Field.toCursor(gs)
}

func (p *gameServerPager) applyCursors(query *GameServerQuery, after, before *Cursor) *GameServerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultGameServerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *gameServerPager) applyOrder(query *GameServerQuery, reverse bool) *GameServerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultGameServerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultGameServerOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to GameServer.
func (gs *GameServerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GameServerPaginateOption,
) (*GameServerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGameServerPager(opts)
	if err != nil {
		return nil, err
	}

	if gs, err = pager.applyFilter(gs); err != nil {
		return nil, err
	}

	conn := &GameServerConnection{Edges: []*GameServerEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := gs.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := gs.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	gs = pager.applyCursors(gs, after, before)
	gs = pager.applyOrder(gs, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		gs = gs.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		gs = gs.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := gs.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *GameServer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GameServer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GameServer {
			return nodes[i]
		}
	}

	conn.Edges = make([]*GameServerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &GameServerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// GameServerOrderFieldCreatedAt orders GameServer by created_at.
	GameServerOrderFieldCreatedAt = &GameServerOrderField{
		field: gameserver.FieldCreatedAt,
		toCursor: func(gs *GameServer) Cursor {
			return Cursor{
				ID:    gs.ID,
				Value: gs.CreatedAt,
			}
		},
	}
	// GameServerOrderFieldUpdatedAt orders GameServer by updated_at.
	GameServerOrderFieldUpdatedAt = &GameServerOrderField{
		field: gameserver.FieldUpdatedAt,
		toCursor: func(gs *GameServer) Cursor {
			return Cursor{
				ID:    gs.ID,
				Value: gs.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GameServerOrderField) String() string {
	var str string
	switch f.field {
	case gameserver.FieldCreatedAt:
		str = "CREATED_AT"
	case gameserver.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GameServerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GameServerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GameServerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *GameServerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *GameServerOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GameServerOrderField", str)
	}
	return nil
}

// GameServerOrderField defines the ordering field of GameServer.
type GameServerOrderField struct {
	field    string
	toCursor func(*GameServer) Cursor
}

// GameServerOrder defines the ordering of GameServer.
type GameServerOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *GameServerOrderField `json:"field"`
}

// DefaultGameServerOrder is the default ordering of GameServer.
var DefaultGameServerOrder = &GameServerOrder{
	Direction: OrderDirectionAsc,
	Field: &GameServerOrderField{
		field: gameserver.FieldID,
		toCursor: func(gs *GameServer) Cursor {
			return Cursor{ID: gs.ID}
		},
	},
}

// ToEdge converts GameServer into GameServerEdge.
func (gs *GameServer) ToEdge(order *GameServerOrder) *GameServerEdge {
	if order == nil {
		order = DefaultGameServerOrder
	}
	return &GameServerEdge{
		Node:   gs,
		Cursor: order.Field.toCursor(gs),
	}
}

// MetadataEdge is the edge representation of Metadata.
type MetadataEdge struct {
	Node   *Metadata `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MetadataConnection is the connection containing edges to Metadata.
type MetadataConnection struct {
	Edges      []*MetadataEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// MetadataPaginateOption enables pagination customization.
type MetadataPaginateOption func(*metadataPager) error

// WithMetadataOrder configures pagination ordering.
func WithMetadataOrder(order *MetadataOrder) MetadataPaginateOption {
	if order == nil {
		order = DefaultMetadataOrder
	}
	o := *order
	return func(pager *metadataPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMetadataOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMetadataFilter configures pagination filter.
func WithMetadataFilter(filter func(*MetadataQuery) (*MetadataQuery, error)) MetadataPaginateOption {
	return func(pager *metadataPager) error {
		if filter == nil {
			return errors.New("MetadataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type metadataPager struct {
	order  *MetadataOrder
	filter func(*MetadataQuery) (*MetadataQuery, error)
}

func newMetadataPager(opts []MetadataPaginateOption) (*metadataPager, error) {
	pager := &metadataPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMetadataOrder
	}
	return pager, nil
}

func (p *metadataPager) applyFilter(query *MetadataQuery) (*MetadataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *metadataPager) toCursor(m *Metadata) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *metadataPager) applyCursors(query *MetadataQuery, after, before *Cursor) *MetadataQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMetadataOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *metadataPager) applyOrder(query *MetadataQuery, reverse bool) *MetadataQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMetadataOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMetadataOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Metadata.
func (m *MetadataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MetadataPaginateOption,
) (*MetadataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMetadataPager(opts)
	if err != nil {
		return nil, err
	}

	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}

	conn := &MetadataConnection{Edges: []*MetadataEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := m.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := m.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	m = pager.applyCursors(m, after, before)
	m = pager.applyOrder(m, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		m = m.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		m = m.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := m.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Metadata
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Metadata {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Metadata {
			return nodes[i]
		}
	}

	conn.Edges = make([]*MetadataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &MetadataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// MetadataOrderFieldCreatedAt orders Metadata by created_at.
	MetadataOrderFieldCreatedAt = &MetadataOrderField{
		field: metadata.FieldCreatedAt,
		toCursor: func(m *Metadata) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// MetadataOrderFieldUpdatedAt orders Metadata by updated_at.
	MetadataOrderFieldUpdatedAt = &MetadataOrderField{
		field: metadata.FieldUpdatedAt,
		toCursor: func(m *Metadata) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MetadataOrderField) String() string {
	var str string
	switch f.field {
	case metadata.FieldCreatedAt:
		str = "CREATED_AT"
	case metadata.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MetadataOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MetadataOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MetadataOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MetadataOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MetadataOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid MetadataOrderField", str)
	}
	return nil
}

// MetadataOrderField defines the ordering field of Metadata.
type MetadataOrderField struct {
	field    string
	toCursor func(*Metadata) Cursor
}

// MetadataOrder defines the ordering of Metadata.
type MetadataOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MetadataOrderField `json:"field"`
}

// DefaultMetadataOrder is the default ordering of Metadata.
var DefaultMetadataOrder = &MetadataOrder{
	Direction: OrderDirectionAsc,
	Field: &MetadataOrderField{
		field: metadata.FieldID,
		toCursor: func(m *Metadata) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Metadata into MetadataEdge.
func (m *Metadata) ToEdge(order *MetadataOrder) *MetadataEdge {
	if order == nil {
		order = DefaultMetadataOrder
	}
	return &MetadataEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// OAuthConnectionEdge is the edge representation of OAuthConnection.
type OAuthConnectionEdge struct {
	Node   *OAuthConnection `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// OAuthConnectionConnection is the connection containing edges to OAuthConnection.
type OAuthConnectionConnection struct {
	Edges      []*OAuthConnectionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// OAuthConnectionPaginateOption enables pagination customization.
type OAuthConnectionPaginateOption func(*oAuthConnectionPager) error

// WithOAuthConnectionOrder configures pagination ordering.
func WithOAuthConnectionOrder(order *OAuthConnectionOrder) OAuthConnectionPaginateOption {
	if order == nil {
		order = DefaultOAuthConnectionOrder
	}
	o := *order
	return func(pager *oAuthConnectionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOAuthConnectionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOAuthConnectionFilter configures pagination filter.
func WithOAuthConnectionFilter(filter func(*OAuthConnectionQuery) (*OAuthConnectionQuery, error)) OAuthConnectionPaginateOption {
	return func(pager *oAuthConnectionPager) error {
		if filter == nil {
			return errors.New("OAuthConnectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type oAuthConnectionPager struct {
	order  *OAuthConnectionOrder
	filter func(*OAuthConnectionQuery) (*OAuthConnectionQuery, error)
}

func newOAuthConnectionPager(opts []OAuthConnectionPaginateOption) (*oAuthConnectionPager, error) {
	pager := &oAuthConnectionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOAuthConnectionOrder
	}
	return pager, nil
}

func (p *oAuthConnectionPager) applyFilter(query *OAuthConnectionQuery) (*OAuthConnectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *oAuthConnectionPager) toCursor(oc *OAuthConnection) Cursor {
	return p.order.Field.toCursor(oc)
}

func (p *oAuthConnectionPager) applyCursors(query *OAuthConnectionQuery, after, before *Cursor) *OAuthConnectionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultOAuthConnectionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *oAuthConnectionPager) applyOrder(query *OAuthConnectionQuery, reverse bool) *OAuthConnectionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultOAuthConnectionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultOAuthConnectionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to OAuthConnection.
func (oc *OAuthConnectionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OAuthConnectionPaginateOption,
) (*OAuthConnectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOAuthConnectionPager(opts)
	if err != nil {
		return nil, err
	}

	if oc, err = pager.applyFilter(oc); err != nil {
		return nil, err
	}

	conn := &OAuthConnectionConnection{Edges: []*OAuthConnectionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := oc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := oc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	oc = pager.applyCursors(oc, after, before)
	oc = pager.applyOrder(oc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		oc = oc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		oc = oc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := oc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *OAuthConnection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OAuthConnection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OAuthConnection {
			return nodes[i]
		}
	}

	conn.Edges = make([]*OAuthConnectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &OAuthConnectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// OAuthConnectionOrderFieldCreatedAt orders OAuthConnection by created_at.
	OAuthConnectionOrderFieldCreatedAt = &OAuthConnectionOrderField{
		field: oauthconnection.FieldCreatedAt,
		toCursor: func(oc *OAuthConnection) Cursor {
			return Cursor{
				ID:    oc.ID,
				Value: oc.CreatedAt,
			}
		},
	}
	// OAuthConnectionOrderFieldUpdatedAt orders OAuthConnection by updated_at.
	OAuthConnectionOrderFieldUpdatedAt = &OAuthConnectionOrderField{
		field: oauthconnection.FieldUpdatedAt,
		toCursor: func(oc *OAuthConnection) Cursor {
			return Cursor{
				ID:    oc.ID,
				Value: oc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OAuthConnectionOrderField) String() string {
	var str string
	switch f.field {
	case oauthconnection.FieldCreatedAt:
		str = "CREATED_AT"
	case oauthconnection.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OAuthConnectionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OAuthConnectionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OAuthConnectionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *OAuthConnectionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *OAuthConnectionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OAuthConnectionOrderField", str)
	}
	return nil
}

// OAuthConnectionOrderField defines the ordering field of OAuthConnection.
type OAuthConnectionOrderField struct {
	field    string
	toCursor func(*OAuthConnection) Cursor
}

// OAuthConnectionOrder defines the ordering of OAuthConnection.
type OAuthConnectionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *OAuthConnectionOrderField `json:"field"`
}

// DefaultOAuthConnectionOrder is the default ordering of OAuthConnection.
var DefaultOAuthConnectionOrder = &OAuthConnectionOrder{
	Direction: OrderDirectionAsc,
	Field: &OAuthConnectionOrderField{
		field: oauthconnection.FieldID,
		toCursor: func(oc *OAuthConnection) Cursor {
			return Cursor{ID: oc.ID}
		},
	},
}

// ToEdge converts OAuthConnection into OAuthConnectionEdge.
func (oc *OAuthConnection) ToEdge(order *OAuthConnectionOrder) *OAuthConnectionEdge {
	if order == nil {
		order = DefaultOAuthConnectionOrder
	}
	return &OAuthConnectionEdge{
		Node:   oc,
		Cursor: order.Field.toCursor(oc),
	}
}

// PersonEdge is the edge representation of Person.
type PersonEdge struct {
	Node   *Person `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PersonConnection is the connection containing edges to Person.
type PersonConnection struct {
	Edges      []*PersonEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// PersonPaginateOption enables pagination customization.
type PersonPaginateOption func(*personPager) error

// WithPersonOrder configures pagination ordering.
func WithPersonOrder(order *PersonOrder) PersonPaginateOption {
	if order == nil {
		order = DefaultPersonOrder
	}
	o := *order
	return func(pager *personPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPersonOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPersonFilter configures pagination filter.
func WithPersonFilter(filter func(*PersonQuery) (*PersonQuery, error)) PersonPaginateOption {
	return func(pager *personPager) error {
		if filter == nil {
			return errors.New("PersonQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personPager struct {
	order  *PersonOrder
	filter func(*PersonQuery) (*PersonQuery, error)
}

func newPersonPager(opts []PersonPaginateOption) (*personPager, error) {
	pager := &personPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPersonOrder
	}
	return pager, nil
}

func (p *personPager) applyFilter(query *PersonQuery) (*PersonQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personPager) toCursor(pe *Person) Cursor {
	return p.order.Field.toCursor(pe)
}

func (p *personPager) applyCursors(query *PersonQuery, after, before *Cursor) *PersonQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPersonOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *personPager) applyOrder(query *PersonQuery, reverse bool) *PersonQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPersonOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPersonOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Person.
func (pe *PersonQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PersonPaginateOption,
) (*PersonConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonPager(opts)
	if err != nil {
		return nil, err
	}

	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}

	conn := &PersonConnection{Edges: []*PersonEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pe.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pe.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pe = pager.applyCursors(pe, after, before)
	pe = pager.applyOrder(pe, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pe = pe.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pe = pe.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pe.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Person
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Person {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Person {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PersonEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PersonEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// PersonOrderFieldCreatedAt orders Person by created_at.
	PersonOrderFieldCreatedAt = &PersonOrderField{
		field: person.FieldCreatedAt,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.CreatedAt,
			}
		},
	}
	// PersonOrderFieldUpdatedAt orders Person by updated_at.
	PersonOrderFieldUpdatedAt = &PersonOrderField{
		field: person.FieldUpdatedAt,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.UpdatedAt,
			}
		},
	}
	// PersonOrderFieldFirstName orders Person by first_name.
	PersonOrderFieldFirstName = &PersonOrderField{
		field: person.FieldFirstName,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.FirstName,
			}
		},
	}
	// PersonOrderFieldLastName orders Person by last_name.
	PersonOrderFieldLastName = &PersonOrderField{
		field: person.FieldLastName,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.LastName,
			}
		},
	}
	// PersonOrderFieldDateOfBirth orders Person by date_of_birth.
	PersonOrderFieldDateOfBirth = &PersonOrderField{
		field: person.FieldDateOfBirth,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.DateOfBirth,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonOrderField) String() string {
	var str string
	switch f.field {
	case person.FieldCreatedAt:
		str = "CREATED_AT"
	case person.FieldUpdatedAt:
		str = "UPDATED_AT"
	case person.FieldFirstName:
		str = "FIRST_NAME"
	case person.FieldLastName:
		str = "LAST_NAME"
	case person.FieldDateOfBirth:
		str = "DATE_OF_BIRTH"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PersonOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PersonOrderFieldUpdatedAt
	case "FIRST_NAME":
		*f = *PersonOrderFieldFirstName
	case "LAST_NAME":
		*f = *PersonOrderFieldLastName
	case "DATE_OF_BIRTH":
		*f = *PersonOrderFieldDateOfBirth
	default:
		return fmt.Errorf("%s is not a valid PersonOrderField", str)
	}
	return nil
}

// PersonOrderField defines the ordering field of Person.
type PersonOrderField struct {
	field    string
	toCursor func(*Person) Cursor
}

// PersonOrder defines the ordering of Person.
type PersonOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PersonOrderField `json:"field"`
}

// DefaultPersonOrder is the default ordering of Person.
var DefaultPersonOrder = &PersonOrder{
	Direction: OrderDirectionAsc,
	Field: &PersonOrderField{
		field: person.FieldID,
		toCursor: func(pe *Person) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Person into PersonEdge.
func (pe *Person) ToEdge(order *PersonOrder) *PersonEdge {
	if order == nil {
		order = DefaultPersonOrder
	}
	return &PersonEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// PlayerEdge is the edge representation of Player.
type PlayerEdge struct {
	Node   *Player `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PlayerConnection is the connection containing edges to Player.
type PlayerConnection struct {
	Edges      []*PlayerEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// PlayerPaginateOption enables pagination customization.
type PlayerPaginateOption func(*playerPager) error

// WithPlayerOrder configures pagination ordering.
func WithPlayerOrder(order *PlayerOrder) PlayerPaginateOption {
	if order == nil {
		order = DefaultPlayerOrder
	}
	o := *order
	return func(pager *playerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlayerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlayerFilter configures pagination filter.
func WithPlayerFilter(filter func(*PlayerQuery) (*PlayerQuery, error)) PlayerPaginateOption {
	return func(pager *playerPager) error {
		if filter == nil {
			return errors.New("PlayerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type playerPager struct {
	order  *PlayerOrder
	filter func(*PlayerQuery) (*PlayerQuery, error)
}

func newPlayerPager(opts []PlayerPaginateOption) (*playerPager, error) {
	pager := &playerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlayerOrder
	}
	return pager, nil
}

func (p *playerPager) applyFilter(query *PlayerQuery) (*PlayerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *playerPager) toCursor(pl *Player) Cursor {
	return p.order.Field.toCursor(pl)
}

func (p *playerPager) applyCursors(query *PlayerQuery, after, before *Cursor) *PlayerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlayerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *playerPager) applyOrder(query *PlayerQuery, reverse bool) *PlayerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlayerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlayerOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Player.
func (pl *PlayerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlayerPaginateOption,
) (*PlayerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlayerPager(opts)
	if err != nil {
		return nil, err
	}

	if pl, err = pager.applyFilter(pl); err != nil {
		return nil, err
	}

	conn := &PlayerConnection{Edges: []*PlayerEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pl = pager.applyCursors(pl, after, before)
	pl = pager.applyOrder(pl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pl = pl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pl = pl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Player
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Player {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Player {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PlayerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PlayerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// PlayerOrderFieldCreatedAt orders Player by created_at.
	PlayerOrderFieldCreatedAt = &PlayerOrderField{
		field: player.FieldCreatedAt,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.CreatedAt,
			}
		},
	}
	// PlayerOrderFieldUpdatedAt orders Player by updated_at.
	PlayerOrderFieldUpdatedAt = &PlayerOrderField{
		field: player.FieldUpdatedAt,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PlayerOrderField) String() string {
	var str string
	switch f.field {
	case player.FieldCreatedAt:
		str = "CREATED_AT"
	case player.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PlayerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PlayerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PlayerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PlayerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PlayerOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PlayerOrderField", str)
	}
	return nil
}

// PlayerOrderField defines the ordering field of Player.
type PlayerOrderField struct {
	field    string
	toCursor func(*Player) Cursor
}

// PlayerOrder defines the ordering of Player.
type PlayerOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PlayerOrderField `json:"field"`
}

// DefaultPlayerOrder is the default ordering of Player.
var DefaultPlayerOrder = &PlayerOrder{
	Direction: OrderDirectionAsc,
	Field: &PlayerOrderField{
		field: player.FieldID,
		toCursor: func(pl *Player) Cursor {
			return Cursor{ID: pl.ID}
		},
	},
}

// ToEdge converts Player into PlayerEdge.
func (pl *Player) ToEdge(order *PlayerOrder) *PlayerEdge {
	if order == nil {
		order = DefaultPlayerOrder
	}
	return &PlayerEdge{
		Node:   pl,
		Cursor: order.Field.toCursor(pl),
	}
}

// PlayerIdentifierEdge is the edge representation of PlayerIdentifier.
type PlayerIdentifierEdge struct {
	Node   *PlayerIdentifier `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// PlayerIdentifierConnection is the connection containing edges to PlayerIdentifier.
type PlayerIdentifierConnection struct {
	Edges      []*PlayerIdentifierEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// PlayerIdentifierPaginateOption enables pagination customization.
type PlayerIdentifierPaginateOption func(*playerIdentifierPager) error

// WithPlayerIdentifierOrder configures pagination ordering.
func WithPlayerIdentifierOrder(order *PlayerIdentifierOrder) PlayerIdentifierPaginateOption {
	if order == nil {
		order = DefaultPlayerIdentifierOrder
	}
	o := *order
	return func(pager *playerIdentifierPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlayerIdentifierOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlayerIdentifierFilter configures pagination filter.
func WithPlayerIdentifierFilter(filter func(*PlayerIdentifierQuery) (*PlayerIdentifierQuery, error)) PlayerIdentifierPaginateOption {
	return func(pager *playerIdentifierPager) error {
		if filter == nil {
			return errors.New("PlayerIdentifierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type playerIdentifierPager struct {
	order  *PlayerIdentifierOrder
	filter func(*PlayerIdentifierQuery) (*PlayerIdentifierQuery, error)
}

func newPlayerIdentifierPager(opts []PlayerIdentifierPaginateOption) (*playerIdentifierPager, error) {
	pager := &playerIdentifierPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlayerIdentifierOrder
	}
	return pager, nil
}

func (p *playerIdentifierPager) applyFilter(query *PlayerIdentifierQuery) (*PlayerIdentifierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *playerIdentifierPager) toCursor(pi *PlayerIdentifier) Cursor {
	return p.order.Field.toCursor(pi)
}

func (p *playerIdentifierPager) applyCursors(query *PlayerIdentifierQuery, after, before *Cursor) *PlayerIdentifierQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlayerIdentifierOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *playerIdentifierPager) applyOrder(query *PlayerIdentifierQuery, reverse bool) *PlayerIdentifierQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlayerIdentifierOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlayerIdentifierOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to PlayerIdentifier.
func (pi *PlayerIdentifierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlayerIdentifierPaginateOption,
) (*PlayerIdentifierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlayerIdentifierPager(opts)
	if err != nil {
		return nil, err
	}

	if pi, err = pager.applyFilter(pi); err != nil {
		return nil, err
	}

	conn := &PlayerIdentifierConnection{Edges: []*PlayerIdentifierEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pi.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pi.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pi = pager.applyCursors(pi, after, before)
	pi = pager.applyOrder(pi, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pi = pi.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pi = pi.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pi.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *PlayerIdentifier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlayerIdentifier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlayerIdentifier {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PlayerIdentifierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PlayerIdentifierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// PlayerIdentifierOrderFieldCreatedAt orders PlayerIdentifier by created_at.
	PlayerIdentifierOrderFieldCreatedAt = &PlayerIdentifierOrderField{
		field: playeridentifier.FieldCreatedAt,
		toCursor: func(pi *PlayerIdentifier) Cursor {
			return Cursor{
				ID:    pi.ID,
				Value: pi.CreatedAt,
			}
		},
	}
	// PlayerIdentifierOrderFieldUpdatedAt orders PlayerIdentifier by updated_at.
	PlayerIdentifierOrderFieldUpdatedAt = &PlayerIdentifierOrderField{
		field: playeridentifier.FieldUpdatedAt,
		toCursor: func(pi *PlayerIdentifier) Cursor {
			return Cursor{
				ID:    pi.ID,
				Value: pi.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PlayerIdentifierOrderField) String() string {
	var str string
	switch f.field {
	case playeridentifier.FieldCreatedAt:
		str = "CREATED_AT"
	case playeridentifier.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PlayerIdentifierOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PlayerIdentifierOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PlayerIdentifierOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PlayerIdentifierOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PlayerIdentifierOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PlayerIdentifierOrderField", str)
	}
	return nil
}

// PlayerIdentifierOrderField defines the ordering field of PlayerIdentifier.
type PlayerIdentifierOrderField struct {
	field    string
	toCursor func(*PlayerIdentifier) Cursor
}

// PlayerIdentifierOrder defines the ordering of PlayerIdentifier.
type PlayerIdentifierOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *PlayerIdentifierOrderField `json:"field"`
}

// DefaultPlayerIdentifierOrder is the default ordering of PlayerIdentifier.
var DefaultPlayerIdentifierOrder = &PlayerIdentifierOrder{
	Direction: OrderDirectionAsc,
	Field: &PlayerIdentifierOrderField{
		field: playeridentifier.FieldID,
		toCursor: func(pi *PlayerIdentifier) Cursor {
			return Cursor{ID: pi.ID}
		},
	},
}

// ToEdge converts PlayerIdentifier into PlayerIdentifierEdge.
func (pi *PlayerIdentifier) ToEdge(order *PlayerIdentifierOrder) *PlayerIdentifierEdge {
	if order == nil {
		order = DefaultPlayerIdentifierOrder
	}
	return &PlayerIdentifierEdge{
		Node:   pi,
		Cursor: order.Field.toCursor(pi),
	}
}

// RaceEdge is the edge representation of Race.
type RaceEdge struct {
	Node   *Race  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RaceConnection is the connection containing edges to Race.
type RaceConnection struct {
	Edges      []*RaceEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// RacePaginateOption enables pagination customization.
type RacePaginateOption func(*racePager) error

// WithRaceOrder configures pagination ordering.
func WithRaceOrder(order *RaceOrder) RacePaginateOption {
	if order == nil {
		order = DefaultRaceOrder
	}
	o := *order
	return func(pager *racePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRaceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRaceFilter configures pagination filter.
func WithRaceFilter(filter func(*RaceQuery) (*RaceQuery, error)) RacePaginateOption {
	return func(pager *racePager) error {
		if filter == nil {
			return errors.New("RaceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type racePager struct {
	order  *RaceOrder
	filter func(*RaceQuery) (*RaceQuery, error)
}

func newRacePager(opts []RacePaginateOption) (*racePager, error) {
	pager := &racePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRaceOrder
	}
	return pager, nil
}

func (p *racePager) applyFilter(query *RaceQuery) (*RaceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *racePager) toCursor(r *Race) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *racePager) applyCursors(query *RaceQuery, after, before *Cursor) *RaceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRaceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *racePager) applyOrder(query *RaceQuery, reverse bool) *RaceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRaceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRaceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Race.
func (r *RaceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RacePaginateOption,
) (*RaceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRacePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RaceConnection{Edges: []*RaceEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Race
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Race {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Race {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RaceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RaceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RaceOrderFieldCreatedAt orders Race by created_at.
	RaceOrderFieldCreatedAt = &RaceOrderField{
		field: race.FieldCreatedAt,
		toCursor: func(r *Race) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
	// RaceOrderFieldUpdatedAt orders Race by updated_at.
	RaceOrderFieldUpdatedAt = &RaceOrderField{
		field: race.FieldUpdatedAt,
		toCursor: func(r *Race) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RaceOrderField) String() string {
	var str string
	switch f.field {
	case race.FieldCreatedAt:
		str = "CREATED_AT"
	case race.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RaceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RaceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RaceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *RaceOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *RaceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid RaceOrderField", str)
	}
	return nil
}

// RaceOrderField defines the ordering field of Race.
type RaceOrderField struct {
	field    string
	toCursor func(*Race) Cursor
}

// RaceOrder defines the ordering of Race.
type RaceOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RaceOrderField `json:"field"`
}

// DefaultRaceOrder is the default ordering of Race.
var DefaultRaceOrder = &RaceOrder{
	Direction: OrderDirectionAsc,
	Field: &RaceOrderField{
		field: race.FieldID,
		toCursor: func(r *Race) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Race into RaceEdge.
func (r *Race) ToEdge(order *RaceOrder) *RaceEdge {
	if order == nil {
		order = DefaultRaceOrder
	}
	return &RaceEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SessionEdge is the edge representation of Session.
type SessionEdge struct {
	Node   *Session `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// SessionConnection is the connection containing edges to Session.
type SessionConnection struct {
	Edges      []*SessionEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// SessionPaginateOption enables pagination customization.
type SessionPaginateOption func(*sessionPager) error

// WithSessionOrder configures pagination ordering.
func WithSessionOrder(order *SessionOrder) SessionPaginateOption {
	if order == nil {
		order = DefaultSessionOrder
	}
	o := *order
	return func(pager *sessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSessionFilter configures pagination filter.
func WithSessionFilter(filter func(*SessionQuery) (*SessionQuery, error)) SessionPaginateOption {
	return func(pager *sessionPager) error {
		if filter == nil {
			return errors.New("SessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sessionPager struct {
	order  *SessionOrder
	filter func(*SessionQuery) (*SessionQuery, error)
}

func newSessionPager(opts []SessionPaginateOption) (*sessionPager, error) {
	pager := &sessionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSessionOrder
	}
	return pager, nil
}

func (p *sessionPager) applyFilter(query *SessionQuery) (*SessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sessionPager) toCursor(s *Session) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *sessionPager) applyCursors(query *SessionQuery, after, before *Cursor) *SessionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSessionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *sessionPager) applyOrder(query *SessionQuery, reverse bool) *SessionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSessionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSessionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Session.
func (s *SessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SessionPaginateOption,
) (*SessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSessionPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &SessionConnection{Edges: []*SessionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Session
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Session {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Session {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// SessionOrderFieldCreatedAt orders Session by created_at.
	SessionOrderFieldCreatedAt = &SessionOrderField{
		field: session.FieldCreatedAt,
		toCursor: func(s *Session) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SessionOrderFieldUpdatedAt orders Session by updated_at.
	SessionOrderFieldUpdatedAt = &SessionOrderField{
		field: session.FieldUpdatedAt,
		toCursor: func(s *Session) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SessionOrderFieldStartedAt orders Session by started_at.
	SessionOrderFieldStartedAt = &SessionOrderField{
		field: session.FieldStartedAt,
		toCursor: func(s *Session) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.StartedAt,
			}
		},
	}
	// SessionOrderFieldEndedAt orders Session by ended_at.
	SessionOrderFieldEndedAt = &SessionOrderField{
		field: session.FieldEndedAt,
		toCursor: func(s *Session) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.EndedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SessionOrderField) String() string {
	var str string
	switch f.field {
	case session.FieldCreatedAt:
		str = "CREATED_AT"
	case session.FieldUpdatedAt:
		str = "UPDATED_AT"
	case session.FieldStartedAt:
		str = "STARTED_AT"
	case session.FieldEndedAt:
		str = "ENDED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SessionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SessionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SessionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SessionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SessionOrderFieldUpdatedAt
	case "STARTED_AT":
		*f = *SessionOrderFieldStartedAt
	case "ENDED_AT":
		*f = *SessionOrderFieldEndedAt
	default:
		return fmt.Errorf("%s is not a valid SessionOrderField", str)
	}
	return nil
}

// SessionOrderField defines the ordering field of Session.
type SessionOrderField struct {
	field    string
	toCursor func(*Session) Cursor
}

// SessionOrder defines the ordering of Session.
type SessionOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *SessionOrderField `json:"field"`
}

// DefaultSessionOrder is the default ordering of Session.
var DefaultSessionOrder = &SessionOrder{
	Direction: OrderDirectionAsc,
	Field: &SessionOrderField{
		field: session.FieldID,
		toCursor: func(s *Session) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Session into SessionEdge.
func (s *Session) ToEdge(order *SessionOrder) *SessionEdge {
	if order == nil {
		order = DefaultSessionOrder
	}
	return &SessionEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SettingEdge is the edge representation of Setting.
type SettingEdge struct {
	Node   *Setting `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// SettingConnection is the connection containing edges to Setting.
type SettingConnection struct {
	Edges      []*SettingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// SettingPaginateOption enables pagination customization.
type SettingPaginateOption func(*settingPager) error

// WithSettingOrder configures pagination ordering.
func WithSettingOrder(order *SettingOrder) SettingPaginateOption {
	if order == nil {
		order = DefaultSettingOrder
	}
	o := *order
	return func(pager *settingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSettingFilter configures pagination filter.
func WithSettingFilter(filter func(*SettingQuery) (*SettingQuery, error)) SettingPaginateOption {
	return func(pager *settingPager) error {
		if filter == nil {
			return errors.New("SettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type settingPager struct {
	order  *SettingOrder
	filter func(*SettingQuery) (*SettingQuery, error)
}

func newSettingPager(opts []SettingPaginateOption) (*settingPager, error) {
	pager := &settingPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSettingOrder
	}
	return pager, nil
}

func (p *settingPager) applyFilter(query *SettingQuery) (*SettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *settingPager) toCursor(s *Setting) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *settingPager) applyCursors(query *SettingQuery, after, before *Cursor) *SettingQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSettingOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *settingPager) applyOrder(query *SettingQuery, reverse bool) *SettingQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSettingOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSettingOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Setting.
func (s *SettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SettingPaginateOption,
) (*SettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSettingPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &SettingConnection{Edges: []*SettingEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Setting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Setting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Setting {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// SettingOrderFieldCreatedAt orders Setting by created_at.
	SettingOrderFieldCreatedAt = &SettingOrderField{
		field: setting.FieldCreatedAt,
		toCursor: func(s *Setting) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SettingOrderFieldUpdatedAt orders Setting by updated_at.
	SettingOrderFieldUpdatedAt = &SettingOrderField{
		field: setting.FieldUpdatedAt,
		toCursor: func(s *Setting) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SettingOrderField) String() string {
	var str string
	switch f.field {
	case setting.FieldCreatedAt:
		str = "CREATED_AT"
	case setting.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SettingOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SettingOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid SettingOrderField", str)
	}
	return nil
}

// SettingOrderField defines the ordering field of Setting.
type SettingOrderField struct {
	field    string
	toCursor func(*Setting) Cursor
}

// SettingOrder defines the ordering of Setting.
type SettingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *SettingOrderField `json:"field"`
}

// DefaultSettingOrder is the default ordering of Setting.
var DefaultSettingOrder = &SettingOrder{
	Direction: OrderDirectionAsc,
	Field: &SettingOrderField{
		field: setting.FieldID,
		toCursor: func(s *Setting) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Setting into SettingEdge.
func (s *Setting) ToEdge(order *SettingOrder) *SettingEdge {
	if order == nil {
		order = DefaultSettingOrder
	}
	return &SettingEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SexEdge is the edge representation of Sex.
type SexEdge struct {
	Node   *Sex   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// SexConnection is the connection containing edges to Sex.
type SexConnection struct {
	Edges      []*SexEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// SexPaginateOption enables pagination customization.
type SexPaginateOption func(*sexPager) error

// WithSexOrder configures pagination ordering.
func WithSexOrder(order *SexOrder) SexPaginateOption {
	if order == nil {
		order = DefaultSexOrder
	}
	o := *order
	return func(pager *sexPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSexOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSexFilter configures pagination filter.
func WithSexFilter(filter func(*SexQuery) (*SexQuery, error)) SexPaginateOption {
	return func(pager *sexPager) error {
		if filter == nil {
			return errors.New("SexQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sexPager struct {
	order  *SexOrder
	filter func(*SexQuery) (*SexQuery, error)
}

func newSexPager(opts []SexPaginateOption) (*sexPager, error) {
	pager := &sexPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSexOrder
	}
	return pager, nil
}

func (p *sexPager) applyFilter(query *SexQuery) (*SexQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sexPager) toCursor(s *Sex) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *sexPager) applyCursors(query *SexQuery, after, before *Cursor) *SexQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSexOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *sexPager) applyOrder(query *SexQuery, reverse bool) *SexQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSexOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSexOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Sex.
func (s *SexQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SexPaginateOption,
) (*SexConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSexPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &SexConnection{Edges: []*SexEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Sex
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Sex {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Sex {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SexEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SexEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// SexOrderFieldCreatedAt orders Sex by created_at.
	SexOrderFieldCreatedAt = &SexOrderField{
		field: sex.FieldCreatedAt,
		toCursor: func(s *Sex) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SexOrderFieldUpdatedAt orders Sex by updated_at.
	SexOrderFieldUpdatedAt = &SexOrderField{
		field: sex.FieldUpdatedAt,
		toCursor: func(s *Sex) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SexOrderField) String() string {
	var str string
	switch f.field {
	case sex.FieldCreatedAt:
		str = "CREATED_AT"
	case sex.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SexOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SexOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SexOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SexOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SexOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid SexOrderField", str)
	}
	return nil
}

// SexOrderField defines the ordering field of Sex.
type SexOrderField struct {
	field    string
	toCursor func(*Sex) Cursor
}

// SexOrder defines the ordering of Sex.
type SexOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *SexOrderField `json:"field"`
}

// DefaultSexOrder is the default ordering of Sex.
var DefaultSexOrder = &SexOrder{
	Direction: OrderDirectionAsc,
	Field: &SexOrderField{
		field: sex.FieldID,
		toCursor: func(s *Sex) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Sex into SexEdge.
func (s *Sex) ToEdge(order *SexOrder) *SexEdge {
	if order == nil {
		order = DefaultSexOrder
	}
	return &SexEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// StateEdge is the edge representation of State.
type StateEdge struct {
	Node   *State `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// StateConnection is the connection containing edges to State.
type StateConnection struct {
	Edges      []*StateEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// StatePaginateOption enables pagination customization.
type StatePaginateOption func(*statePager) error

// WithStateOrder configures pagination ordering.
func WithStateOrder(order *StateOrder) StatePaginateOption {
	if order == nil {
		order = DefaultStateOrder
	}
	o := *order
	return func(pager *statePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStateFilter configures pagination filter.
func WithStateFilter(filter func(*StateQuery) (*StateQuery, error)) StatePaginateOption {
	return func(pager *statePager) error {
		if filter == nil {
			return errors.New("StateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statePager struct {
	order  *StateOrder
	filter func(*StateQuery) (*StateQuery, error)
}

func newStatePager(opts []StatePaginateOption) (*statePager, error) {
	pager := &statePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStateOrder
	}
	return pager, nil
}

func (p *statePager) applyFilter(query *StateQuery) (*StateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statePager) toCursor(s *State) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *statePager) applyCursors(query *StateQuery, after, before *Cursor) *StateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultStateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *statePager) applyOrder(query *StateQuery, reverse bool) *StateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultStateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultStateOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to State.
func (s *StateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatePaginateOption,
) (*StateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatePager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &StateConnection{Edges: []*StateEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *State
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *State {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *State {
			return nodes[i]
		}
	}

	conn.Edges = make([]*StateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &StateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// StateOrderFieldCreatedAt orders State by created_at.
	StateOrderFieldCreatedAt = &StateOrderField{
		field: state.FieldCreatedAt,
		toCursor: func(s *State) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// StateOrderFieldUpdatedAt orders State by updated_at.
	StateOrderFieldUpdatedAt = &StateOrderField{
		field: state.FieldUpdatedAt,
		toCursor: func(s *State) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StateOrderField) String() string {
	var str string
	switch f.field {
	case state.FieldCreatedAt:
		str = "CREATED_AT"
	case state.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StateOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *StateOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *StateOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid StateOrderField", str)
	}
	return nil
}

// StateOrderField defines the ordering field of State.
type StateOrderField struct {
	field    string
	toCursor func(*State) Cursor
}

// StateOrder defines the ordering of State.
type StateOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *StateOrderField `json:"field"`
}

// DefaultStateOrder is the default ordering of State.
var DefaultStateOrder = &StateOrder{
	Direction: OrderDirectionAsc,
	Field: &StateOrderField{
		field: state.FieldID,
		toCursor: func(s *State) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts State into StateEdge.
func (s *State) ToEdge(order *StateOrder) *StateEdge {
	if order == nil {
		order = DefaultStateOrder
	}
	return &StateEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}

	conn := &UserConnection{Edges: []*UserEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := u.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := u.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		u = u.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		u = u.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := u.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		field: user.FieldCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		field: user.FieldUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.field {
	case user.FieldCreatedAt:
		str = "CREATED_AT"
	case user.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UserOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UserOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// VehicleEdge is the edge representation of Vehicle.
type VehicleEdge struct {
	Node   *Vehicle `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// VehicleConnection is the connection containing edges to Vehicle.
type VehicleConnection struct {
	Edges      []*VehicleEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// VehiclePaginateOption enables pagination customization.
type VehiclePaginateOption func(*vehiclePager) error

// WithVehicleOrder configures pagination ordering.
func WithVehicleOrder(order *VehicleOrder) VehiclePaginateOption {
	if order == nil {
		order = DefaultVehicleOrder
	}
	o := *order
	return func(pager *vehiclePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVehicleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVehicleFilter configures pagination filter.
func WithVehicleFilter(filter func(*VehicleQuery) (*VehicleQuery, error)) VehiclePaginateOption {
	return func(pager *vehiclePager) error {
		if filter == nil {
			return errors.New("VehicleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vehiclePager struct {
	order  *VehicleOrder
	filter func(*VehicleQuery) (*VehicleQuery, error)
}

func newVehiclePager(opts []VehiclePaginateOption) (*vehiclePager, error) {
	pager := &vehiclePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVehicleOrder
	}
	return pager, nil
}

func (p *vehiclePager) applyFilter(query *VehicleQuery) (*VehicleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vehiclePager) toCursor(v *Vehicle) Cursor {
	return p.order.Field.toCursor(v)
}

func (p *vehiclePager) applyCursors(query *VehicleQuery, after, before *Cursor) *VehicleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVehicleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vehiclePager) applyOrder(query *VehicleQuery, reverse bool) *VehicleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVehicleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVehicleOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Vehicle.
func (v *VehicleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VehiclePaginateOption,
) (*VehicleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVehiclePager(opts)
	if err != nil {
		return nil, err
	}

	if v, err = pager.applyFilter(v); err != nil {
		return nil, err
	}

	conn := &VehicleConnection{Edges: []*VehicleEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := v.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := v.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	v = pager.applyCursors(v, after, before)
	v = pager.applyOrder(v, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		v = v.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		v = v.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := v.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Vehicle
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vehicle {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vehicle {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VehicleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VehicleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VehicleOrderFieldCreatedAt orders Vehicle by created_at.
	VehicleOrderFieldCreatedAt = &VehicleOrderField{
		field: vehicle.FieldCreatedAt,
		toCursor: func(v *Vehicle) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.CreatedAt,
			}
		},
	}
	// VehicleOrderFieldUpdatedAt orders Vehicle by updated_at.
	VehicleOrderFieldUpdatedAt = &VehicleOrderField{
		field: vehicle.FieldUpdatedAt,
		toCursor: func(v *Vehicle) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VehicleOrderField) String() string {
	var str string
	switch f.field {
	case vehicle.FieldCreatedAt:
		str = "CREATED_AT"
	case vehicle.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VehicleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VehicleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VehicleOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *VehicleOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *VehicleOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid VehicleOrderField", str)
	}
	return nil
}

// VehicleOrderField defines the ordering field of Vehicle.
type VehicleOrderField struct {
	field    string
	toCursor func(*Vehicle) Cursor
}

// VehicleOrder defines the ordering of Vehicle.
type VehicleOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *VehicleOrderField `json:"field"`
}

// DefaultVehicleOrder is the default ordering of Vehicle.
var DefaultVehicleOrder = &VehicleOrder{
	Direction: OrderDirectionAsc,
	Field: &VehicleOrderField{
		field: vehicle.FieldID,
		toCursor: func(v *Vehicle) Cursor {
			return Cursor{ID: v.ID}
		},
	},
}

// ToEdge converts Vehicle into VehicleEdge.
func (v *Vehicle) ToEdge(order *VehicleOrder) *VehicleEdge {
	if order == nil {
		order = DefaultVehicleOrder
	}
	return &VehicleEdge{
		Node:   v,
		Cursor: order.Field.toCursor(v),
	}
}

// VehicleClassEdge is the edge representation of VehicleClass.
type VehicleClassEdge struct {
	Node   *VehicleClass `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// VehicleClassConnection is the connection containing edges to VehicleClass.
type VehicleClassConnection struct {
	Edges      []*VehicleClassEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// VehicleClassPaginateOption enables pagination customization.
type VehicleClassPaginateOption func(*vehicleClassPager) error

// WithVehicleClassOrder configures pagination ordering.
func WithVehicleClassOrder(order *VehicleClassOrder) VehicleClassPaginateOption {
	if order == nil {
		order = DefaultVehicleClassOrder
	}
	o := *order
	return func(pager *vehicleClassPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVehicleClassOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVehicleClassFilter configures pagination filter.
func WithVehicleClassFilter(filter func(*VehicleClassQuery) (*VehicleClassQuery, error)) VehicleClassPaginateOption {
	return func(pager *vehicleClassPager) error {
		if filter == nil {
			return errors.New("VehicleClassQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vehicleClassPager struct {
	order  *VehicleClassOrder
	filter func(*VehicleClassQuery) (*VehicleClassQuery, error)
}

func newVehicleClassPager(opts []VehicleClassPaginateOption) (*vehicleClassPager, error) {
	pager := &vehicleClassPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVehicleClassOrder
	}
	return pager, nil
}

func (p *vehicleClassPager) applyFilter(query *VehicleClassQuery) (*VehicleClassQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vehicleClassPager) toCursor(vc *VehicleClass) Cursor {
	return p.order.Field.toCursor(vc)
}

func (p *vehicleClassPager) applyCursors(query *VehicleClassQuery, after, before *Cursor) *VehicleClassQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVehicleClassOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vehicleClassPager) applyOrder(query *VehicleClassQuery, reverse bool) *VehicleClassQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVehicleClassOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVehicleClassOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VehicleClass.
func (vc *VehicleClassQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VehicleClassPaginateOption,
) (*VehicleClassConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVehicleClassPager(opts)
	if err != nil {
		return nil, err
	}

	if vc, err = pager.applyFilter(vc); err != nil {
		return nil, err
	}

	conn := &VehicleClassConnection{Edges: []*VehicleClassEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vc = pager.applyCursors(vc, after, before)
	vc = pager.applyOrder(vc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vc = vc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vc = vc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VehicleClass
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VehicleClass {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VehicleClass {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VehicleClassEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VehicleClassEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VehicleClassOrderFieldCreatedAt orders VehicleClass by created_at.
	VehicleClassOrderFieldCreatedAt = &VehicleClassOrderField{
		field: vehicleclass.FieldCreatedAt,
		toCursor: func(vc *VehicleClass) Cursor {
			return Cursor{
				ID:    vc.ID,
				Value: vc.CreatedAt,
			}
		},
	}
	// VehicleClassOrderFieldUpdatedAt orders VehicleClass by updated_at.
	VehicleClassOrderFieldUpdatedAt = &VehicleClassOrderField{
		field: vehicleclass.FieldUpdatedAt,
		toCursor: func(vc *VehicleClass) Cursor {
			return Cursor{
				ID:    vc.ID,
				Value: vc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VehicleClassOrderField) String() string {
	var str string
	switch f.field {
	case vehicleclass.FieldCreatedAt:
		str = "CREATED_AT"
	case vehicleclass.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VehicleClassOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VehicleClassOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VehicleClassOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *VehicleClassOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *VehicleClassOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid VehicleClassOrderField", str)
	}
	return nil
}

// VehicleClassOrderField defines the ordering field of VehicleClass.
type VehicleClassOrderField struct {
	field    string
	toCursor func(*VehicleClass) Cursor
}

// VehicleClassOrder defines the ordering of VehicleClass.
type VehicleClassOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *VehicleClassOrderField `json:"field"`
}

// DefaultVehicleClassOrder is the default ordering of VehicleClass.
var DefaultVehicleClassOrder = &VehicleClassOrder{
	Direction: OrderDirectionAsc,
	Field: &VehicleClassOrderField{
		field: vehicleclass.FieldID,
		toCursor: func(vc *VehicleClass) Cursor {
			return Cursor{ID: vc.ID}
		},
	},
}

// ToEdge converts VehicleClass into VehicleClassEdge.
func (vc *VehicleClass) ToEdge(order *VehicleClassOrder) *VehicleClassEdge {
	if order == nil {
		order = DefaultVehicleClassOrder
	}
	return &VehicleClassEdge{
		Node:   vc,
		Cursor: order.Field.toCursor(vc),
	}
}

// VehicleColorEdge is the edge representation of VehicleColor.
type VehicleColorEdge struct {
	Node   *VehicleColor `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// VehicleColorConnection is the connection containing edges to VehicleColor.
type VehicleColorConnection struct {
	Edges      []*VehicleColorEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// VehicleColorPaginateOption enables pagination customization.
type VehicleColorPaginateOption func(*vehicleColorPager) error

// WithVehicleColorOrder configures pagination ordering.
func WithVehicleColorOrder(order *VehicleColorOrder) VehicleColorPaginateOption {
	if order == nil {
		order = DefaultVehicleColorOrder
	}
	o := *order
	return func(pager *vehicleColorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVehicleColorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVehicleColorFilter configures pagination filter.
func WithVehicleColorFilter(filter func(*VehicleColorQuery) (*VehicleColorQuery, error)) VehicleColorPaginateOption {
	return func(pager *vehicleColorPager) error {
		if filter == nil {
			return errors.New("VehicleColorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vehicleColorPager struct {
	order  *VehicleColorOrder
	filter func(*VehicleColorQuery) (*VehicleColorQuery, error)
}

func newVehicleColorPager(opts []VehicleColorPaginateOption) (*vehicleColorPager, error) {
	pager := &vehicleColorPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVehicleColorOrder
	}
	return pager, nil
}

func (p *vehicleColorPager) applyFilter(query *VehicleColorQuery) (*VehicleColorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vehicleColorPager) toCursor(vc *VehicleColor) Cursor {
	return p.order.Field.toCursor(vc)
}

func (p *vehicleColorPager) applyCursors(query *VehicleColorQuery, after, before *Cursor) *VehicleColorQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVehicleColorOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vehicleColorPager) applyOrder(query *VehicleColorQuery, reverse bool) *VehicleColorQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVehicleColorOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVehicleColorOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VehicleColor.
func (vc *VehicleColorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VehicleColorPaginateOption,
) (*VehicleColorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVehicleColorPager(opts)
	if err != nil {
		return nil, err
	}

	if vc, err = pager.applyFilter(vc); err != nil {
		return nil, err
	}

	conn := &VehicleColorConnection{Edges: []*VehicleColorEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vc = pager.applyCursors(vc, after, before)
	vc = pager.applyOrder(vc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vc = vc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vc = vc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VehicleColor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VehicleColor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VehicleColor {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VehicleColorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VehicleColorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VehicleColorOrderFieldCreatedAt orders VehicleColor by created_at.
	VehicleColorOrderFieldCreatedAt = &VehicleColorOrderField{
		field: vehiclecolor.FieldCreatedAt,
		toCursor: func(vc *VehicleColor) Cursor {
			return Cursor{
				ID:    vc.ID,
				Value: vc.CreatedAt,
			}
		},
	}
	// VehicleColorOrderFieldUpdatedAt orders VehicleColor by updated_at.
	VehicleColorOrderFieldUpdatedAt = &VehicleColorOrderField{
		field: vehiclecolor.FieldUpdatedAt,
		toCursor: func(vc *VehicleColor) Cursor {
			return Cursor{
				ID:    vc.ID,
				Value: vc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VehicleColorOrderField) String() string {
	var str string
	switch f.field {
	case vehiclecolor.FieldCreatedAt:
		str = "CREATED_AT"
	case vehiclecolor.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VehicleColorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VehicleColorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VehicleColorOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *VehicleColorOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *VehicleColorOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid VehicleColorOrderField", str)
	}
	return nil
}

// VehicleColorOrderField defines the ordering field of VehicleColor.
type VehicleColorOrderField struct {
	field    string
	toCursor func(*VehicleColor) Cursor
}

// VehicleColorOrder defines the ordering of VehicleColor.
type VehicleColorOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *VehicleColorOrderField `json:"field"`
}

// DefaultVehicleColorOrder is the default ordering of VehicleColor.
var DefaultVehicleColorOrder = &VehicleColorOrder{
	Direction: OrderDirectionAsc,
	Field: &VehicleColorOrderField{
		field: vehiclecolor.FieldID,
		toCursor: func(vc *VehicleColor) Cursor {
			return Cursor{ID: vc.ID}
		},
	},
}

// ToEdge converts VehicleColor into VehicleColorEdge.
func (vc *VehicleColor) ToEdge(order *VehicleColorOrder) *VehicleColorEdge {
	if order == nil {
		order = DefaultVehicleColorOrder
	}
	return &VehicleColorEdge{
		Node:   vc,
		Cursor: order.Field.toCursor(vc),
	}
}

// VehicleMakeEdge is the edge representation of VehicleMake.
type VehicleMakeEdge struct {
	Node   *VehicleMake `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// VehicleMakeConnection is the connection containing edges to VehicleMake.
type VehicleMakeConnection struct {
	Edges      []*VehicleMakeEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// VehicleMakePaginateOption enables pagination customization.
type VehicleMakePaginateOption func(*vehicleMakePager) error

// WithVehicleMakeOrder configures pagination ordering.
func WithVehicleMakeOrder(order *VehicleMakeOrder) VehicleMakePaginateOption {
	if order == nil {
		order = DefaultVehicleMakeOrder
	}
	o := *order
	return func(pager *vehicleMakePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVehicleMakeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVehicleMakeFilter configures pagination filter.
func WithVehicleMakeFilter(filter func(*VehicleMakeQuery) (*VehicleMakeQuery, error)) VehicleMakePaginateOption {
	return func(pager *vehicleMakePager) error {
		if filter == nil {
			return errors.New("VehicleMakeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vehicleMakePager struct {
	order  *VehicleMakeOrder
	filter func(*VehicleMakeQuery) (*VehicleMakeQuery, error)
}

func newVehicleMakePager(opts []VehicleMakePaginateOption) (*vehicleMakePager, error) {
	pager := &vehicleMakePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVehicleMakeOrder
	}
	return pager, nil
}

func (p *vehicleMakePager) applyFilter(query *VehicleMakeQuery) (*VehicleMakeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vehicleMakePager) toCursor(vm *VehicleMake) Cursor {
	return p.order.Field.toCursor(vm)
}

func (p *vehicleMakePager) applyCursors(query *VehicleMakeQuery, after, before *Cursor) *VehicleMakeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVehicleMakeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vehicleMakePager) applyOrder(query *VehicleMakeQuery, reverse bool) *VehicleMakeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVehicleMakeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVehicleMakeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VehicleMake.
func (vm *VehicleMakeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VehicleMakePaginateOption,
) (*VehicleMakeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVehicleMakePager(opts)
	if err != nil {
		return nil, err
	}

	if vm, err = pager.applyFilter(vm); err != nil {
		return nil, err
	}

	conn := &VehicleMakeConnection{Edges: []*VehicleMakeEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vm.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vm.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vm = pager.applyCursors(vm, after, before)
	vm = pager.applyOrder(vm, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vm = vm.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vm = vm.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vm.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VehicleMake
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VehicleMake {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VehicleMake {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VehicleMakeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VehicleMakeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VehicleMakeOrderFieldCreatedAt orders VehicleMake by created_at.
	VehicleMakeOrderFieldCreatedAt = &VehicleMakeOrderField{
		field: vehiclemake.FieldCreatedAt,
		toCursor: func(vm *VehicleMake) Cursor {
			return Cursor{
				ID:    vm.ID,
				Value: vm.CreatedAt,
			}
		},
	}
	// VehicleMakeOrderFieldUpdatedAt orders VehicleMake by updated_at.
	VehicleMakeOrderFieldUpdatedAt = &VehicleMakeOrderField{
		field: vehiclemake.FieldUpdatedAt,
		toCursor: func(vm *VehicleMake) Cursor {
			return Cursor{
				ID:    vm.ID,
				Value: vm.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VehicleMakeOrderField) String() string {
	var str string
	switch f.field {
	case vehiclemake.FieldCreatedAt:
		str = "CREATED_AT"
	case vehiclemake.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VehicleMakeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VehicleMakeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VehicleMakeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *VehicleMakeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *VehicleMakeOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid VehicleMakeOrderField", str)
	}
	return nil
}

// VehicleMakeOrderField defines the ordering field of VehicleMake.
type VehicleMakeOrderField struct {
	field    string
	toCursor func(*VehicleMake) Cursor
}

// VehicleMakeOrder defines the ordering of VehicleMake.
type VehicleMakeOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *VehicleMakeOrderField `json:"field"`
}

// DefaultVehicleMakeOrder is the default ordering of VehicleMake.
var DefaultVehicleMakeOrder = &VehicleMakeOrder{
	Direction: OrderDirectionAsc,
	Field: &VehicleMakeOrderField{
		field: vehiclemake.FieldID,
		toCursor: func(vm *VehicleMake) Cursor {
			return Cursor{ID: vm.ID}
		},
	},
}

// ToEdge converts VehicleMake into VehicleMakeEdge.
func (vm *VehicleMake) ToEdge(order *VehicleMakeOrder) *VehicleMakeEdge {
	if order == nil {
		order = DefaultVehicleMakeOrder
	}
	return &VehicleMakeEdge{
		Node:   vm,
		Cursor: order.Field.toCursor(vm),
	}
}

// VehicleModelEdge is the edge representation of VehicleModel.
type VehicleModelEdge struct {
	Node   *VehicleModel `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// VehicleModelConnection is the connection containing edges to VehicleModel.
type VehicleModelConnection struct {
	Edges      []*VehicleModelEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// VehicleModelPaginateOption enables pagination customization.
type VehicleModelPaginateOption func(*vehicleModelPager) error

// WithVehicleModelOrder configures pagination ordering.
func WithVehicleModelOrder(order *VehicleModelOrder) VehicleModelPaginateOption {
	if order == nil {
		order = DefaultVehicleModelOrder
	}
	o := *order
	return func(pager *vehicleModelPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVehicleModelOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVehicleModelFilter configures pagination filter.
func WithVehicleModelFilter(filter func(*VehicleModelQuery) (*VehicleModelQuery, error)) VehicleModelPaginateOption {
	return func(pager *vehicleModelPager) error {
		if filter == nil {
			return errors.New("VehicleModelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vehicleModelPager struct {
	order  *VehicleModelOrder
	filter func(*VehicleModelQuery) (*VehicleModelQuery, error)
}

func newVehicleModelPager(opts []VehicleModelPaginateOption) (*vehicleModelPager, error) {
	pager := &vehicleModelPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVehicleModelOrder
	}
	return pager, nil
}

func (p *vehicleModelPager) applyFilter(query *VehicleModelQuery) (*VehicleModelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vehicleModelPager) toCursor(vm *VehicleModel) Cursor {
	return p.order.Field.toCursor(vm)
}

func (p *vehicleModelPager) applyCursors(query *VehicleModelQuery, after, before *Cursor) *VehicleModelQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVehicleModelOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vehicleModelPager) applyOrder(query *VehicleModelQuery, reverse bool) *VehicleModelQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVehicleModelOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVehicleModelOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VehicleModel.
func (vm *VehicleModelQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VehicleModelPaginateOption,
) (*VehicleModelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVehicleModelPager(opts)
	if err != nil {
		return nil, err
	}

	if vm, err = pager.applyFilter(vm); err != nil {
		return nil, err
	}

	conn := &VehicleModelConnection{Edges: []*VehicleModelEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vm.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vm.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vm = pager.applyCursors(vm, after, before)
	vm = pager.applyOrder(vm, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vm = vm.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vm = vm.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vm.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VehicleModel
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VehicleModel {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VehicleModel {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VehicleModelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VehicleModelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VehicleModelOrderFieldCreatedAt orders VehicleModel by created_at.
	VehicleModelOrderFieldCreatedAt = &VehicleModelOrderField{
		field: vehiclemodel.FieldCreatedAt,
		toCursor: func(vm *VehicleModel) Cursor {
			return Cursor{
				ID:    vm.ID,
				Value: vm.CreatedAt,
			}
		},
	}
	// VehicleModelOrderFieldUpdatedAt orders VehicleModel by updated_at.
	VehicleModelOrderFieldUpdatedAt = &VehicleModelOrderField{
		field: vehiclemodel.FieldUpdatedAt,
		toCursor: func(vm *VehicleModel) Cursor {
			return Cursor{
				ID:    vm.ID,
				Value: vm.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VehicleModelOrderField) String() string {
	var str string
	switch f.field {
	case vehiclemodel.FieldCreatedAt:
		str = "CREATED_AT"
	case vehiclemodel.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VehicleModelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VehicleModelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VehicleModelOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *VehicleModelOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *VehicleModelOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid VehicleModelOrderField", str)
	}
	return nil
}

// VehicleModelOrderField defines the ordering field of VehicleModel.
type VehicleModelOrderField struct {
	field    string
	toCursor func(*VehicleModel) Cursor
}

// VehicleModelOrder defines the ordering of VehicleModel.
type VehicleModelOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *VehicleModelOrderField `json:"field"`
}

// DefaultVehicleModelOrder is the default ordering of VehicleModel.
var DefaultVehicleModelOrder = &VehicleModelOrder{
	Direction: OrderDirectionAsc,
	Field: &VehicleModelOrderField{
		field: vehiclemodel.FieldID,
		toCursor: func(vm *VehicleModel) Cursor {
			return Cursor{ID: vm.ID}
		},
	},
}

// ToEdge converts VehicleModel into VehicleModelEdge.
func (vm *VehicleModel) ToEdge(order *VehicleModelOrder) *VehicleModelEdge {
	if order == nil {
		order = DefaultVehicleModelOrder
	}
	return &VehicleModelEdge{
		Node:   vm,
		Cursor: order.Field.toCursor(vm),
	}
}

// VehicleRegistrationEdge is the edge representation of VehicleRegistration.
type VehicleRegistrationEdge struct {
	Node   *VehicleRegistration `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// VehicleRegistrationConnection is the connection containing edges to VehicleRegistration.
type VehicleRegistrationConnection struct {
	Edges      []*VehicleRegistrationEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

// VehicleRegistrationPaginateOption enables pagination customization.
type VehicleRegistrationPaginateOption func(*vehicleRegistrationPager) error

// WithVehicleRegistrationOrder configures pagination ordering.
func WithVehicleRegistrationOrder(order *VehicleRegistrationOrder) VehicleRegistrationPaginateOption {
	if order == nil {
		order = DefaultVehicleRegistrationOrder
	}
	o := *order
	return func(pager *vehicleRegistrationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVehicleRegistrationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVehicleRegistrationFilter configures pagination filter.
func WithVehicleRegistrationFilter(filter func(*VehicleRegistrationQuery) (*VehicleRegistrationQuery, error)) VehicleRegistrationPaginateOption {
	return func(pager *vehicleRegistrationPager) error {
		if filter == nil {
			return errors.New("VehicleRegistrationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vehicleRegistrationPager struct {
	order  *VehicleRegistrationOrder
	filter func(*VehicleRegistrationQuery) (*VehicleRegistrationQuery, error)
}

func newVehicleRegistrationPager(opts []VehicleRegistrationPaginateOption) (*vehicleRegistrationPager, error) {
	pager := &vehicleRegistrationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVehicleRegistrationOrder
	}
	return pager, nil
}

func (p *vehicleRegistrationPager) applyFilter(query *VehicleRegistrationQuery) (*VehicleRegistrationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vehicleRegistrationPager) toCursor(vr *VehicleRegistration) Cursor {
	return p.order.Field.toCursor(vr)
}

func (p *vehicleRegistrationPager) applyCursors(query *VehicleRegistrationQuery, after, before *Cursor) *VehicleRegistrationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVehicleRegistrationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vehicleRegistrationPager) applyOrder(query *VehicleRegistrationQuery, reverse bool) *VehicleRegistrationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVehicleRegistrationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVehicleRegistrationOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VehicleRegistration.
func (vr *VehicleRegistrationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VehicleRegistrationPaginateOption,
) (*VehicleRegistrationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVehicleRegistrationPager(opts)
	if err != nil {
		return nil, err
	}

	if vr, err = pager.applyFilter(vr); err != nil {
		return nil, err
	}

	conn := &VehicleRegistrationConnection{Edges: []*VehicleRegistrationEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vr = pager.applyCursors(vr, after, before)
	vr = pager.applyOrder(vr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vr = vr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vr = vr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VehicleRegistration
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VehicleRegistration {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VehicleRegistration {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VehicleRegistrationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VehicleRegistrationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VehicleRegistrationOrderFieldCreatedAt orders VehicleRegistration by created_at.
	VehicleRegistrationOrderFieldCreatedAt = &VehicleRegistrationOrderField{
		field: vehicleregistration.FieldCreatedAt,
		toCursor: func(vr *VehicleRegistration) Cursor {
			return Cursor{
				ID:    vr.ID,
				Value: vr.CreatedAt,
			}
		},
	}
	// VehicleRegistrationOrderFieldUpdatedAt orders VehicleRegistration by updated_at.
	VehicleRegistrationOrderFieldUpdatedAt = &VehicleRegistrationOrderField{
		field: vehicleregistration.FieldUpdatedAt,
		toCursor: func(vr *VehicleRegistration) Cursor {
			return Cursor{
				ID:    vr.ID,
				Value: vr.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VehicleRegistrationOrderField) String() string {
	var str string
	switch f.field {
	case vehicleregistration.FieldCreatedAt:
		str = "CREATED_AT"
	case vehicleregistration.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VehicleRegistrationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VehicleRegistrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VehicleRegistrationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *VehicleRegistrationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *VehicleRegistrationOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid VehicleRegistrationOrderField", str)
	}
	return nil
}

// VehicleRegistrationOrderField defines the ordering field of VehicleRegistration.
type VehicleRegistrationOrderField struct {
	field    string
	toCursor func(*VehicleRegistration) Cursor
}

// VehicleRegistrationOrder defines the ordering of VehicleRegistration.
type VehicleRegistrationOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *VehicleRegistrationOrderField `json:"field"`
}

// DefaultVehicleRegistrationOrder is the default ordering of VehicleRegistration.
var DefaultVehicleRegistrationOrder = &VehicleRegistrationOrder{
	Direction: OrderDirectionAsc,
	Field: &VehicleRegistrationOrderField{
		field: vehicleregistration.FieldID,
		toCursor: func(vr *VehicleRegistration) Cursor {
			return Cursor{ID: vr.ID}
		},
	},
}

// ToEdge converts VehicleRegistration into VehicleRegistrationEdge.
func (vr *VehicleRegistration) ToEdge(order *VehicleRegistrationOrder) *VehicleRegistrationEdge {
	if order == nil {
		order = DefaultVehicleRegistrationOrder
	}
	return &VehicleRegistrationEdge{
		Node:   vr,
		Cursor: order.Field.toCursor(vr),
	}
}
