// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/responserms/response/internal/ent/deathcertificate"
	"github.com/responserms/response/internal/ent/deathcertifier"
	"github.com/responserms/response/internal/ent/deathmanner"
	"github.com/responserms/response/internal/ent/deathplace"
	"github.com/responserms/response/internal/ent/ethnicity"
	"github.com/responserms/response/internal/ent/gameserver"
	"github.com/responserms/response/internal/ent/metadata"
	"github.com/responserms/response/internal/ent/oauthconnection"
	"github.com/responserms/response/internal/ent/person"
	"github.com/responserms/response/internal/ent/player"
	"github.com/responserms/response/internal/ent/playeridentifier"
	"github.com/responserms/response/internal/ent/predicate"
	"github.com/responserms/response/internal/ent/race"
	"github.com/responserms/response/internal/ent/session"
	"github.com/responserms/response/internal/ent/setting"
	"github.com/responserms/response/internal/ent/sex"
	"github.com/responserms/response/internal/ent/state"
	"github.com/responserms/response/internal/ent/user"
	"github.com/responserms/response/internal/ent/vehicle"
	"github.com/responserms/response/internal/ent/vehicleclass"
	"github.com/responserms/response/internal/ent/vehiclecolor"
	"github.com/responserms/response/internal/ent/vehiclemake"
	"github.com/responserms/response/internal/ent/vehiclemodel"
	"github.com/responserms/response/internal/ent/vehicleregistration"
)

// DeathCertificateWhereInput represents a where input for filtering DeathCertificate queries.
type DeathCertificateWhereInput struct {
	Not *DeathCertificateWhereInput   `json:"not,omitempty"`
	Or  []*DeathCertificateWhereInput `json:"or,omitempty"`
	And []*DeathCertificateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "cause" field predicates.
	Cause             *string  `json:"cause,omitempty"`
	CauseNEQ          *string  `json:"causeNEQ,omitempty"`
	CauseIn           []string `json:"causeIn,omitempty"`
	CauseNotIn        []string `json:"causeNotIn,omitempty"`
	CauseGT           *string  `json:"causeGT,omitempty"`
	CauseGTE          *string  `json:"causeGTE,omitempty"`
	CauseLT           *string  `json:"causeLT,omitempty"`
	CauseLTE          *string  `json:"causeLTE,omitempty"`
	CauseContains     *string  `json:"causeContains,omitempty"`
	CauseHasPrefix    *string  `json:"causeHasPrefix,omitempty"`
	CauseHasSuffix    *string  `json:"causeHasSuffix,omitempty"`
	CauseEqualFold    *string  `json:"causeEqualFold,omitempty"`
	CauseContainsFold *string  `json:"causeContainsFold,omitempty"`

	// "comments" field predicates.
	Comments             *string  `json:"comments,omitempty"`
	CommentsNEQ          *string  `json:"commentsNEQ,omitempty"`
	CommentsIn           []string `json:"commentsIn,omitempty"`
	CommentsNotIn        []string `json:"commentsNotIn,omitempty"`
	CommentsGT           *string  `json:"commentsGT,omitempty"`
	CommentsGTE          *string  `json:"commentsGTE,omitempty"`
	CommentsLT           *string  `json:"commentsLT,omitempty"`
	CommentsLTE          *string  `json:"commentsLTE,omitempty"`
	CommentsContains     *string  `json:"commentsContains,omitempty"`
	CommentsHasPrefix    *string  `json:"commentsHasPrefix,omitempty"`
	CommentsHasSuffix    *string  `json:"commentsHasSuffix,omitempty"`
	CommentsIsNil        bool     `json:"commentsIsNil,omitempty"`
	CommentsNotNil       bool     `json:"commentsNotNil,omitempty"`
	CommentsEqualFold    *string  `json:"commentsEqualFold,omitempty"`
	CommentsContainsFold *string  `json:"commentsContainsFold,omitempty"`

	// "certified_at" field predicates.
	CertifiedAt       *time.Time  `json:"certifiedAt,omitempty"`
	CertifiedAtNEQ    *time.Time  `json:"certifiedAtNEQ,omitempty"`
	CertifiedAtIn     []time.Time `json:"certifiedAtIn,omitempty"`
	CertifiedAtNotIn  []time.Time `json:"certifiedAtNotIn,omitempty"`
	CertifiedAtGT     *time.Time  `json:"certifiedAtGT,omitempty"`
	CertifiedAtGTE    *time.Time  `json:"certifiedAtGTE,omitempty"`
	CertifiedAtLT     *time.Time  `json:"certifiedAtLT,omitempty"`
	CertifiedAtLTE    *time.Time  `json:"certifiedAtLTE,omitempty"`
	CertifiedAtIsNil  bool        `json:"certifiedAtIsNil,omitempty"`
	CertifiedAtNotNil bool        `json:"certifiedAtNotNil,omitempty"`

	// "certifier_comments" field predicates.
	CertifierComments             *string  `json:"certifierComments,omitempty"`
	CertifierCommentsNEQ          *string  `json:"certifierCommentsNEQ,omitempty"`
	CertifierCommentsIn           []string `json:"certifierCommentsIn,omitempty"`
	CertifierCommentsNotIn        []string `json:"certifierCommentsNotIn,omitempty"`
	CertifierCommentsGT           *string  `json:"certifierCommentsGT,omitempty"`
	CertifierCommentsGTE          *string  `json:"certifierCommentsGTE,omitempty"`
	CertifierCommentsLT           *string  `json:"certifierCommentsLT,omitempty"`
	CertifierCommentsLTE          *string  `json:"certifierCommentsLTE,omitempty"`
	CertifierCommentsContains     *string  `json:"certifierCommentsContains,omitempty"`
	CertifierCommentsHasPrefix    *string  `json:"certifierCommentsHasPrefix,omitempty"`
	CertifierCommentsHasSuffix    *string  `json:"certifierCommentsHasSuffix,omitempty"`
	CertifierCommentsIsNil        bool     `json:"certifierCommentsIsNil,omitempty"`
	CertifierCommentsNotNil       bool     `json:"certifierCommentsNotNil,omitempty"`
	CertifierCommentsEqualFold    *string  `json:"certifierCommentsEqualFold,omitempty"`
	CertifierCommentsContainsFold *string  `json:"certifierCommentsContainsFold,omitempty"`

	// "requires_certification" field predicates.
	RequiresCertification    *bool `json:"requiresCertification,omitempty"`
	RequiresCertificationNEQ *bool `json:"requiresCertificationNEQ,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "decedent" edge predicates.
	HasDecedent     *bool               `json:"hasDecedent,omitempty"`
	HasDecedentWith []*PersonWhereInput `json:"hasDecedentWith,omitempty"`

	// "manner" edge predicates.
	HasManner     *bool                    `json:"hasManner,omitempty"`
	HasMannerWith []*DeathMannerWhereInput `json:"hasMannerWith,omitempty"`

	// "place" edge predicates.
	HasPlace     *bool                   `json:"hasPlace,omitempty"`
	HasPlaceWith []*DeathPlaceWhereInput `json:"hasPlaceWith,omitempty"`

	// "certifier" edge predicates.
	HasCertifier     *bool                       `json:"hasCertifier,omitempty"`
	HasCertifierWith []*DeathCertifierWhereInput `json:"hasCertifierWith,omitempty"`

	// "certified_by" edge predicates.
	HasCertifiedBy     *bool               `json:"hasCertifiedBy,omitempty"`
	HasCertifiedByWith []*PersonWhereInput `json:"hasCertifiedByWith,omitempty"`
}

// Filter applies the DeathCertificateWhereInput filter on the DeathCertificateQuery builder.
func (i *DeathCertificateWhereInput) Filter(q *DeathCertificateQuery) (*DeathCertificateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering deathcertificates.
// An error is returned if the input is empty or invalid.
func (i *DeathCertificateWhereInput) P() (predicate.DeathCertificate, error) {
	var predicates []predicate.DeathCertificate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, deathcertificate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeathCertificate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, deathcertificate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeathCertificate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, deathcertificate.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, deathcertificate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deathcertificate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deathcertificate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deathcertificate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deathcertificate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deathcertificate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deathcertificate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deathcertificate.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, deathcertificate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, deathcertificate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, deathcertificate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, deathcertificate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, deathcertificate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, deathcertificate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, deathcertificate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, deathcertificate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, deathcertificate.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, deathcertificate.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, deathcertificate.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, deathcertificate.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, deathcertificate.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, deathcertificate.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, deathcertificate.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, deathcertificate.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, deathcertificate.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, deathcertificate.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, deathcertificate.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, deathcertificate.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, deathcertificate.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, deathcertificate.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, deathcertificate.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, deathcertificate.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, deathcertificate.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, deathcertificate.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, deathcertificate.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, deathcertificate.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, deathcertificate.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, deathcertificate.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, deathcertificate.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, deathcertificate.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, deathcertificate.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, deathcertificate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, deathcertificate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, deathcertificate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, deathcertificate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, deathcertificate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, deathcertificate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, deathcertificate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, deathcertificate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, deathcertificate.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, deathcertificate.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, deathcertificate.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, deathcertificate.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, deathcertificate.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, deathcertificate.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, deathcertificate.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, deathcertificate.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, deathcertificate.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, deathcertificate.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, deathcertificate.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, deathcertificate.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, deathcertificate.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, deathcertificate.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, deathcertificate.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Cause != nil {
		predicates = append(predicates, deathcertificate.CauseEQ(*i.Cause))
	}
	if i.CauseNEQ != nil {
		predicates = append(predicates, deathcertificate.CauseNEQ(*i.CauseNEQ))
	}
	if len(i.CauseIn) > 0 {
		predicates = append(predicates, deathcertificate.CauseIn(i.CauseIn...))
	}
	if len(i.CauseNotIn) > 0 {
		predicates = append(predicates, deathcertificate.CauseNotIn(i.CauseNotIn...))
	}
	if i.CauseGT != nil {
		predicates = append(predicates, deathcertificate.CauseGT(*i.CauseGT))
	}
	if i.CauseGTE != nil {
		predicates = append(predicates, deathcertificate.CauseGTE(*i.CauseGTE))
	}
	if i.CauseLT != nil {
		predicates = append(predicates, deathcertificate.CauseLT(*i.CauseLT))
	}
	if i.CauseLTE != nil {
		predicates = append(predicates, deathcertificate.CauseLTE(*i.CauseLTE))
	}
	if i.CauseContains != nil {
		predicates = append(predicates, deathcertificate.CauseContains(*i.CauseContains))
	}
	if i.CauseHasPrefix != nil {
		predicates = append(predicates, deathcertificate.CauseHasPrefix(*i.CauseHasPrefix))
	}
	if i.CauseHasSuffix != nil {
		predicates = append(predicates, deathcertificate.CauseHasSuffix(*i.CauseHasSuffix))
	}
	if i.CauseEqualFold != nil {
		predicates = append(predicates, deathcertificate.CauseEqualFold(*i.CauseEqualFold))
	}
	if i.CauseContainsFold != nil {
		predicates = append(predicates, deathcertificate.CauseContainsFold(*i.CauseContainsFold))
	}
	if i.Comments != nil {
		predicates = append(predicates, deathcertificate.CommentsEQ(*i.Comments))
	}
	if i.CommentsNEQ != nil {
		predicates = append(predicates, deathcertificate.CommentsNEQ(*i.CommentsNEQ))
	}
	if len(i.CommentsIn) > 0 {
		predicates = append(predicates, deathcertificate.CommentsIn(i.CommentsIn...))
	}
	if len(i.CommentsNotIn) > 0 {
		predicates = append(predicates, deathcertificate.CommentsNotIn(i.CommentsNotIn...))
	}
	if i.CommentsGT != nil {
		predicates = append(predicates, deathcertificate.CommentsGT(*i.CommentsGT))
	}
	if i.CommentsGTE != nil {
		predicates = append(predicates, deathcertificate.CommentsGTE(*i.CommentsGTE))
	}
	if i.CommentsLT != nil {
		predicates = append(predicates, deathcertificate.CommentsLT(*i.CommentsLT))
	}
	if i.CommentsLTE != nil {
		predicates = append(predicates, deathcertificate.CommentsLTE(*i.CommentsLTE))
	}
	if i.CommentsContains != nil {
		predicates = append(predicates, deathcertificate.CommentsContains(*i.CommentsContains))
	}
	if i.CommentsHasPrefix != nil {
		predicates = append(predicates, deathcertificate.CommentsHasPrefix(*i.CommentsHasPrefix))
	}
	if i.CommentsHasSuffix != nil {
		predicates = append(predicates, deathcertificate.CommentsHasSuffix(*i.CommentsHasSuffix))
	}
	if i.CommentsIsNil {
		predicates = append(predicates, deathcertificate.CommentsIsNil())
	}
	if i.CommentsNotNil {
		predicates = append(predicates, deathcertificate.CommentsNotNil())
	}
	if i.CommentsEqualFold != nil {
		predicates = append(predicates, deathcertificate.CommentsEqualFold(*i.CommentsEqualFold))
	}
	if i.CommentsContainsFold != nil {
		predicates = append(predicates, deathcertificate.CommentsContainsFold(*i.CommentsContainsFold))
	}
	if i.CertifiedAt != nil {
		predicates = append(predicates, deathcertificate.CertifiedAtEQ(*i.CertifiedAt))
	}
	if i.CertifiedAtNEQ != nil {
		predicates = append(predicates, deathcertificate.CertifiedAtNEQ(*i.CertifiedAtNEQ))
	}
	if len(i.CertifiedAtIn) > 0 {
		predicates = append(predicates, deathcertificate.CertifiedAtIn(i.CertifiedAtIn...))
	}
	if len(i.CertifiedAtNotIn) > 0 {
		predicates = append(predicates, deathcertificate.CertifiedAtNotIn(i.CertifiedAtNotIn...))
	}
	if i.CertifiedAtGT != nil {
		predicates = append(predicates, deathcertificate.CertifiedAtGT(*i.CertifiedAtGT))
	}
	if i.CertifiedAtGTE != nil {
		predicates = append(predicates, deathcertificate.CertifiedAtGTE(*i.CertifiedAtGTE))
	}
	if i.CertifiedAtLT != nil {
		predicates = append(predicates, deathcertificate.CertifiedAtLT(*i.CertifiedAtLT))
	}
	if i.CertifiedAtLTE != nil {
		predicates = append(predicates, deathcertificate.CertifiedAtLTE(*i.CertifiedAtLTE))
	}
	if i.CertifiedAtIsNil {
		predicates = append(predicates, deathcertificate.CertifiedAtIsNil())
	}
	if i.CertifiedAtNotNil {
		predicates = append(predicates, deathcertificate.CertifiedAtNotNil())
	}
	if i.CertifierComments != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsEQ(*i.CertifierComments))
	}
	if i.CertifierCommentsNEQ != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsNEQ(*i.CertifierCommentsNEQ))
	}
	if len(i.CertifierCommentsIn) > 0 {
		predicates = append(predicates, deathcertificate.CertifierCommentsIn(i.CertifierCommentsIn...))
	}
	if len(i.CertifierCommentsNotIn) > 0 {
		predicates = append(predicates, deathcertificate.CertifierCommentsNotIn(i.CertifierCommentsNotIn...))
	}
	if i.CertifierCommentsGT != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsGT(*i.CertifierCommentsGT))
	}
	if i.CertifierCommentsGTE != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsGTE(*i.CertifierCommentsGTE))
	}
	if i.CertifierCommentsLT != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsLT(*i.CertifierCommentsLT))
	}
	if i.CertifierCommentsLTE != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsLTE(*i.CertifierCommentsLTE))
	}
	if i.CertifierCommentsContains != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsContains(*i.CertifierCommentsContains))
	}
	if i.CertifierCommentsHasPrefix != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsHasPrefix(*i.CertifierCommentsHasPrefix))
	}
	if i.CertifierCommentsHasSuffix != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsHasSuffix(*i.CertifierCommentsHasSuffix))
	}
	if i.CertifierCommentsIsNil {
		predicates = append(predicates, deathcertificate.CertifierCommentsIsNil())
	}
	if i.CertifierCommentsNotNil {
		predicates = append(predicates, deathcertificate.CertifierCommentsNotNil())
	}
	if i.CertifierCommentsEqualFold != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsEqualFold(*i.CertifierCommentsEqualFold))
	}
	if i.CertifierCommentsContainsFold != nil {
		predicates = append(predicates, deathcertificate.CertifierCommentsContainsFold(*i.CertifierCommentsContainsFold))
	}
	if i.RequiresCertification != nil {
		predicates = append(predicates, deathcertificate.RequiresCertificationEQ(*i.RequiresCertification))
	}
	if i.RequiresCertificationNEQ != nil {
		predicates = append(predicates, deathcertificate.RequiresCertificationNEQ(*i.RequiresCertificationNEQ))
	}

	if i.HasMetadata != nil {
		p := deathcertificate.HasMetadata()
		if !*i.HasMetadata {
			p = deathcertificate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertificate.HasMetadataWith(with...))
	}
	if i.HasDecedent != nil {
		p := deathcertificate.HasDecedent()
		if !*i.HasDecedent {
			p = deathcertificate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDecedentWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasDecedentWith))
		for _, w := range i.HasDecedentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertificate.HasDecedentWith(with...))
	}
	if i.HasManner != nil {
		p := deathcertificate.HasManner()
		if !*i.HasManner {
			p = deathcertificate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMannerWith) > 0 {
		with := make([]predicate.DeathManner, 0, len(i.HasMannerWith))
		for _, w := range i.HasMannerWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertificate.HasMannerWith(with...))
	}
	if i.HasPlace != nil {
		p := deathcertificate.HasPlace()
		if !*i.HasPlace {
			p = deathcertificate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlaceWith) > 0 {
		with := make([]predicate.DeathPlace, 0, len(i.HasPlaceWith))
		for _, w := range i.HasPlaceWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertificate.HasPlaceWith(with...))
	}
	if i.HasCertifier != nil {
		p := deathcertificate.HasCertifier()
		if !*i.HasCertifier {
			p = deathcertificate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCertifierWith) > 0 {
		with := make([]predicate.DeathCertifier, 0, len(i.HasCertifierWith))
		for _, w := range i.HasCertifierWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertificate.HasCertifierWith(with...))
	}
	if i.HasCertifiedBy != nil {
		p := deathcertificate.HasCertifiedBy()
		if !*i.HasCertifiedBy {
			p = deathcertificate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCertifiedByWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasCertifiedByWith))
		for _, w := range i.HasCertifiedByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertificate.HasCertifiedByWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate DeathCertificateWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return deathcertificate.And(predicates...), nil
	}
}

// DeathCertifierWhereInput represents a where input for filtering DeathCertifier queries.
type DeathCertifierWhereInput struct {
	Not *DeathCertifierWhereInput   `json:"not,omitempty"`
	Or  []*DeathCertifierWhereInput `json:"or,omitempty"`
	And []*DeathCertifierWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "death_certificates" edge predicates.
	HasDeathCertificates     *bool                         `json:"hasDeathCertificates,omitempty"`
	HasDeathCertificatesWith []*DeathCertificateWhereInput `json:"hasDeathCertificatesWith,omitempty"`
}

// Filter applies the DeathCertifierWhereInput filter on the DeathCertifierQuery builder.
func (i *DeathCertifierWhereInput) Filter(q *DeathCertifierQuery) (*DeathCertifierQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering deathcertifiers.
// An error is returned if the input is empty or invalid.
func (i *DeathCertifierWhereInput) P() (predicate.DeathCertifier, error) {
	var predicates []predicate.DeathCertifier
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, deathcertifier.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeathCertifier, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, deathcertifier.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeathCertifier, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, deathcertifier.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, deathcertifier.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deathcertifier.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deathcertifier.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deathcertifier.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deathcertifier.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deathcertifier.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deathcertifier.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deathcertifier.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, deathcertifier.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, deathcertifier.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, deathcertifier.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, deathcertifier.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, deathcertifier.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, deathcertifier.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, deathcertifier.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, deathcertifier.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, deathcertifier.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, deathcertifier.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, deathcertifier.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, deathcertifier.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, deathcertifier.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, deathcertifier.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, deathcertifier.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, deathcertifier.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, deathcertifier.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, deathcertifier.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, deathcertifier.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, deathcertifier.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, deathcertifier.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, deathcertifier.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, deathcertifier.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, deathcertifier.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, deathcertifier.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, deathcertifier.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, deathcertifier.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, deathcertifier.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, deathcertifier.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, deathcertifier.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, deathcertifier.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, deathcertifier.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, deathcertifier.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, deathcertifier.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, deathcertifier.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, deathcertifier.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, deathcertifier.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, deathcertifier.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, deathcertifier.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, deathcertifier.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, deathcertifier.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, deathcertifier.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, deathcertifier.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, deathcertifier.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, deathcertifier.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, deathcertifier.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, deathcertifier.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, deathcertifier.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, deathcertifier.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, deathcertifier.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, deathcertifier.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, deathcertifier.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, deathcertifier.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, deathcertifier.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, deathcertifier.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, deathcertifier.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, deathcertifier.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, deathcertifier.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, deathcertifier.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, deathcertifier.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, deathcertifier.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, deathcertifier.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, deathcertifier.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, deathcertifier.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, deathcertifier.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, deathcertifier.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, deathcertifier.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, deathcertifier.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, deathcertifier.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, deathcertifier.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, deathcertifier.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, deathcertifier.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, deathcertifier.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, deathcertifier.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, deathcertifier.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, deathcertifier.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, deathcertifier.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, deathcertifier.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, deathcertifier.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, deathcertifier.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, deathcertifier.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, deathcertifier.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, deathcertifier.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, deathcertifier.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, deathcertifier.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, deathcertifier.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, deathcertifier.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, deathcertifier.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, deathcertifier.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, deathcertifier.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, deathcertifier.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, deathcertifier.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, deathcertifier.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, deathcertifier.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, deathcertifier.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, deathcertifier.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, deathcertifier.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := deathcertifier.HasMetadata()
		if !*i.HasMetadata {
			p = deathcertifier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertifier.HasMetadataWith(with...))
	}
	if i.HasDeathCertificates != nil {
		p := deathcertifier.HasDeathCertificates()
		if !*i.HasDeathCertificates {
			p = deathcertifier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeathCertificatesWith) > 0 {
		with := make([]predicate.DeathCertificate, 0, len(i.HasDeathCertificatesWith))
		for _, w := range i.HasDeathCertificatesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathcertifier.HasDeathCertificatesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate DeathCertifierWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return deathcertifier.And(predicates...), nil
	}
}

// DeathMannerWhereInput represents a where input for filtering DeathManner queries.
type DeathMannerWhereInput struct {
	Not *DeathMannerWhereInput   `json:"not,omitempty"`
	Or  []*DeathMannerWhereInput `json:"or,omitempty"`
	And []*DeathMannerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "death_certificates" edge predicates.
	HasDeathCertificates     *bool                         `json:"hasDeathCertificates,omitempty"`
	HasDeathCertificatesWith []*DeathCertificateWhereInput `json:"hasDeathCertificatesWith,omitempty"`
}

// Filter applies the DeathMannerWhereInput filter on the DeathMannerQuery builder.
func (i *DeathMannerWhereInput) Filter(q *DeathMannerQuery) (*DeathMannerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering deathmanners.
// An error is returned if the input is empty or invalid.
func (i *DeathMannerWhereInput) P() (predicate.DeathManner, error) {
	var predicates []predicate.DeathManner
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, deathmanner.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeathManner, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, deathmanner.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeathManner, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, deathmanner.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, deathmanner.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deathmanner.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deathmanner.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deathmanner.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deathmanner.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deathmanner.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deathmanner.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deathmanner.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, deathmanner.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, deathmanner.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, deathmanner.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, deathmanner.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, deathmanner.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, deathmanner.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, deathmanner.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, deathmanner.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, deathmanner.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, deathmanner.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, deathmanner.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, deathmanner.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, deathmanner.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, deathmanner.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, deathmanner.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, deathmanner.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, deathmanner.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, deathmanner.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, deathmanner.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, deathmanner.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, deathmanner.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, deathmanner.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, deathmanner.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, deathmanner.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, deathmanner.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, deathmanner.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, deathmanner.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, deathmanner.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, deathmanner.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, deathmanner.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, deathmanner.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, deathmanner.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, deathmanner.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, deathmanner.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, deathmanner.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, deathmanner.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, deathmanner.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, deathmanner.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, deathmanner.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, deathmanner.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, deathmanner.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, deathmanner.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, deathmanner.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, deathmanner.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, deathmanner.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, deathmanner.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, deathmanner.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, deathmanner.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, deathmanner.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, deathmanner.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, deathmanner.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, deathmanner.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, deathmanner.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, deathmanner.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, deathmanner.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, deathmanner.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, deathmanner.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, deathmanner.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, deathmanner.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, deathmanner.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, deathmanner.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, deathmanner.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, deathmanner.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, deathmanner.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, deathmanner.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, deathmanner.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, deathmanner.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, deathmanner.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, deathmanner.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, deathmanner.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, deathmanner.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, deathmanner.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, deathmanner.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, deathmanner.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, deathmanner.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, deathmanner.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, deathmanner.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, deathmanner.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, deathmanner.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, deathmanner.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, deathmanner.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, deathmanner.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, deathmanner.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, deathmanner.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, deathmanner.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, deathmanner.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, deathmanner.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, deathmanner.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, deathmanner.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, deathmanner.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, deathmanner.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, deathmanner.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, deathmanner.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, deathmanner.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, deathmanner.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, deathmanner.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, deathmanner.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, deathmanner.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, deathmanner.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, deathmanner.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, deathmanner.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, deathmanner.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, deathmanner.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, deathmanner.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, deathmanner.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, deathmanner.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, deathmanner.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := deathmanner.HasMetadata()
		if !*i.HasMetadata {
			p = deathmanner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathmanner.HasMetadataWith(with...))
	}
	if i.HasDeathCertificates != nil {
		p := deathmanner.HasDeathCertificates()
		if !*i.HasDeathCertificates {
			p = deathmanner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeathCertificatesWith) > 0 {
		with := make([]predicate.DeathCertificate, 0, len(i.HasDeathCertificatesWith))
		for _, w := range i.HasDeathCertificatesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathmanner.HasDeathCertificatesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate DeathMannerWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return deathmanner.And(predicates...), nil
	}
}

// DeathPlaceWhereInput represents a where input for filtering DeathPlace queries.
type DeathPlaceWhereInput struct {
	Not *DeathPlaceWhereInput   `json:"not,omitempty"`
	Or  []*DeathPlaceWhereInput `json:"or,omitempty"`
	And []*DeathPlaceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "death_certificates" edge predicates.
	HasDeathCertificates     *bool                         `json:"hasDeathCertificates,omitempty"`
	HasDeathCertificatesWith []*DeathCertificateWhereInput `json:"hasDeathCertificatesWith,omitempty"`
}

// Filter applies the DeathPlaceWhereInput filter on the DeathPlaceQuery builder.
func (i *DeathPlaceWhereInput) Filter(q *DeathPlaceQuery) (*DeathPlaceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering deathplaces.
// An error is returned if the input is empty or invalid.
func (i *DeathPlaceWhereInput) P() (predicate.DeathPlace, error) {
	var predicates []predicate.DeathPlace
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, deathplace.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeathPlace, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, deathplace.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeathPlace, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, deathplace.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, deathplace.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deathplace.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deathplace.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deathplace.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deathplace.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deathplace.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deathplace.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deathplace.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, deathplace.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, deathplace.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, deathplace.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, deathplace.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, deathplace.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, deathplace.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, deathplace.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, deathplace.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, deathplace.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, deathplace.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, deathplace.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, deathplace.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, deathplace.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, deathplace.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, deathplace.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, deathplace.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, deathplace.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, deathplace.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, deathplace.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, deathplace.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, deathplace.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, deathplace.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, deathplace.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, deathplace.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, deathplace.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, deathplace.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, deathplace.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, deathplace.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, deathplace.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, deathplace.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, deathplace.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, deathplace.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, deathplace.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, deathplace.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, deathplace.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, deathplace.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, deathplace.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, deathplace.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, deathplace.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, deathplace.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, deathplace.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, deathplace.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, deathplace.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, deathplace.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, deathplace.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, deathplace.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, deathplace.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, deathplace.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, deathplace.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, deathplace.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, deathplace.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, deathplace.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, deathplace.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, deathplace.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, deathplace.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, deathplace.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, deathplace.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, deathplace.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, deathplace.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, deathplace.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, deathplace.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, deathplace.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, deathplace.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, deathplace.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, deathplace.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, deathplace.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, deathplace.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, deathplace.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, deathplace.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, deathplace.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, deathplace.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, deathplace.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, deathplace.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, deathplace.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, deathplace.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, deathplace.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, deathplace.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, deathplace.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, deathplace.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, deathplace.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, deathplace.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, deathplace.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, deathplace.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, deathplace.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, deathplace.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, deathplace.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, deathplace.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, deathplace.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, deathplace.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, deathplace.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, deathplace.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, deathplace.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, deathplace.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, deathplace.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, deathplace.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, deathplace.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, deathplace.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, deathplace.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, deathplace.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, deathplace.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, deathplace.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, deathplace.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, deathplace.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, deathplace.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, deathplace.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, deathplace.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, deathplace.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := deathplace.HasMetadata()
		if !*i.HasMetadata {
			p = deathplace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathplace.HasMetadataWith(with...))
	}
	if i.HasDeathCertificates != nil {
		p := deathplace.HasDeathCertificates()
		if !*i.HasDeathCertificates {
			p = deathplace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeathCertificatesWith) > 0 {
		with := make([]predicate.DeathCertificate, 0, len(i.HasDeathCertificatesWith))
		for _, w := range i.HasDeathCertificatesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deathplace.HasDeathCertificatesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate DeathPlaceWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return deathplace.And(predicates...), nil
	}
}

// EthnicityWhereInput represents a where input for filtering Ethnicity queries.
type EthnicityWhereInput struct {
	Not *EthnicityWhereInput   `json:"not,omitempty"`
	Or  []*EthnicityWhereInput `json:"or,omitempty"`
	And []*EthnicityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "people" edge predicates.
	HasPeople     *bool               `json:"hasPeople,omitempty"`
	HasPeopleWith []*PersonWhereInput `json:"hasPeopleWith,omitempty"`
}

// Filter applies the EthnicityWhereInput filter on the EthnicityQuery builder.
func (i *EthnicityWhereInput) Filter(q *EthnicityQuery) (*EthnicityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering ethnicities.
// An error is returned if the input is empty or invalid.
func (i *EthnicityWhereInput) P() (predicate.Ethnicity, error) {
	var predicates []predicate.Ethnicity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, ethnicity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Ethnicity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, ethnicity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Ethnicity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, ethnicity.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, ethnicity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, ethnicity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, ethnicity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, ethnicity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, ethnicity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, ethnicity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, ethnicity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, ethnicity.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, ethnicity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, ethnicity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, ethnicity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, ethnicity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, ethnicity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, ethnicity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, ethnicity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, ethnicity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, ethnicity.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, ethnicity.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, ethnicity.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, ethnicity.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, ethnicity.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, ethnicity.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, ethnicity.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, ethnicity.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, ethnicity.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, ethnicity.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, ethnicity.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, ethnicity.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, ethnicity.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, ethnicity.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, ethnicity.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, ethnicity.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, ethnicity.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, ethnicity.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, ethnicity.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, ethnicity.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, ethnicity.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, ethnicity.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, ethnicity.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, ethnicity.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, ethnicity.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, ethnicity.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, ethnicity.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, ethnicity.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, ethnicity.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, ethnicity.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, ethnicity.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, ethnicity.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, ethnicity.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, ethnicity.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, ethnicity.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, ethnicity.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, ethnicity.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, ethnicity.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, ethnicity.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, ethnicity.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, ethnicity.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, ethnicity.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, ethnicity.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, ethnicity.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, ethnicity.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, ethnicity.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, ethnicity.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, ethnicity.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, ethnicity.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, ethnicity.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, ethnicity.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, ethnicity.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, ethnicity.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, ethnicity.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, ethnicity.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, ethnicity.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, ethnicity.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, ethnicity.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, ethnicity.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, ethnicity.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, ethnicity.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, ethnicity.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, ethnicity.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, ethnicity.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, ethnicity.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, ethnicity.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, ethnicity.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, ethnicity.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, ethnicity.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, ethnicity.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, ethnicity.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, ethnicity.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, ethnicity.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, ethnicity.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, ethnicity.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, ethnicity.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, ethnicity.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, ethnicity.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, ethnicity.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, ethnicity.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, ethnicity.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, ethnicity.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, ethnicity.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, ethnicity.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, ethnicity.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, ethnicity.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, ethnicity.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, ethnicity.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, ethnicity.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, ethnicity.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, ethnicity.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, ethnicity.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, ethnicity.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, ethnicity.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, ethnicity.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, ethnicity.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, ethnicity.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, ethnicity.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, ethnicity.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := ethnicity.HasMetadata()
		if !*i.HasMetadata {
			p = ethnicity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, ethnicity.HasMetadataWith(with...))
	}
	if i.HasPeople != nil {
		p := ethnicity.HasPeople()
		if !*i.HasPeople {
			p = ethnicity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeopleWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPeopleWith))
		for _, w := range i.HasPeopleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, ethnicity.HasPeopleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate EthnicityWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return ethnicity.And(predicates...), nil
	}
}

// GameServerWhereInput represents a where input for filtering GameServer queries.
type GameServerWhereInput struct {
	Not *GameServerWhereInput   `json:"not,omitempty"`
	Or  []*GameServerWhereInput `json:"or,omitempty"`
	And []*GameServerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "secret" field predicates.
	Secret             *string  `json:"secret,omitempty"`
	SecretNEQ          *string  `json:"secretNEQ,omitempty"`
	SecretIn           []string `json:"secretIn,omitempty"`
	SecretNotIn        []string `json:"secretNotIn,omitempty"`
	SecretGT           *string  `json:"secretGT,omitempty"`
	SecretGTE          *string  `json:"secretGTE,omitempty"`
	SecretLT           *string  `json:"secretLT,omitempty"`
	SecretLTE          *string  `json:"secretLTE,omitempty"`
	SecretContains     *string  `json:"secretContains,omitempty"`
	SecretHasPrefix    *string  `json:"secretHasPrefix,omitempty"`
	SecretHasSuffix    *string  `json:"secretHasSuffix,omitempty"`
	SecretIsNil        bool     `json:"secretIsNil,omitempty"`
	SecretNotNil       bool     `json:"secretNotNil,omitempty"`
	SecretEqualFold    *string  `json:"secretEqualFold,omitempty"`
	SecretContainsFold *string  `json:"secretContainsFold,omitempty"`

	// "ip_address" field predicates.
	IPAddress             *string  `json:"ipAddress,omitempty"`
	IPAddressNEQ          *string  `json:"ipAddressNEQ,omitempty"`
	IPAddressIn           []string `json:"ipAddressIn,omitempty"`
	IPAddressNotIn        []string `json:"ipAddressNotIn,omitempty"`
	IPAddressGT           *string  `json:"ipAddressGT,omitempty"`
	IPAddressGTE          *string  `json:"ipAddressGTE,omitempty"`
	IPAddressLT           *string  `json:"ipAddressLT,omitempty"`
	IPAddressLTE          *string  `json:"ipAddressLTE,omitempty"`
	IPAddressContains     *string  `json:"ipAddressContains,omitempty"`
	IPAddressHasPrefix    *string  `json:"ipAddressHasPrefix,omitempty"`
	IPAddressHasSuffix    *string  `json:"ipAddressHasSuffix,omitempty"`
	IPAddressEqualFold    *string  `json:"ipAddressEqualFold,omitempty"`
	IPAddressContainsFold *string  `json:"ipAddressContainsFold,omitempty"`

	// "monitoring" field predicates.
	Monitoring       *bool `json:"monitoring,omitempty"`
	MonitoringNEQ    *bool `json:"monitoringNEQ,omitempty"`
	MonitoringIsNil  bool  `json:"monitoringIsNil,omitempty"`
	MonitoringNotNil bool  `json:"monitoringNotNil,omitempty"`

	// "disabled_at" field predicates.
	DisabledAt       *time.Time  `json:"disabledAt,omitempty"`
	DisabledAtNEQ    *time.Time  `json:"disabledAtNEQ,omitempty"`
	DisabledAtIn     []time.Time `json:"disabledAtIn,omitempty"`
	DisabledAtNotIn  []time.Time `json:"disabledAtNotIn,omitempty"`
	DisabledAtGT     *time.Time  `json:"disabledAtGT,omitempty"`
	DisabledAtGTE    *time.Time  `json:"disabledAtGTE,omitempty"`
	DisabledAtLT     *time.Time  `json:"disabledAtLT,omitempty"`
	DisabledAtLTE    *time.Time  `json:"disabledAtLTE,omitempty"`
	DisabledAtIsNil  bool        `json:"disabledAtIsNil,omitempty"`
	DisabledAtNotNil bool        `json:"disabledAtNotNil,omitempty"`

	// "last_contact_at" field predicates.
	LastContactAt       *time.Time  `json:"lastContactAt,omitempty"`
	LastContactAtNEQ    *time.Time  `json:"lastContactAtNEQ,omitempty"`
	LastContactAtIn     []time.Time `json:"lastContactAtIn,omitempty"`
	LastContactAtNotIn  []time.Time `json:"lastContactAtNotIn,omitempty"`
	LastContactAtGT     *time.Time  `json:"lastContactAtGT,omitempty"`
	LastContactAtGTE    *time.Time  `json:"lastContactAtGTE,omitempty"`
	LastContactAtLT     *time.Time  `json:"lastContactAtLT,omitempty"`
	LastContactAtLTE    *time.Time  `json:"lastContactAtLTE,omitempty"`
	LastContactAtIsNil  bool        `json:"lastContactAtIsNil,omitempty"`
	LastContactAtNotNil bool        `json:"lastContactAtNotNil,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "players" edge predicates.
	HasPlayers     *bool               `json:"hasPlayers,omitempty"`
	HasPlayersWith []*PlayerWhereInput `json:"hasPlayersWith,omitempty"`
}

// Filter applies the GameServerWhereInput filter on the GameServerQuery builder.
func (i *GameServerWhereInput) Filter(q *GameServerQuery) (*GameServerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering gameservers.
// An error is returned if the input is empty or invalid.
func (i *GameServerWhereInput) P() (predicate.GameServer, error) {
	var predicates []predicate.GameServer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, gameserver.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GameServer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, gameserver.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GameServer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, gameserver.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, gameserver.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gameserver.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gameserver.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gameserver.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gameserver.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gameserver.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gameserver.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gameserver.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, gameserver.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, gameserver.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, gameserver.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, gameserver.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, gameserver.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, gameserver.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, gameserver.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, gameserver.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, gameserver.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, gameserver.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, gameserver.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, gameserver.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, gameserver.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, gameserver.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, gameserver.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, gameserver.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, gameserver.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, gameserver.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, gameserver.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, gameserver.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, gameserver.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, gameserver.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, gameserver.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, gameserver.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, gameserver.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, gameserver.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, gameserver.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, gameserver.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, gameserver.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, gameserver.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, gameserver.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, gameserver.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, gameserver.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, gameserver.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, gameserver.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, gameserver.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, gameserver.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, gameserver.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, gameserver.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, gameserver.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, gameserver.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, gameserver.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, gameserver.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, gameserver.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, gameserver.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, gameserver.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, gameserver.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, gameserver.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, gameserver.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, gameserver.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, gameserver.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, gameserver.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, gameserver.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, gameserver.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, gameserver.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, gameserver.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, gameserver.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, gameserver.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, gameserver.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, gameserver.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, gameserver.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, gameserver.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, gameserver.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, gameserver.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, gameserver.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, gameserver.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, gameserver.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, gameserver.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, gameserver.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, gameserver.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, gameserver.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, gameserver.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, gameserver.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, gameserver.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, gameserver.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, gameserver.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, gameserver.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, gameserver.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, gameserver.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, gameserver.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, gameserver.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, gameserver.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, gameserver.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, gameserver.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, gameserver.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, gameserver.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, gameserver.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, gameserver.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, gameserver.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, gameserver.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, gameserver.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, gameserver.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Secret != nil {
		predicates = append(predicates, gameserver.SecretEQ(*i.Secret))
	}
	if i.SecretNEQ != nil {
		predicates = append(predicates, gameserver.SecretNEQ(*i.SecretNEQ))
	}
	if len(i.SecretIn) > 0 {
		predicates = append(predicates, gameserver.SecretIn(i.SecretIn...))
	}
	if len(i.SecretNotIn) > 0 {
		predicates = append(predicates, gameserver.SecretNotIn(i.SecretNotIn...))
	}
	if i.SecretGT != nil {
		predicates = append(predicates, gameserver.SecretGT(*i.SecretGT))
	}
	if i.SecretGTE != nil {
		predicates = append(predicates, gameserver.SecretGTE(*i.SecretGTE))
	}
	if i.SecretLT != nil {
		predicates = append(predicates, gameserver.SecretLT(*i.SecretLT))
	}
	if i.SecretLTE != nil {
		predicates = append(predicates, gameserver.SecretLTE(*i.SecretLTE))
	}
	if i.SecretContains != nil {
		predicates = append(predicates, gameserver.SecretContains(*i.SecretContains))
	}
	if i.SecretHasPrefix != nil {
		predicates = append(predicates, gameserver.SecretHasPrefix(*i.SecretHasPrefix))
	}
	if i.SecretHasSuffix != nil {
		predicates = append(predicates, gameserver.SecretHasSuffix(*i.SecretHasSuffix))
	}
	if i.SecretIsNil {
		predicates = append(predicates, gameserver.SecretIsNil())
	}
	if i.SecretNotNil {
		predicates = append(predicates, gameserver.SecretNotNil())
	}
	if i.SecretEqualFold != nil {
		predicates = append(predicates, gameserver.SecretEqualFold(*i.SecretEqualFold))
	}
	if i.SecretContainsFold != nil {
		predicates = append(predicates, gameserver.SecretContainsFold(*i.SecretContainsFold))
	}
	if i.IPAddress != nil {
		predicates = append(predicates, gameserver.IPAddressEQ(*i.IPAddress))
	}
	if i.IPAddressNEQ != nil {
		predicates = append(predicates, gameserver.IPAddressNEQ(*i.IPAddressNEQ))
	}
	if len(i.IPAddressIn) > 0 {
		predicates = append(predicates, gameserver.IPAddressIn(i.IPAddressIn...))
	}
	if len(i.IPAddressNotIn) > 0 {
		predicates = append(predicates, gameserver.IPAddressNotIn(i.IPAddressNotIn...))
	}
	if i.IPAddressGT != nil {
		predicates = append(predicates, gameserver.IPAddressGT(*i.IPAddressGT))
	}
	if i.IPAddressGTE != nil {
		predicates = append(predicates, gameserver.IPAddressGTE(*i.IPAddressGTE))
	}
	if i.IPAddressLT != nil {
		predicates = append(predicates, gameserver.IPAddressLT(*i.IPAddressLT))
	}
	if i.IPAddressLTE != nil {
		predicates = append(predicates, gameserver.IPAddressLTE(*i.IPAddressLTE))
	}
	if i.IPAddressContains != nil {
		predicates = append(predicates, gameserver.IPAddressContains(*i.IPAddressContains))
	}
	if i.IPAddressHasPrefix != nil {
		predicates = append(predicates, gameserver.IPAddressHasPrefix(*i.IPAddressHasPrefix))
	}
	if i.IPAddressHasSuffix != nil {
		predicates = append(predicates, gameserver.IPAddressHasSuffix(*i.IPAddressHasSuffix))
	}
	if i.IPAddressEqualFold != nil {
		predicates = append(predicates, gameserver.IPAddressEqualFold(*i.IPAddressEqualFold))
	}
	if i.IPAddressContainsFold != nil {
		predicates = append(predicates, gameserver.IPAddressContainsFold(*i.IPAddressContainsFold))
	}
	if i.Monitoring != nil {
		predicates = append(predicates, gameserver.MonitoringEQ(*i.Monitoring))
	}
	if i.MonitoringNEQ != nil {
		predicates = append(predicates, gameserver.MonitoringNEQ(*i.MonitoringNEQ))
	}
	if i.MonitoringIsNil {
		predicates = append(predicates, gameserver.MonitoringIsNil())
	}
	if i.MonitoringNotNil {
		predicates = append(predicates, gameserver.MonitoringNotNil())
	}
	if i.DisabledAt != nil {
		predicates = append(predicates, gameserver.DisabledAtEQ(*i.DisabledAt))
	}
	if i.DisabledAtNEQ != nil {
		predicates = append(predicates, gameserver.DisabledAtNEQ(*i.DisabledAtNEQ))
	}
	if len(i.DisabledAtIn) > 0 {
		predicates = append(predicates, gameserver.DisabledAtIn(i.DisabledAtIn...))
	}
	if len(i.DisabledAtNotIn) > 0 {
		predicates = append(predicates, gameserver.DisabledAtNotIn(i.DisabledAtNotIn...))
	}
	if i.DisabledAtGT != nil {
		predicates = append(predicates, gameserver.DisabledAtGT(*i.DisabledAtGT))
	}
	if i.DisabledAtGTE != nil {
		predicates = append(predicates, gameserver.DisabledAtGTE(*i.DisabledAtGTE))
	}
	if i.DisabledAtLT != nil {
		predicates = append(predicates, gameserver.DisabledAtLT(*i.DisabledAtLT))
	}
	if i.DisabledAtLTE != nil {
		predicates = append(predicates, gameserver.DisabledAtLTE(*i.DisabledAtLTE))
	}
	if i.DisabledAtIsNil {
		predicates = append(predicates, gameserver.DisabledAtIsNil())
	}
	if i.DisabledAtNotNil {
		predicates = append(predicates, gameserver.DisabledAtNotNil())
	}
	if i.LastContactAt != nil {
		predicates = append(predicates, gameserver.LastContactAtEQ(*i.LastContactAt))
	}
	if i.LastContactAtNEQ != nil {
		predicates = append(predicates, gameserver.LastContactAtNEQ(*i.LastContactAtNEQ))
	}
	if len(i.LastContactAtIn) > 0 {
		predicates = append(predicates, gameserver.LastContactAtIn(i.LastContactAtIn...))
	}
	if len(i.LastContactAtNotIn) > 0 {
		predicates = append(predicates, gameserver.LastContactAtNotIn(i.LastContactAtNotIn...))
	}
	if i.LastContactAtGT != nil {
		predicates = append(predicates, gameserver.LastContactAtGT(*i.LastContactAtGT))
	}
	if i.LastContactAtGTE != nil {
		predicates = append(predicates, gameserver.LastContactAtGTE(*i.LastContactAtGTE))
	}
	if i.LastContactAtLT != nil {
		predicates = append(predicates, gameserver.LastContactAtLT(*i.LastContactAtLT))
	}
	if i.LastContactAtLTE != nil {
		predicates = append(predicates, gameserver.LastContactAtLTE(*i.LastContactAtLTE))
	}
	if i.LastContactAtIsNil {
		predicates = append(predicates, gameserver.LastContactAtIsNil())
	}
	if i.LastContactAtNotNil {
		predicates = append(predicates, gameserver.LastContactAtNotNil())
	}

	if i.HasMetadata != nil {
		p := gameserver.HasMetadata()
		if !*i.HasMetadata {
			p = gameserver.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, gameserver.HasMetadataWith(with...))
	}
	if i.HasPlayers != nil {
		p := gameserver.HasPlayers()
		if !*i.HasPlayers {
			p = gameserver.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlayersWith) > 0 {
		with := make([]predicate.Player, 0, len(i.HasPlayersWith))
		for _, w := range i.HasPlayersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, gameserver.HasPlayersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate GameServerWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return gameserver.And(predicates...), nil
	}
}

// MetadataWhereInput represents a where input for filtering Metadata queries.
type MetadataWhereInput struct {
	Not *MetadataWhereInput   `json:"not,omitempty"`
	Or  []*MetadataWhereInput `json:"or,omitempty"`
	And []*MetadataWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`
}

// Filter applies the MetadataWhereInput filter on the MetadataQuery builder.
func (i *MetadataWhereInput) Filter(q *MetadataQuery) (*MetadataQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering metadataslice.
// An error is returned if the input is empty or invalid.
func (i *MetadataWhereInput) P() (predicate.Metadata, error) {
	var predicates []predicate.Metadata
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, metadata.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Metadata, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, metadata.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Metadata, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, metadata.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, metadata.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, metadata.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, metadata.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, metadata.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, metadata.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, metadata.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, metadata.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, metadata.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, metadata.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, metadata.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, metadata.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, metadata.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, metadata.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, metadata.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, metadata.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, metadata.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, metadata.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, metadata.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, metadata.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, metadata.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, metadata.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, metadata.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, metadata.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, metadata.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, metadata.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, metadata.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, metadata.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, metadata.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, metadata.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, metadata.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, metadata.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, metadata.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, metadata.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, metadata.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, metadata.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, metadata.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, metadata.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, metadata.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, metadata.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, metadata.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, metadata.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, metadata.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, metadata.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, metadata.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, metadata.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, metadata.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, metadata.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, metadata.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, metadata.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, metadata.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, metadata.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, metadata.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, metadata.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, metadata.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, metadata.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, metadata.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, metadata.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, metadata.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, metadata.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, metadata.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, metadata.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, metadata.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, metadata.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, metadata.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, metadata.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, metadata.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, metadata.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, metadata.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, metadata.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, metadata.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, metadata.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, metadata.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, metadata.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, metadata.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate MetadataWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return metadata.And(predicates...), nil
	}
}

// OAuthConnectionWhereInput represents a where input for filtering OAuthConnection queries.
type OAuthConnectionWhereInput struct {
	Not *OAuthConnectionWhereInput   `json:"not,omitempty"`
	Or  []*OAuthConnectionWhereInput `json:"or,omitempty"`
	And []*OAuthConnectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "provider" field predicates.
	Provider             *string  `json:"provider,omitempty"`
	ProviderNEQ          *string  `json:"providerNEQ,omitempty"`
	ProviderIn           []string `json:"providerIn,omitempty"`
	ProviderNotIn        []string `json:"providerNotIn,omitempty"`
	ProviderGT           *string  `json:"providerGT,omitempty"`
	ProviderGTE          *string  `json:"providerGTE,omitempty"`
	ProviderLT           *string  `json:"providerLT,omitempty"`
	ProviderLTE          *string  `json:"providerLTE,omitempty"`
	ProviderContains     *string  `json:"providerContains,omitempty"`
	ProviderHasPrefix    *string  `json:"providerHasPrefix,omitempty"`
	ProviderHasSuffix    *string  `json:"providerHasSuffix,omitempty"`
	ProviderEqualFold    *string  `json:"providerEqualFold,omitempty"`
	ProviderContainsFold *string  `json:"providerContainsFold,omitempty"`

	// "provider_user_id" field predicates.
	ProviderUserID             *string  `json:"providerUserID,omitempty"`
	ProviderUserIDNEQ          *string  `json:"providerUserIDNEQ,omitempty"`
	ProviderUserIDIn           []string `json:"providerUserIDIn,omitempty"`
	ProviderUserIDNotIn        []string `json:"providerUserIDNotIn,omitempty"`
	ProviderUserIDGT           *string  `json:"providerUserIDGT,omitempty"`
	ProviderUserIDGTE          *string  `json:"providerUserIDGTE,omitempty"`
	ProviderUserIDLT           *string  `json:"providerUserIDLT,omitempty"`
	ProviderUserIDLTE          *string  `json:"providerUserIDLTE,omitempty"`
	ProviderUserIDContains     *string  `json:"providerUserIDContains,omitempty"`
	ProviderUserIDHasPrefix    *string  `json:"providerUserIDHasPrefix,omitempty"`
	ProviderUserIDHasSuffix    *string  `json:"providerUserIDHasSuffix,omitempty"`
	ProviderUserIDEqualFold    *string  `json:"providerUserIDEqualFold,omitempty"`
	ProviderUserIDContainsFold *string  `json:"providerUserIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// Filter applies the OAuthConnectionWhereInput filter on the OAuthConnectionQuery builder.
func (i *OAuthConnectionWhereInput) Filter(q *OAuthConnectionQuery) (*OAuthConnectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering oauthconnections.
// An error is returned if the input is empty or invalid.
func (i *OAuthConnectionWhereInput) P() (predicate.OAuthConnection, error) {
	var predicates []predicate.OAuthConnection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, oauthconnection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OAuthConnection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, oauthconnection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OAuthConnection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, oauthconnection.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, oauthconnection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oauthconnection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oauthconnection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oauthconnection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oauthconnection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oauthconnection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oauthconnection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oauthconnection.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, oauthconnection.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, oauthconnection.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, oauthconnection.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, oauthconnection.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, oauthconnection.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, oauthconnection.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, oauthconnection.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, oauthconnection.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, oauthconnection.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, oauthconnection.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, oauthconnection.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, oauthconnection.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, oauthconnection.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, oauthconnection.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, oauthconnection.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, oauthconnection.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, oauthconnection.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, oauthconnection.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, oauthconnection.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, oauthconnection.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, oauthconnection.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, oauthconnection.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, oauthconnection.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, oauthconnection.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, oauthconnection.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, oauthconnection.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, oauthconnection.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, oauthconnection.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, oauthconnection.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, oauthconnection.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, oauthconnection.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, oauthconnection.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, oauthconnection.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, oauthconnection.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, oauthconnection.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, oauthconnection.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Provider != nil {
		predicates = append(predicates, oauthconnection.ProviderEQ(*i.Provider))
	}
	if i.ProviderNEQ != nil {
		predicates = append(predicates, oauthconnection.ProviderNEQ(*i.ProviderNEQ))
	}
	if len(i.ProviderIn) > 0 {
		predicates = append(predicates, oauthconnection.ProviderIn(i.ProviderIn...))
	}
	if len(i.ProviderNotIn) > 0 {
		predicates = append(predicates, oauthconnection.ProviderNotIn(i.ProviderNotIn...))
	}
	if i.ProviderGT != nil {
		predicates = append(predicates, oauthconnection.ProviderGT(*i.ProviderGT))
	}
	if i.ProviderGTE != nil {
		predicates = append(predicates, oauthconnection.ProviderGTE(*i.ProviderGTE))
	}
	if i.ProviderLT != nil {
		predicates = append(predicates, oauthconnection.ProviderLT(*i.ProviderLT))
	}
	if i.ProviderLTE != nil {
		predicates = append(predicates, oauthconnection.ProviderLTE(*i.ProviderLTE))
	}
	if i.ProviderContains != nil {
		predicates = append(predicates, oauthconnection.ProviderContains(*i.ProviderContains))
	}
	if i.ProviderHasPrefix != nil {
		predicates = append(predicates, oauthconnection.ProviderHasPrefix(*i.ProviderHasPrefix))
	}
	if i.ProviderHasSuffix != nil {
		predicates = append(predicates, oauthconnection.ProviderHasSuffix(*i.ProviderHasSuffix))
	}
	if i.ProviderEqualFold != nil {
		predicates = append(predicates, oauthconnection.ProviderEqualFold(*i.ProviderEqualFold))
	}
	if i.ProviderContainsFold != nil {
		predicates = append(predicates, oauthconnection.ProviderContainsFold(*i.ProviderContainsFold))
	}
	if i.ProviderUserID != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDEQ(*i.ProviderUserID))
	}
	if i.ProviderUserIDNEQ != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDNEQ(*i.ProviderUserIDNEQ))
	}
	if len(i.ProviderUserIDIn) > 0 {
		predicates = append(predicates, oauthconnection.ProviderUserIDIn(i.ProviderUserIDIn...))
	}
	if len(i.ProviderUserIDNotIn) > 0 {
		predicates = append(predicates, oauthconnection.ProviderUserIDNotIn(i.ProviderUserIDNotIn...))
	}
	if i.ProviderUserIDGT != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDGT(*i.ProviderUserIDGT))
	}
	if i.ProviderUserIDGTE != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDGTE(*i.ProviderUserIDGTE))
	}
	if i.ProviderUserIDLT != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDLT(*i.ProviderUserIDLT))
	}
	if i.ProviderUserIDLTE != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDLTE(*i.ProviderUserIDLTE))
	}
	if i.ProviderUserIDContains != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDContains(*i.ProviderUserIDContains))
	}
	if i.ProviderUserIDHasPrefix != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDHasPrefix(*i.ProviderUserIDHasPrefix))
	}
	if i.ProviderUserIDHasSuffix != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDHasSuffix(*i.ProviderUserIDHasSuffix))
	}
	if i.ProviderUserIDEqualFold != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDEqualFold(*i.ProviderUserIDEqualFold))
	}
	if i.ProviderUserIDContainsFold != nil {
		predicates = append(predicates, oauthconnection.ProviderUserIDContainsFold(*i.ProviderUserIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, oauthconnection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, oauthconnection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, oauthconnection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, oauthconnection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, oauthconnection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, oauthconnection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, oauthconnection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, oauthconnection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, oauthconnection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, oauthconnection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, oauthconnection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, oauthconnection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, oauthconnection.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasUser != nil {
		p := oauthconnection.HasUser()
		if !*i.HasUser {
			p = oauthconnection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, oauthconnection.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate OAuthConnectionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return oauthconnection.And(predicates...), nil
	}
}

// PersonWhereInput represents a where input for filtering Person queries.
type PersonWhereInput struct {
	Not *PersonWhereInput   `json:"not,omitempty"`
	Or  []*PersonWhereInput `json:"or,omitempty"`
	And []*PersonWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "middle_name" field predicates.
	MiddleName             *string  `json:"middleName,omitempty"`
	MiddleNameNEQ          *string  `json:"middleNameNEQ,omitempty"`
	MiddleNameIn           []string `json:"middleNameIn,omitempty"`
	MiddleNameNotIn        []string `json:"middleNameNotIn,omitempty"`
	MiddleNameGT           *string  `json:"middleNameGT,omitempty"`
	MiddleNameGTE          *string  `json:"middleNameGTE,omitempty"`
	MiddleNameLT           *string  `json:"middleNameLT,omitempty"`
	MiddleNameLTE          *string  `json:"middleNameLTE,omitempty"`
	MiddleNameContains     *string  `json:"middleNameContains,omitempty"`
	MiddleNameHasPrefix    *string  `json:"middleNameHasPrefix,omitempty"`
	MiddleNameHasSuffix    *string  `json:"middleNameHasSuffix,omitempty"`
	MiddleNameIsNil        bool     `json:"middleNameIsNil,omitempty"`
	MiddleNameNotNil       bool     `json:"middleNameNotNil,omitempty"`
	MiddleNameEqualFold    *string  `json:"middleNameEqualFold,omitempty"`
	MiddleNameContainsFold *string  `json:"middleNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "suffix" field predicates.
	Suffix             *string  `json:"suffix,omitempty"`
	SuffixNEQ          *string  `json:"suffixNEQ,omitempty"`
	SuffixIn           []string `json:"suffixIn,omitempty"`
	SuffixNotIn        []string `json:"suffixNotIn,omitempty"`
	SuffixGT           *string  `json:"suffixGT,omitempty"`
	SuffixGTE          *string  `json:"suffixGTE,omitempty"`
	SuffixLT           *string  `json:"suffixLT,omitempty"`
	SuffixLTE          *string  `json:"suffixLTE,omitempty"`
	SuffixContains     *string  `json:"suffixContains,omitempty"`
	SuffixHasPrefix    *string  `json:"suffixHasPrefix,omitempty"`
	SuffixHasSuffix    *string  `json:"suffixHasSuffix,omitempty"`
	SuffixIsNil        bool     `json:"suffixIsNil,omitempty"`
	SuffixNotNil       bool     `json:"suffixNotNil,omitempty"`
	SuffixEqualFold    *string  `json:"suffixEqualFold,omitempty"`
	SuffixContainsFold *string  `json:"suffixContainsFold,omitempty"`

	// "date_of_birth" field predicates.
	DateOfBirth       *time.Time  `json:"dateOfBirth,omitempty"`
	DateOfBirthNEQ    *time.Time  `json:"dateOfBirthNEQ,omitempty"`
	DateOfBirthIn     []time.Time `json:"dateOfBirthIn,omitempty"`
	DateOfBirthNotIn  []time.Time `json:"dateOfBirthNotIn,omitempty"`
	DateOfBirthGT     *time.Time  `json:"dateOfBirthGT,omitempty"`
	DateOfBirthGTE    *time.Time  `json:"dateOfBirthGTE,omitempty"`
	DateOfBirthLT     *time.Time  `json:"dateOfBirthLT,omitempty"`
	DateOfBirthLTE    *time.Time  `json:"dateOfBirthLTE,omitempty"`
	DateOfBirthIsNil  bool        `json:"dateOfBirthIsNil,omitempty"`
	DateOfBirthNotNil bool        `json:"dateOfBirthNotNil,omitempty"`

	// "birthplace" field predicates.
	Birthplace             *string  `json:"birthplace,omitempty"`
	BirthplaceNEQ          *string  `json:"birthplaceNEQ,omitempty"`
	BirthplaceIn           []string `json:"birthplaceIn,omitempty"`
	BirthplaceNotIn        []string `json:"birthplaceNotIn,omitempty"`
	BirthplaceGT           *string  `json:"birthplaceGT,omitempty"`
	BirthplaceGTE          *string  `json:"birthplaceGTE,omitempty"`
	BirthplaceLT           *string  `json:"birthplaceLT,omitempty"`
	BirthplaceLTE          *string  `json:"birthplaceLTE,omitempty"`
	BirthplaceContains     *string  `json:"birthplaceContains,omitempty"`
	BirthplaceHasPrefix    *string  `json:"birthplaceHasPrefix,omitempty"`
	BirthplaceHasSuffix    *string  `json:"birthplaceHasSuffix,omitempty"`
	BirthplaceIsNil        bool     `json:"birthplaceIsNil,omitempty"`
	BirthplaceNotNil       bool     `json:"birthplaceNotNil,omitempty"`
	BirthplaceEqualFold    *string  `json:"birthplaceEqualFold,omitempty"`
	BirthplaceContainsFold *string  `json:"birthplaceContainsFold,omitempty"`

	// "deceased_at" field predicates.
	DeceasedAt       *time.Time  `json:"deceasedAt,omitempty"`
	DeceasedAtNEQ    *time.Time  `json:"deceasedAtNEQ,omitempty"`
	DeceasedAtIn     []time.Time `json:"deceasedAtIn,omitempty"`
	DeceasedAtNotIn  []time.Time `json:"deceasedAtNotIn,omitempty"`
	DeceasedAtGT     *time.Time  `json:"deceasedAtGT,omitempty"`
	DeceasedAtGTE    *time.Time  `json:"deceasedAtGTE,omitempty"`
	DeceasedAtLT     *time.Time  `json:"deceasedAtLT,omitempty"`
	DeceasedAtLTE    *time.Time  `json:"deceasedAtLTE,omitempty"`
	DeceasedAtIsNil  bool        `json:"deceasedAtIsNil,omitempty"`
	DeceasedAtNotNil bool        `json:"deceasedAtNotNil,omitempty"`

	// "archived_at" field predicates.
	ArchivedAt       *time.Time  `json:"archivedAt,omitempty"`
	ArchivedAtNEQ    *time.Time  `json:"archivedAtNEQ,omitempty"`
	ArchivedAtIn     []time.Time `json:"archivedAtIn,omitempty"`
	ArchivedAtNotIn  []time.Time `json:"archivedAtNotIn,omitempty"`
	ArchivedAtGT     *time.Time  `json:"archivedAtGT,omitempty"`
	ArchivedAtGTE    *time.Time  `json:"archivedAtGTE,omitempty"`
	ArchivedAtLT     *time.Time  `json:"archivedAtLT,omitempty"`
	ArchivedAtLTE    *time.Time  `json:"archivedAtLTE,omitempty"`
	ArchivedAtIsNil  bool        `json:"archivedAtIsNil,omitempty"`
	ArchivedAtNotNil bool        `json:"archivedAtNotNil,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "vehicle_registrations" edge predicates.
	HasVehicleRegistrations     *bool                            `json:"hasVehicleRegistrations,omitempty"`
	HasVehicleRegistrationsWith []*VehicleRegistrationWhereInput `json:"hasVehicleRegistrationsWith,omitempty"`

	// "race" edge predicates.
	HasRace     *bool             `json:"hasRace,omitempty"`
	HasRaceWith []*RaceWhereInput `json:"hasRaceWith,omitempty"`

	// "ethnicity" edge predicates.
	HasEthnicity     *bool                  `json:"hasEthnicity,omitempty"`
	HasEthnicityWith []*EthnicityWhereInput `json:"hasEthnicityWith,omitempty"`

	// "sex" edge predicates.
	HasSex     *bool            `json:"hasSex,omitempty"`
	HasSexWith []*SexWhereInput `json:"hasSexWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "death_certificate" edge predicates.
	HasDeathCertificate     *bool                         `json:"hasDeathCertificate,omitempty"`
	HasDeathCertificateWith []*DeathCertificateWhereInput `json:"hasDeathCertificateWith,omitempty"`

	// "certified_deaths" edge predicates.
	HasCertifiedDeaths     *bool                         `json:"hasCertifiedDeaths,omitempty"`
	HasCertifiedDeathsWith []*DeathCertificateWhereInput `json:"hasCertifiedDeathsWith,omitempty"`
}

// Filter applies the PersonWhereInput filter on the PersonQuery builder.
func (i *PersonWhereInput) Filter(q *PersonQuery) (*PersonQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering persons.
// An error is returned if the input is empty or invalid.
func (i *PersonWhereInput) P() (predicate.Person, error) {
	var predicates []predicate.Person
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, person.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Person, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, person.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Person, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, person.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, person.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, person.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, person.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, person.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, person.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, person.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, person.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, person.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, person.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, person.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, person.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, person.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, person.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, person.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, person.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, person.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, person.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, person.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, person.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, person.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, person.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, person.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, person.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, person.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, person.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, person.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, person.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, person.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, person.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, person.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, person.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, person.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, person.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, person.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, person.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, person.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, person.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, person.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, person.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, person.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, person.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, person.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, person.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, person.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, person.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, person.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, person.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, person.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, person.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, person.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, person.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, person.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, person.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, person.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, person.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, person.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, person.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, person.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, person.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, person.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, person.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, person.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, person.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, person.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, person.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, person.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, person.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, person.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, person.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, person.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, person.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, person.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, person.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, person.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, person.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, person.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, person.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, person.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, person.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, person.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, person.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, person.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, person.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, person.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, person.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, person.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, person.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, person.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, person.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.MiddleName != nil {
		predicates = append(predicates, person.MiddleNameEQ(*i.MiddleName))
	}
	if i.MiddleNameNEQ != nil {
		predicates = append(predicates, person.MiddleNameNEQ(*i.MiddleNameNEQ))
	}
	if len(i.MiddleNameIn) > 0 {
		predicates = append(predicates, person.MiddleNameIn(i.MiddleNameIn...))
	}
	if len(i.MiddleNameNotIn) > 0 {
		predicates = append(predicates, person.MiddleNameNotIn(i.MiddleNameNotIn...))
	}
	if i.MiddleNameGT != nil {
		predicates = append(predicates, person.MiddleNameGT(*i.MiddleNameGT))
	}
	if i.MiddleNameGTE != nil {
		predicates = append(predicates, person.MiddleNameGTE(*i.MiddleNameGTE))
	}
	if i.MiddleNameLT != nil {
		predicates = append(predicates, person.MiddleNameLT(*i.MiddleNameLT))
	}
	if i.MiddleNameLTE != nil {
		predicates = append(predicates, person.MiddleNameLTE(*i.MiddleNameLTE))
	}
	if i.MiddleNameContains != nil {
		predicates = append(predicates, person.MiddleNameContains(*i.MiddleNameContains))
	}
	if i.MiddleNameHasPrefix != nil {
		predicates = append(predicates, person.MiddleNameHasPrefix(*i.MiddleNameHasPrefix))
	}
	if i.MiddleNameHasSuffix != nil {
		predicates = append(predicates, person.MiddleNameHasSuffix(*i.MiddleNameHasSuffix))
	}
	if i.MiddleNameIsNil {
		predicates = append(predicates, person.MiddleNameIsNil())
	}
	if i.MiddleNameNotNil {
		predicates = append(predicates, person.MiddleNameNotNil())
	}
	if i.MiddleNameEqualFold != nil {
		predicates = append(predicates, person.MiddleNameEqualFold(*i.MiddleNameEqualFold))
	}
	if i.MiddleNameContainsFold != nil {
		predicates = append(predicates, person.MiddleNameContainsFold(*i.MiddleNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, person.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, person.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, person.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, person.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, person.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, person.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, person.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, person.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, person.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, person.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, person.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, person.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, person.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, person.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, person.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Suffix != nil {
		predicates = append(predicates, person.SuffixEQ(*i.Suffix))
	}
	if i.SuffixNEQ != nil {
		predicates = append(predicates, person.SuffixNEQ(*i.SuffixNEQ))
	}
	if len(i.SuffixIn) > 0 {
		predicates = append(predicates, person.SuffixIn(i.SuffixIn...))
	}
	if len(i.SuffixNotIn) > 0 {
		predicates = append(predicates, person.SuffixNotIn(i.SuffixNotIn...))
	}
	if i.SuffixGT != nil {
		predicates = append(predicates, person.SuffixGT(*i.SuffixGT))
	}
	if i.SuffixGTE != nil {
		predicates = append(predicates, person.SuffixGTE(*i.SuffixGTE))
	}
	if i.SuffixLT != nil {
		predicates = append(predicates, person.SuffixLT(*i.SuffixLT))
	}
	if i.SuffixLTE != nil {
		predicates = append(predicates, person.SuffixLTE(*i.SuffixLTE))
	}
	if i.SuffixContains != nil {
		predicates = append(predicates, person.SuffixContains(*i.SuffixContains))
	}
	if i.SuffixHasPrefix != nil {
		predicates = append(predicates, person.SuffixHasPrefix(*i.SuffixHasPrefix))
	}
	if i.SuffixHasSuffix != nil {
		predicates = append(predicates, person.SuffixHasSuffix(*i.SuffixHasSuffix))
	}
	if i.SuffixIsNil {
		predicates = append(predicates, person.SuffixIsNil())
	}
	if i.SuffixNotNil {
		predicates = append(predicates, person.SuffixNotNil())
	}
	if i.SuffixEqualFold != nil {
		predicates = append(predicates, person.SuffixEqualFold(*i.SuffixEqualFold))
	}
	if i.SuffixContainsFold != nil {
		predicates = append(predicates, person.SuffixContainsFold(*i.SuffixContainsFold))
	}
	if i.DateOfBirth != nil {
		predicates = append(predicates, person.DateOfBirthEQ(*i.DateOfBirth))
	}
	if i.DateOfBirthNEQ != nil {
		predicates = append(predicates, person.DateOfBirthNEQ(*i.DateOfBirthNEQ))
	}
	if len(i.DateOfBirthIn) > 0 {
		predicates = append(predicates, person.DateOfBirthIn(i.DateOfBirthIn...))
	}
	if len(i.DateOfBirthNotIn) > 0 {
		predicates = append(predicates, person.DateOfBirthNotIn(i.DateOfBirthNotIn...))
	}
	if i.DateOfBirthGT != nil {
		predicates = append(predicates, person.DateOfBirthGT(*i.DateOfBirthGT))
	}
	if i.DateOfBirthGTE != nil {
		predicates = append(predicates, person.DateOfBirthGTE(*i.DateOfBirthGTE))
	}
	if i.DateOfBirthLT != nil {
		predicates = append(predicates, person.DateOfBirthLT(*i.DateOfBirthLT))
	}
	if i.DateOfBirthLTE != nil {
		predicates = append(predicates, person.DateOfBirthLTE(*i.DateOfBirthLTE))
	}
	if i.DateOfBirthIsNil {
		predicates = append(predicates, person.DateOfBirthIsNil())
	}
	if i.DateOfBirthNotNil {
		predicates = append(predicates, person.DateOfBirthNotNil())
	}
	if i.Birthplace != nil {
		predicates = append(predicates, person.BirthplaceEQ(*i.Birthplace))
	}
	if i.BirthplaceNEQ != nil {
		predicates = append(predicates, person.BirthplaceNEQ(*i.BirthplaceNEQ))
	}
	if len(i.BirthplaceIn) > 0 {
		predicates = append(predicates, person.BirthplaceIn(i.BirthplaceIn...))
	}
	if len(i.BirthplaceNotIn) > 0 {
		predicates = append(predicates, person.BirthplaceNotIn(i.BirthplaceNotIn...))
	}
	if i.BirthplaceGT != nil {
		predicates = append(predicates, person.BirthplaceGT(*i.BirthplaceGT))
	}
	if i.BirthplaceGTE != nil {
		predicates = append(predicates, person.BirthplaceGTE(*i.BirthplaceGTE))
	}
	if i.BirthplaceLT != nil {
		predicates = append(predicates, person.BirthplaceLT(*i.BirthplaceLT))
	}
	if i.BirthplaceLTE != nil {
		predicates = append(predicates, person.BirthplaceLTE(*i.BirthplaceLTE))
	}
	if i.BirthplaceContains != nil {
		predicates = append(predicates, person.BirthplaceContains(*i.BirthplaceContains))
	}
	if i.BirthplaceHasPrefix != nil {
		predicates = append(predicates, person.BirthplaceHasPrefix(*i.BirthplaceHasPrefix))
	}
	if i.BirthplaceHasSuffix != nil {
		predicates = append(predicates, person.BirthplaceHasSuffix(*i.BirthplaceHasSuffix))
	}
	if i.BirthplaceIsNil {
		predicates = append(predicates, person.BirthplaceIsNil())
	}
	if i.BirthplaceNotNil {
		predicates = append(predicates, person.BirthplaceNotNil())
	}
	if i.BirthplaceEqualFold != nil {
		predicates = append(predicates, person.BirthplaceEqualFold(*i.BirthplaceEqualFold))
	}
	if i.BirthplaceContainsFold != nil {
		predicates = append(predicates, person.BirthplaceContainsFold(*i.BirthplaceContainsFold))
	}
	if i.DeceasedAt != nil {
		predicates = append(predicates, person.DeceasedAtEQ(*i.DeceasedAt))
	}
	if i.DeceasedAtNEQ != nil {
		predicates = append(predicates, person.DeceasedAtNEQ(*i.DeceasedAtNEQ))
	}
	if len(i.DeceasedAtIn) > 0 {
		predicates = append(predicates, person.DeceasedAtIn(i.DeceasedAtIn...))
	}
	if len(i.DeceasedAtNotIn) > 0 {
		predicates = append(predicates, person.DeceasedAtNotIn(i.DeceasedAtNotIn...))
	}
	if i.DeceasedAtGT != nil {
		predicates = append(predicates, person.DeceasedAtGT(*i.DeceasedAtGT))
	}
	if i.DeceasedAtGTE != nil {
		predicates = append(predicates, person.DeceasedAtGTE(*i.DeceasedAtGTE))
	}
	if i.DeceasedAtLT != nil {
		predicates = append(predicates, person.DeceasedAtLT(*i.DeceasedAtLT))
	}
	if i.DeceasedAtLTE != nil {
		predicates = append(predicates, person.DeceasedAtLTE(*i.DeceasedAtLTE))
	}
	if i.DeceasedAtIsNil {
		predicates = append(predicates, person.DeceasedAtIsNil())
	}
	if i.DeceasedAtNotNil {
		predicates = append(predicates, person.DeceasedAtNotNil())
	}
	if i.ArchivedAt != nil {
		predicates = append(predicates, person.ArchivedAtEQ(*i.ArchivedAt))
	}
	if i.ArchivedAtNEQ != nil {
		predicates = append(predicates, person.ArchivedAtNEQ(*i.ArchivedAtNEQ))
	}
	if len(i.ArchivedAtIn) > 0 {
		predicates = append(predicates, person.ArchivedAtIn(i.ArchivedAtIn...))
	}
	if len(i.ArchivedAtNotIn) > 0 {
		predicates = append(predicates, person.ArchivedAtNotIn(i.ArchivedAtNotIn...))
	}
	if i.ArchivedAtGT != nil {
		predicates = append(predicates, person.ArchivedAtGT(*i.ArchivedAtGT))
	}
	if i.ArchivedAtGTE != nil {
		predicates = append(predicates, person.ArchivedAtGTE(*i.ArchivedAtGTE))
	}
	if i.ArchivedAtLT != nil {
		predicates = append(predicates, person.ArchivedAtLT(*i.ArchivedAtLT))
	}
	if i.ArchivedAtLTE != nil {
		predicates = append(predicates, person.ArchivedAtLTE(*i.ArchivedAtLTE))
	}
	if i.ArchivedAtIsNil {
		predicates = append(predicates, person.ArchivedAtIsNil())
	}
	if i.ArchivedAtNotNil {
		predicates = append(predicates, person.ArchivedAtNotNil())
	}

	if i.HasMetadata != nil {
		p := person.HasMetadata()
		if !*i.HasMetadata {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasMetadataWith(with...))
	}
	if i.HasVehicleRegistrations != nil {
		p := person.HasVehicleRegistrations()
		if !*i.HasVehicleRegistrations {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleRegistrationsWith) > 0 {
		with := make([]predicate.VehicleRegistration, 0, len(i.HasVehicleRegistrationsWith))
		for _, w := range i.HasVehicleRegistrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasVehicleRegistrationsWith(with...))
	}
	if i.HasRace != nil {
		p := person.HasRace()
		if !*i.HasRace {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRaceWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRaceWith))
		for _, w := range i.HasRaceWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasRaceWith(with...))
	}
	if i.HasEthnicity != nil {
		p := person.HasEthnicity()
		if !*i.HasEthnicity {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEthnicityWith) > 0 {
		with := make([]predicate.Ethnicity, 0, len(i.HasEthnicityWith))
		for _, w := range i.HasEthnicityWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasEthnicityWith(with...))
	}
	if i.HasSex != nil {
		p := person.HasSex()
		if !*i.HasSex {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSexWith) > 0 {
		with := make([]predicate.Sex, 0, len(i.HasSexWith))
		for _, w := range i.HasSexWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasSexWith(with...))
	}
	if i.HasUser != nil {
		p := person.HasUser()
		if !*i.HasUser {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasUserWith(with...))
	}
	if i.HasDeathCertificate != nil {
		p := person.HasDeathCertificate()
		if !*i.HasDeathCertificate {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeathCertificateWith) > 0 {
		with := make([]predicate.DeathCertificate, 0, len(i.HasDeathCertificateWith))
		for _, w := range i.HasDeathCertificateWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasDeathCertificateWith(with...))
	}
	if i.HasCertifiedDeaths != nil {
		p := person.HasCertifiedDeaths()
		if !*i.HasCertifiedDeaths {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCertifiedDeathsWith) > 0 {
		with := make([]predicate.DeathCertificate, 0, len(i.HasCertifiedDeathsWith))
		for _, w := range i.HasCertifiedDeathsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasCertifiedDeathsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate PersonWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return person.And(predicates...), nil
	}
}

// PlayerWhereInput represents a where input for filtering Player queries.
type PlayerWhereInput struct {
	Not *PlayerWhereInput   `json:"not,omitempty"`
	Or  []*PlayerWhereInput `json:"or,omitempty"`
	And []*PlayerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "servers" edge predicates.
	HasServers     *bool                   `json:"hasServers,omitempty"`
	HasServersWith []*GameServerWhereInput `json:"hasServersWith,omitempty"`

	// "identifiers" edge predicates.
	HasIdentifiers     *bool                         `json:"hasIdentifiers,omitempty"`
	HasIdentifiersWith []*PlayerIdentifierWhereInput `json:"hasIdentifiersWith,omitempty"`
}

// Filter applies the PlayerWhereInput filter on the PlayerQuery builder.
func (i *PlayerWhereInput) Filter(q *PlayerQuery) (*PlayerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering players.
// An error is returned if the input is empty or invalid.
func (i *PlayerWhereInput) P() (predicate.Player, error) {
	var predicates []predicate.Player
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, player.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Player, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, player.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Player, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, player.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, player.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, player.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, player.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, player.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, player.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, player.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, player.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, player.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, player.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, player.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, player.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, player.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, player.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, player.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, player.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, player.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, player.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, player.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, player.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, player.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, player.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, player.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, player.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, player.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, player.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, player.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, player.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, player.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, player.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, player.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, player.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, player.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, player.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, player.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, player.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, player.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, player.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, player.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, player.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, player.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, player.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, player.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, player.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, player.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, player.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, player.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, player.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, player.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, player.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, player.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, player.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, player.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, player.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, player.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, player.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, player.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, player.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, player.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, player.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, player.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, player.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, player.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, player.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, player.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, player.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, player.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, player.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, player.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, player.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, player.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, player.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, player.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, player.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, player.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, player.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, player.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, player.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, player.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, player.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, player.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, player.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, player.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, player.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, player.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, player.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, player.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, player.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasMetadata != nil {
		p := player.HasMetadata()
		if !*i.HasMetadata {
			p = player.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, player.HasMetadataWith(with...))
	}
	if i.HasServers != nil {
		p := player.HasServers()
		if !*i.HasServers {
			p = player.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServersWith) > 0 {
		with := make([]predicate.GameServer, 0, len(i.HasServersWith))
		for _, w := range i.HasServersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, player.HasServersWith(with...))
	}
	if i.HasIdentifiers != nil {
		p := player.HasIdentifiers()
		if !*i.HasIdentifiers {
			p = player.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIdentifiersWith) > 0 {
		with := make([]predicate.PlayerIdentifier, 0, len(i.HasIdentifiersWith))
		for _, w := range i.HasIdentifiersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, player.HasIdentifiersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate PlayerWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return player.And(predicates...), nil
	}
}

// PlayerIdentifierWhereInput represents a where input for filtering PlayerIdentifier queries.
type PlayerIdentifierWhereInput struct {
	Not *PlayerIdentifierWhereInput   `json:"not,omitempty"`
	Or  []*PlayerIdentifierWhereInput `json:"or,omitempty"`
	And []*PlayerIdentifierWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "player" edge predicates.
	HasPlayer     *bool               `json:"hasPlayer,omitempty"`
	HasPlayerWith []*PlayerWhereInput `json:"hasPlayerWith,omitempty"`
}

// Filter applies the PlayerIdentifierWhereInput filter on the PlayerIdentifierQuery builder.
func (i *PlayerIdentifierWhereInput) Filter(q *PlayerIdentifierQuery) (*PlayerIdentifierQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering playeridentifiers.
// An error is returned if the input is empty or invalid.
func (i *PlayerIdentifierWhereInput) P() (predicate.PlayerIdentifier, error) {
	var predicates []predicate.PlayerIdentifier
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, playeridentifier.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PlayerIdentifier, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, playeridentifier.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PlayerIdentifier, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, playeridentifier.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, playeridentifier.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, playeridentifier.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, playeridentifier.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, playeridentifier.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, playeridentifier.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, playeridentifier.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, playeridentifier.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, playeridentifier.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, playeridentifier.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, playeridentifier.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, playeridentifier.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, playeridentifier.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, playeridentifier.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, playeridentifier.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, playeridentifier.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, playeridentifier.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, playeridentifier.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, playeridentifier.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, playeridentifier.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, playeridentifier.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, playeridentifier.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, playeridentifier.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, playeridentifier.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, playeridentifier.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, playeridentifier.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, playeridentifier.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, playeridentifier.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, playeridentifier.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, playeridentifier.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, playeridentifier.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, playeridentifier.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, playeridentifier.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, playeridentifier.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, playeridentifier.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, playeridentifier.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, playeridentifier.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, playeridentifier.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, playeridentifier.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, playeridentifier.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, playeridentifier.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, playeridentifier.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, playeridentifier.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, playeridentifier.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, playeridentifier.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, playeridentifier.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, playeridentifier.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, playeridentifier.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, playeridentifier.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, playeridentifier.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, playeridentifier.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, playeridentifier.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, playeridentifier.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, playeridentifier.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, playeridentifier.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, playeridentifier.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, playeridentifier.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, playeridentifier.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, playeridentifier.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, playeridentifier.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, playeridentifier.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, playeridentifier.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, playeridentifier.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, playeridentifier.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, playeridentifier.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, playeridentifier.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, playeridentifier.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, playeridentifier.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, playeridentifier.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, playeridentifier.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, playeridentifier.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, playeridentifier.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, playeridentifier.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, playeridentifier.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, playeridentifier.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, playeridentifier.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, playeridentifier.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, playeridentifier.ValueContainsFold(*i.ValueContainsFold))
	}

	if i.HasPlayer != nil {
		p := playeridentifier.HasPlayer()
		if !*i.HasPlayer {
			p = playeridentifier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlayerWith) > 0 {
		with := make([]predicate.Player, 0, len(i.HasPlayerWith))
		for _, w := range i.HasPlayerWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, playeridentifier.HasPlayerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate PlayerIdentifierWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return playeridentifier.And(predicates...), nil
	}
}

// RaceWhereInput represents a where input for filtering Race queries.
type RaceWhereInput struct {
	Not *RaceWhereInput   `json:"not,omitempty"`
	Or  []*RaceWhereInput `json:"or,omitempty"`
	And []*RaceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "people" edge predicates.
	HasPeople     *bool               `json:"hasPeople,omitempty"`
	HasPeopleWith []*PersonWhereInput `json:"hasPeopleWith,omitempty"`
}

// Filter applies the RaceWhereInput filter on the RaceQuery builder.
func (i *RaceWhereInput) Filter(q *RaceQuery) (*RaceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering races.
// An error is returned if the input is empty or invalid.
func (i *RaceWhereInput) P() (predicate.Race, error) {
	var predicates []predicate.Race
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, race.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Race, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, race.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Race, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, race.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, race.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, race.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, race.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, race.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, race.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, race.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, race.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, race.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, race.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, race.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, race.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, race.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, race.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, race.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, race.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, race.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, race.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, race.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, race.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, race.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, race.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, race.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, race.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, race.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, race.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, race.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, race.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, race.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, race.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, race.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, race.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, race.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, race.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, race.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, race.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, race.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, race.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, race.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, race.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, race.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, race.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, race.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, race.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, race.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, race.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, race.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, race.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, race.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, race.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, race.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, race.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, race.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, race.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, race.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, race.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, race.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, race.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, race.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, race.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, race.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, race.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, race.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, race.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, race.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, race.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, race.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, race.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, race.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, race.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, race.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, race.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, race.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, race.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, race.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, race.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, race.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, race.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, race.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, race.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, race.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, race.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, race.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, race.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, race.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, race.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, race.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, race.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, race.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, race.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, race.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, race.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, race.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, race.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, race.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, race.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, race.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, race.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, race.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, race.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, race.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, race.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, race.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, race.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, race.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, race.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, race.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, race.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, race.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, race.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, race.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, race.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, race.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, race.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, race.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, race.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasPeople != nil {
		p := race.HasPeople()
		if !*i.HasPeople {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeopleWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPeopleWith))
		for _, w := range i.HasPeopleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasPeopleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate RaceWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return race.And(predicates...), nil
	}
}

// SessionWhereInput represents a where input for filtering Session queries.
type SessionWhereInput struct {
	Not *SessionWhereInput   `json:"not,omitempty"`
	Or  []*SessionWhereInput `json:"or,omitempty"`
	And []*SessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "started_at" field predicates.
	StartedAt      *time.Time  `json:"startedAt,omitempty"`
	StartedAtNEQ   *time.Time  `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGT    *time.Time  `json:"startedAtGT,omitempty"`
	StartedAtGTE   *time.Time  `json:"startedAtGTE,omitempty"`
	StartedAtLT    *time.Time  `json:"startedAtLT,omitempty"`
	StartedAtLTE   *time.Time  `json:"startedAtLTE,omitempty"`

	// "started_from" field predicates.
	StartedFrom             *string  `json:"startedFrom,omitempty"`
	StartedFromNEQ          *string  `json:"startedFromNEQ,omitempty"`
	StartedFromIn           []string `json:"startedFromIn,omitempty"`
	StartedFromNotIn        []string `json:"startedFromNotIn,omitempty"`
	StartedFromGT           *string  `json:"startedFromGT,omitempty"`
	StartedFromGTE          *string  `json:"startedFromGTE,omitempty"`
	StartedFromLT           *string  `json:"startedFromLT,omitempty"`
	StartedFromLTE          *string  `json:"startedFromLTE,omitempty"`
	StartedFromContains     *string  `json:"startedFromContains,omitempty"`
	StartedFromHasPrefix    *string  `json:"startedFromHasPrefix,omitempty"`
	StartedFromHasSuffix    *string  `json:"startedFromHasSuffix,omitempty"`
	StartedFromIsNil        bool     `json:"startedFromIsNil,omitempty"`
	StartedFromNotNil       bool     `json:"startedFromNotNil,omitempty"`
	StartedFromEqualFold    *string  `json:"startedFromEqualFold,omitempty"`
	StartedFromContainsFold *string  `json:"startedFromContainsFold,omitempty"`

	// "ip_address" field predicates.
	IPAddress             *string  `json:"ipAddress,omitempty"`
	IPAddressNEQ          *string  `json:"ipAddressNEQ,omitempty"`
	IPAddressIn           []string `json:"ipAddressIn,omitempty"`
	IPAddressNotIn        []string `json:"ipAddressNotIn,omitempty"`
	IPAddressGT           *string  `json:"ipAddressGT,omitempty"`
	IPAddressGTE          *string  `json:"ipAddressGTE,omitempty"`
	IPAddressLT           *string  `json:"ipAddressLT,omitempty"`
	IPAddressLTE          *string  `json:"ipAddressLTE,omitempty"`
	IPAddressContains     *string  `json:"ipAddressContains,omitempty"`
	IPAddressHasPrefix    *string  `json:"ipAddressHasPrefix,omitempty"`
	IPAddressHasSuffix    *string  `json:"ipAddressHasSuffix,omitempty"`
	IPAddressIsNil        bool     `json:"ipAddressIsNil,omitempty"`
	IPAddressNotNil       bool     `json:"ipAddressNotNil,omitempty"`
	IPAddressEqualFold    *string  `json:"ipAddressEqualFold,omitempty"`
	IPAddressContainsFold *string  `json:"ipAddressContainsFold,omitempty"`

	// "ended_at" field predicates.
	EndedAt      *time.Time  `json:"endedAt,omitempty"`
	EndedAtNEQ   *time.Time  `json:"endedAtNEQ,omitempty"`
	EndedAtIn    []time.Time `json:"endedAtIn,omitempty"`
	EndedAtNotIn []time.Time `json:"endedAtNotIn,omitempty"`
	EndedAtGT    *time.Time  `json:"endedAtGT,omitempty"`
	EndedAtGTE   *time.Time  `json:"endedAtGTE,omitempty"`
	EndedAtLT    *time.Time  `json:"endedAtLT,omitempty"`
	EndedAtLTE   *time.Time  `json:"endedAtLTE,omitempty"`
}

// Filter applies the SessionWhereInput filter on the SessionQuery builder.
func (i *SessionWhereInput) Filter(q *SessionQuery) (*SessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering sessions.
// An error is returned if the input is empty or invalid.
func (i *SessionWhereInput) P() (predicate.Session, error) {
	var predicates []predicate.Session
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, session.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Session, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, session.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Session, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, session.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, session.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, session.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, session.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, session.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, session.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, session.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, session.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, session.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, session.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, session.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, session.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, session.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, session.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, session.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, session.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, session.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, session.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, session.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, session.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, session.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, session.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, session.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, session.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, session.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, session.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, session.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, session.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, session.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, session.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, session.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, session.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, session.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, session.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, session.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, session.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, session.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, session.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, session.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, session.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, session.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, session.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, session.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, session.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, session.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, session.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, session.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, session.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, session.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, session.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, session.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, session.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, session.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, session.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, session.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, session.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, session.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, session.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, session.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, session.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, session.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, session.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, session.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, session.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, session.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, session.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, session.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, session.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, session.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, session.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, session.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, session.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, session.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, session.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, session.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.StartedAt != nil {
		predicates = append(predicates, session.StartedAtEQ(*i.StartedAt))
	}
	if i.StartedAtNEQ != nil {
		predicates = append(predicates, session.StartedAtNEQ(*i.StartedAtNEQ))
	}
	if len(i.StartedAtIn) > 0 {
		predicates = append(predicates, session.StartedAtIn(i.StartedAtIn...))
	}
	if len(i.StartedAtNotIn) > 0 {
		predicates = append(predicates, session.StartedAtNotIn(i.StartedAtNotIn...))
	}
	if i.StartedAtGT != nil {
		predicates = append(predicates, session.StartedAtGT(*i.StartedAtGT))
	}
	if i.StartedAtGTE != nil {
		predicates = append(predicates, session.StartedAtGTE(*i.StartedAtGTE))
	}
	if i.StartedAtLT != nil {
		predicates = append(predicates, session.StartedAtLT(*i.StartedAtLT))
	}
	if i.StartedAtLTE != nil {
		predicates = append(predicates, session.StartedAtLTE(*i.StartedAtLTE))
	}
	if i.StartedFrom != nil {
		predicates = append(predicates, session.StartedFromEQ(*i.StartedFrom))
	}
	if i.StartedFromNEQ != nil {
		predicates = append(predicates, session.StartedFromNEQ(*i.StartedFromNEQ))
	}
	if len(i.StartedFromIn) > 0 {
		predicates = append(predicates, session.StartedFromIn(i.StartedFromIn...))
	}
	if len(i.StartedFromNotIn) > 0 {
		predicates = append(predicates, session.StartedFromNotIn(i.StartedFromNotIn...))
	}
	if i.StartedFromGT != nil {
		predicates = append(predicates, session.StartedFromGT(*i.StartedFromGT))
	}
	if i.StartedFromGTE != nil {
		predicates = append(predicates, session.StartedFromGTE(*i.StartedFromGTE))
	}
	if i.StartedFromLT != nil {
		predicates = append(predicates, session.StartedFromLT(*i.StartedFromLT))
	}
	if i.StartedFromLTE != nil {
		predicates = append(predicates, session.StartedFromLTE(*i.StartedFromLTE))
	}
	if i.StartedFromContains != nil {
		predicates = append(predicates, session.StartedFromContains(*i.StartedFromContains))
	}
	if i.StartedFromHasPrefix != nil {
		predicates = append(predicates, session.StartedFromHasPrefix(*i.StartedFromHasPrefix))
	}
	if i.StartedFromHasSuffix != nil {
		predicates = append(predicates, session.StartedFromHasSuffix(*i.StartedFromHasSuffix))
	}
	if i.StartedFromIsNil {
		predicates = append(predicates, session.StartedFromIsNil())
	}
	if i.StartedFromNotNil {
		predicates = append(predicates, session.StartedFromNotNil())
	}
	if i.StartedFromEqualFold != nil {
		predicates = append(predicates, session.StartedFromEqualFold(*i.StartedFromEqualFold))
	}
	if i.StartedFromContainsFold != nil {
		predicates = append(predicates, session.StartedFromContainsFold(*i.StartedFromContainsFold))
	}
	if i.IPAddress != nil {
		predicates = append(predicates, session.IPAddressEQ(*i.IPAddress))
	}
	if i.IPAddressNEQ != nil {
		predicates = append(predicates, session.IPAddressNEQ(*i.IPAddressNEQ))
	}
	if len(i.IPAddressIn) > 0 {
		predicates = append(predicates, session.IPAddressIn(i.IPAddressIn...))
	}
	if len(i.IPAddressNotIn) > 0 {
		predicates = append(predicates, session.IPAddressNotIn(i.IPAddressNotIn...))
	}
	if i.IPAddressGT != nil {
		predicates = append(predicates, session.IPAddressGT(*i.IPAddressGT))
	}
	if i.IPAddressGTE != nil {
		predicates = append(predicates, session.IPAddressGTE(*i.IPAddressGTE))
	}
	if i.IPAddressLT != nil {
		predicates = append(predicates, session.IPAddressLT(*i.IPAddressLT))
	}
	if i.IPAddressLTE != nil {
		predicates = append(predicates, session.IPAddressLTE(*i.IPAddressLTE))
	}
	if i.IPAddressContains != nil {
		predicates = append(predicates, session.IPAddressContains(*i.IPAddressContains))
	}
	if i.IPAddressHasPrefix != nil {
		predicates = append(predicates, session.IPAddressHasPrefix(*i.IPAddressHasPrefix))
	}
	if i.IPAddressHasSuffix != nil {
		predicates = append(predicates, session.IPAddressHasSuffix(*i.IPAddressHasSuffix))
	}
	if i.IPAddressIsNil {
		predicates = append(predicates, session.IPAddressIsNil())
	}
	if i.IPAddressNotNil {
		predicates = append(predicates, session.IPAddressNotNil())
	}
	if i.IPAddressEqualFold != nil {
		predicates = append(predicates, session.IPAddressEqualFold(*i.IPAddressEqualFold))
	}
	if i.IPAddressContainsFold != nil {
		predicates = append(predicates, session.IPAddressContainsFold(*i.IPAddressContainsFold))
	}
	if i.EndedAt != nil {
		predicates = append(predicates, session.EndedAtEQ(*i.EndedAt))
	}
	if i.EndedAtNEQ != nil {
		predicates = append(predicates, session.EndedAtNEQ(*i.EndedAtNEQ))
	}
	if len(i.EndedAtIn) > 0 {
		predicates = append(predicates, session.EndedAtIn(i.EndedAtIn...))
	}
	if len(i.EndedAtNotIn) > 0 {
		predicates = append(predicates, session.EndedAtNotIn(i.EndedAtNotIn...))
	}
	if i.EndedAtGT != nil {
		predicates = append(predicates, session.EndedAtGT(*i.EndedAtGT))
	}
	if i.EndedAtGTE != nil {
		predicates = append(predicates, session.EndedAtGTE(*i.EndedAtGTE))
	}
	if i.EndedAtLT != nil {
		predicates = append(predicates, session.EndedAtLT(*i.EndedAtLT))
	}
	if i.EndedAtLTE != nil {
		predicates = append(predicates, session.EndedAtLTE(*i.EndedAtLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate SessionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return session.And(predicates...), nil
	}
}

// SettingWhereInput represents a where input for filtering Setting queries.
type SettingWhereInput struct {
	Not *SettingWhereInput   `json:"not,omitempty"`
	Or  []*SettingWhereInput `json:"or,omitempty"`
	And []*SettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`
}

// Filter applies the SettingWhereInput filter on the SettingQuery builder.
func (i *SettingWhereInput) Filter(q *SettingQuery) (*SettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering settings.
// An error is returned if the input is empty or invalid.
func (i *SettingWhereInput) P() (predicate.Setting, error) {
	var predicates []predicate.Setting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, setting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Setting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, setting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Setting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, setting.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, setting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, setting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, setting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, setting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, setting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, setting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, setting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, setting.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, setting.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, setting.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, setting.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, setting.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, setting.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, setting.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, setting.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, setting.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, setting.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, setting.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, setting.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, setting.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, setting.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, setting.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, setting.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, setting.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, setting.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, setting.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, setting.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, setting.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, setting.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, setting.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, setting.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, setting.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, setting.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, setting.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, setting.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, setting.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, setting.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, setting.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, setting.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, setting.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, setting.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, setting.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, setting.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, setting.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, setting.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, setting.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, setting.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, setting.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, setting.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, setting.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, setting.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, setting.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, setting.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, setting.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, setting.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, setting.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, setting.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, setting.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, setting.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, setting.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, setting.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, setting.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, setting.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, setting.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, setting.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, setting.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, setting.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, setting.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, setting.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, setting.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, setting.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, setting.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, setting.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, setting.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, setting.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, setting.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, setting.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, setting.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, setting.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, setting.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, setting.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, setting.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, setting.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, setting.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, setting.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, setting.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, setting.KeyContainsFold(*i.KeyContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate SettingWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return setting.And(predicates...), nil
	}
}

// SexWhereInput represents a where input for filtering Sex queries.
type SexWhereInput struct {
	Not *SexWhereInput   `json:"not,omitempty"`
	Or  []*SexWhereInput `json:"or,omitempty"`
	And []*SexWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "people" edge predicates.
	HasPeople     *bool               `json:"hasPeople,omitempty"`
	HasPeopleWith []*PersonWhereInput `json:"hasPeopleWith,omitempty"`
}

// Filter applies the SexWhereInput filter on the SexQuery builder.
func (i *SexWhereInput) Filter(q *SexQuery) (*SexQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering sexes.
// An error is returned if the input is empty or invalid.
func (i *SexWhereInput) P() (predicate.Sex, error) {
	var predicates []predicate.Sex
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, sex.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Sex, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, sex.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Sex, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, sex.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, sex.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, sex.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, sex.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, sex.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, sex.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, sex.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, sex.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, sex.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, sex.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, sex.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, sex.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, sex.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, sex.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, sex.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, sex.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, sex.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, sex.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, sex.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, sex.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, sex.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, sex.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, sex.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, sex.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, sex.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, sex.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, sex.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, sex.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, sex.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, sex.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, sex.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, sex.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, sex.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, sex.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, sex.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, sex.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, sex.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, sex.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, sex.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, sex.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, sex.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, sex.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, sex.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, sex.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, sex.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, sex.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, sex.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, sex.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, sex.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, sex.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, sex.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, sex.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, sex.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, sex.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, sex.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, sex.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, sex.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, sex.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, sex.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, sex.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, sex.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, sex.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, sex.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, sex.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, sex.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, sex.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, sex.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, sex.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, sex.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, sex.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, sex.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, sex.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, sex.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, sex.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, sex.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, sex.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, sex.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, sex.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, sex.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, sex.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, sex.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, sex.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, sex.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, sex.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, sex.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, sex.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, sex.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, sex.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, sex.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, sex.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, sex.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, sex.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, sex.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, sex.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, sex.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, sex.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, sex.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, sex.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, sex.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, sex.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, sex.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, sex.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, sex.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, sex.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, sex.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, sex.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, sex.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, sex.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, sex.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, sex.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, sex.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, sex.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, sex.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, sex.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, sex.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, sex.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := sex.HasMetadata()
		if !*i.HasMetadata {
			p = sex.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, sex.HasMetadataWith(with...))
	}
	if i.HasPeople != nil {
		p := sex.HasPeople()
		if !*i.HasPeople {
			p = sex.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeopleWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPeopleWith))
		for _, w := range i.HasPeopleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, sex.HasPeopleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate SexWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return sex.And(predicates...), nil
	}
}

// StateWhereInput represents a where input for filtering State queries.
type StateWhereInput struct {
	Not *StateWhereInput   `json:"not,omitempty"`
	Or  []*StateWhereInput `json:"or,omitempty"`
	And []*StateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "vehicle_registrations" edge predicates.
	HasVehicleRegistrations     *bool                            `json:"hasVehicleRegistrations,omitempty"`
	HasVehicleRegistrationsWith []*VehicleRegistrationWhereInput `json:"hasVehicleRegistrationsWith,omitempty"`
}

// Filter applies the StateWhereInput filter on the StateQuery builder.
func (i *StateWhereInput) Filter(q *StateQuery) (*StateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering states.
// An error is returned if the input is empty or invalid.
func (i *StateWhereInput) P() (predicate.State, error) {
	var predicates []predicate.State
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, state.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.State, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, state.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.State, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, state.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, state.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, state.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, state.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, state.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, state.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, state.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, state.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, state.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, state.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, state.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, state.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, state.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, state.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, state.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, state.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, state.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, state.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, state.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, state.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, state.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, state.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, state.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, state.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, state.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, state.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, state.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, state.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, state.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, state.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, state.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, state.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, state.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, state.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, state.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, state.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, state.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, state.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, state.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, state.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, state.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, state.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, state.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, state.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, state.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, state.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, state.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, state.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, state.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, state.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, state.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, state.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, state.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, state.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, state.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, state.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, state.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, state.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, state.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, state.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, state.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, state.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, state.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, state.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, state.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, state.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, state.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, state.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, state.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, state.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, state.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, state.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, state.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, state.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, state.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, state.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, state.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, state.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, state.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, state.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, state.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, state.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, state.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, state.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, state.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, state.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, state.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, state.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, state.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, state.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, state.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, state.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, state.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, state.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, state.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, state.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, state.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, state.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, state.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, state.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, state.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, state.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, state.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, state.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, state.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, state.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, state.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, state.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, state.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, state.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, state.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, state.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, state.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, state.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, state.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, state.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasVehicleRegistrations != nil {
		p := state.HasVehicleRegistrations()
		if !*i.HasVehicleRegistrations {
			p = state.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleRegistrationsWith) > 0 {
		with := make([]predicate.VehicleRegistration, 0, len(i.HasVehicleRegistrationsWith))
		for _, w := range i.HasVehicleRegistrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, state.HasVehicleRegistrationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate StateWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return state.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "avatar_url" field predicates.
	AvatarURL             *string  `json:"avatarURL,omitempty"`
	AvatarURLNEQ          *string  `json:"avatarURLNEQ,omitempty"`
	AvatarURLIn           []string `json:"avatarURLIn,omitempty"`
	AvatarURLNotIn        []string `json:"avatarURLNotIn,omitempty"`
	AvatarURLGT           *string  `json:"avatarURLGT,omitempty"`
	AvatarURLGTE          *string  `json:"avatarURLGTE,omitempty"`
	AvatarURLLT           *string  `json:"avatarURLLT,omitempty"`
	AvatarURLLTE          *string  `json:"avatarURLLTE,omitempty"`
	AvatarURLContains     *string  `json:"avatarURLContains,omitempty"`
	AvatarURLHasPrefix    *string  `json:"avatarURLHasPrefix,omitempty"`
	AvatarURLHasSuffix    *string  `json:"avatarURLHasSuffix,omitempty"`
	AvatarURLIsNil        bool     `json:"avatarURLIsNil,omitempty"`
	AvatarURLNotNil       bool     `json:"avatarURLNotNil,omitempty"`
	AvatarURLEqualFold    *string  `json:"avatarURLEqualFold,omitempty"`
	AvatarURLContainsFold *string  `json:"avatarURLContainsFold,omitempty"`

	// "first_setup_at" field predicates.
	FirstSetupAt       *time.Time  `json:"firstSetupAt,omitempty"`
	FirstSetupAtNEQ    *time.Time  `json:"firstSetupAtNEQ,omitempty"`
	FirstSetupAtIn     []time.Time `json:"firstSetupAtIn,omitempty"`
	FirstSetupAtNotIn  []time.Time `json:"firstSetupAtNotIn,omitempty"`
	FirstSetupAtGT     *time.Time  `json:"firstSetupAtGT,omitempty"`
	FirstSetupAtGTE    *time.Time  `json:"firstSetupAtGTE,omitempty"`
	FirstSetupAtLT     *time.Time  `json:"firstSetupAtLT,omitempty"`
	FirstSetupAtLTE    *time.Time  `json:"firstSetupAtLTE,omitempty"`
	FirstSetupAtIsNil  bool        `json:"firstSetupAtIsNil,omitempty"`
	FirstSetupAtNotNil bool        `json:"firstSetupAtNotNil,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "oauth_connections" edge predicates.
	HasOauthConnections     *bool                        `json:"hasOauthConnections,omitempty"`
	HasOauthConnectionsWith []*OAuthConnectionWhereInput `json:"hasOauthConnectionsWith,omitempty"`

	// "people" edge predicates.
	HasPeople     *bool               `json:"hasPeople,omitempty"`
	HasPeopleWith []*PersonWhereInput `json:"hasPeopleWith,omitempty"`
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, user.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, user.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, user.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, user.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, user.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, user.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, user.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, user.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, user.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, user.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, user.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, user.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, user.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, user.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, user.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, user.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, user.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, user.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, user.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, user.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, user.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, user.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, user.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, user.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, user.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, user.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, user.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, user.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, user.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, user.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, user.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, user.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, user.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, user.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, user.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, user.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, user.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, user.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, user.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, user.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, user.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, user.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, user.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, user.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, user.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, user.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, user.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, user.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, user.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, user.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, user.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, user.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.AvatarURL != nil {
		predicates = append(predicates, user.AvatarURLEQ(*i.AvatarURL))
	}
	if i.AvatarURLNEQ != nil {
		predicates = append(predicates, user.AvatarURLNEQ(*i.AvatarURLNEQ))
	}
	if len(i.AvatarURLIn) > 0 {
		predicates = append(predicates, user.AvatarURLIn(i.AvatarURLIn...))
	}
	if len(i.AvatarURLNotIn) > 0 {
		predicates = append(predicates, user.AvatarURLNotIn(i.AvatarURLNotIn...))
	}
	if i.AvatarURLGT != nil {
		predicates = append(predicates, user.AvatarURLGT(*i.AvatarURLGT))
	}
	if i.AvatarURLGTE != nil {
		predicates = append(predicates, user.AvatarURLGTE(*i.AvatarURLGTE))
	}
	if i.AvatarURLLT != nil {
		predicates = append(predicates, user.AvatarURLLT(*i.AvatarURLLT))
	}
	if i.AvatarURLLTE != nil {
		predicates = append(predicates, user.AvatarURLLTE(*i.AvatarURLLTE))
	}
	if i.AvatarURLContains != nil {
		predicates = append(predicates, user.AvatarURLContains(*i.AvatarURLContains))
	}
	if i.AvatarURLHasPrefix != nil {
		predicates = append(predicates, user.AvatarURLHasPrefix(*i.AvatarURLHasPrefix))
	}
	if i.AvatarURLHasSuffix != nil {
		predicates = append(predicates, user.AvatarURLHasSuffix(*i.AvatarURLHasSuffix))
	}
	if i.AvatarURLIsNil {
		predicates = append(predicates, user.AvatarURLIsNil())
	}
	if i.AvatarURLNotNil {
		predicates = append(predicates, user.AvatarURLNotNil())
	}
	if i.AvatarURLEqualFold != nil {
		predicates = append(predicates, user.AvatarURLEqualFold(*i.AvatarURLEqualFold))
	}
	if i.AvatarURLContainsFold != nil {
		predicates = append(predicates, user.AvatarURLContainsFold(*i.AvatarURLContainsFold))
	}
	if i.FirstSetupAt != nil {
		predicates = append(predicates, user.FirstSetupAtEQ(*i.FirstSetupAt))
	}
	if i.FirstSetupAtNEQ != nil {
		predicates = append(predicates, user.FirstSetupAtNEQ(*i.FirstSetupAtNEQ))
	}
	if len(i.FirstSetupAtIn) > 0 {
		predicates = append(predicates, user.FirstSetupAtIn(i.FirstSetupAtIn...))
	}
	if len(i.FirstSetupAtNotIn) > 0 {
		predicates = append(predicates, user.FirstSetupAtNotIn(i.FirstSetupAtNotIn...))
	}
	if i.FirstSetupAtGT != nil {
		predicates = append(predicates, user.FirstSetupAtGT(*i.FirstSetupAtGT))
	}
	if i.FirstSetupAtGTE != nil {
		predicates = append(predicates, user.FirstSetupAtGTE(*i.FirstSetupAtGTE))
	}
	if i.FirstSetupAtLT != nil {
		predicates = append(predicates, user.FirstSetupAtLT(*i.FirstSetupAtLT))
	}
	if i.FirstSetupAtLTE != nil {
		predicates = append(predicates, user.FirstSetupAtLTE(*i.FirstSetupAtLTE))
	}
	if i.FirstSetupAtIsNil {
		predicates = append(predicates, user.FirstSetupAtIsNil())
	}
	if i.FirstSetupAtNotNil {
		predicates = append(predicates, user.FirstSetupAtNotNil())
	}

	if i.HasMetadata != nil {
		p := user.HasMetadata()
		if !*i.HasMetadata {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasMetadataWith(with...))
	}
	if i.HasOauthConnections != nil {
		p := user.HasOauthConnections()
		if !*i.HasOauthConnections {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOauthConnectionsWith) > 0 {
		with := make([]predicate.OAuthConnection, 0, len(i.HasOauthConnectionsWith))
		for _, w := range i.HasOauthConnectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasOauthConnectionsWith(with...))
	}
	if i.HasPeople != nil {
		p := user.HasPeople()
		if !*i.HasPeople {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeopleWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPeopleWith))
		for _, w := range i.HasPeopleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPeopleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate UserWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// VehicleWhereInput represents a where input for filtering Vehicle queries.
type VehicleWhereInput struct {
	Not *VehicleWhereInput   `json:"not,omitempty"`
	Or  []*VehicleWhereInput `json:"or,omitempty"`
	And []*VehicleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "vin" field predicates.
	Vin             *string  `json:"vin,omitempty"`
	VinNEQ          *string  `json:"vinNEQ,omitempty"`
	VinIn           []string `json:"vinIn,omitempty"`
	VinNotIn        []string `json:"vinNotIn,omitempty"`
	VinGT           *string  `json:"vinGT,omitempty"`
	VinGTE          *string  `json:"vinGTE,omitempty"`
	VinLT           *string  `json:"vinLT,omitempty"`
	VinLTE          *string  `json:"vinLTE,omitempty"`
	VinContains     *string  `json:"vinContains,omitempty"`
	VinHasPrefix    *string  `json:"vinHasPrefix,omitempty"`
	VinHasSuffix    *string  `json:"vinHasSuffix,omitempty"`
	VinIsNil        bool     `json:"vinIsNil,omitempty"`
	VinNotNil       bool     `json:"vinNotNil,omitempty"`
	VinEqualFold    *string  `json:"vinEqualFold,omitempty"`
	VinContainsFold *string  `json:"vinContainsFold,omitempty"`

	// "style" field predicates.
	Style             *string  `json:"style,omitempty"`
	StyleNEQ          *string  `json:"styleNEQ,omitempty"`
	StyleIn           []string `json:"styleIn,omitempty"`
	StyleNotIn        []string `json:"styleNotIn,omitempty"`
	StyleGT           *string  `json:"styleGT,omitempty"`
	StyleGTE          *string  `json:"styleGTE,omitempty"`
	StyleLT           *string  `json:"styleLT,omitempty"`
	StyleLTE          *string  `json:"styleLTE,omitempty"`
	StyleContains     *string  `json:"styleContains,omitempty"`
	StyleHasPrefix    *string  `json:"styleHasPrefix,omitempty"`
	StyleHasSuffix    *string  `json:"styleHasSuffix,omitempty"`
	StyleIsNil        bool     `json:"styleIsNil,omitempty"`
	StyleNotNil       bool     `json:"styleNotNil,omitempty"`
	StyleEqualFold    *string  `json:"styleEqualFold,omitempty"`
	StyleContainsFold *string  `json:"styleContainsFold,omitempty"`

	// "extra_features" field predicates.
	ExtraFeatures       *time.Time  `json:"extraFeatures,omitempty"`
	ExtraFeaturesNEQ    *time.Time  `json:"extraFeaturesNEQ,omitempty"`
	ExtraFeaturesIn     []time.Time `json:"extraFeaturesIn,omitempty"`
	ExtraFeaturesNotIn  []time.Time `json:"extraFeaturesNotIn,omitempty"`
	ExtraFeaturesGT     *time.Time  `json:"extraFeaturesGT,omitempty"`
	ExtraFeaturesGTE    *time.Time  `json:"extraFeaturesGTE,omitempty"`
	ExtraFeaturesLT     *time.Time  `json:"extraFeaturesLT,omitempty"`
	ExtraFeaturesLTE    *time.Time  `json:"extraFeaturesLTE,omitempty"`
	ExtraFeaturesIsNil  bool        `json:"extraFeaturesIsNil,omitempty"`
	ExtraFeaturesNotNil bool        `json:"extraFeaturesNotNil,omitempty"`

	// "private_notes" field predicates.
	PrivateNotes             *string  `json:"privateNotes,omitempty"`
	PrivateNotesNEQ          *string  `json:"privateNotesNEQ,omitempty"`
	PrivateNotesIn           []string `json:"privateNotesIn,omitempty"`
	PrivateNotesNotIn        []string `json:"privateNotesNotIn,omitempty"`
	PrivateNotesGT           *string  `json:"privateNotesGT,omitempty"`
	PrivateNotesGTE          *string  `json:"privateNotesGTE,omitempty"`
	PrivateNotesLT           *string  `json:"privateNotesLT,omitempty"`
	PrivateNotesLTE          *string  `json:"privateNotesLTE,omitempty"`
	PrivateNotesContains     *string  `json:"privateNotesContains,omitempty"`
	PrivateNotesHasPrefix    *string  `json:"privateNotesHasPrefix,omitempty"`
	PrivateNotesHasSuffix    *string  `json:"privateNotesHasSuffix,omitempty"`
	PrivateNotesIsNil        bool     `json:"privateNotesIsNil,omitempty"`
	PrivateNotesNotNil       bool     `json:"privateNotesNotNil,omitempty"`
	PrivateNotesEqualFold    *string  `json:"privateNotesEqualFold,omitempty"`
	PrivateNotesContainsFold *string  `json:"privateNotesContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "registrations" edge predicates.
	HasRegistrations     *bool                            `json:"hasRegistrations,omitempty"`
	HasRegistrationsWith []*VehicleRegistrationWhereInput `json:"hasRegistrationsWith,omitempty"`

	// "make" edge predicates.
	HasMake     *bool                    `json:"hasMake,omitempty"`
	HasMakeWith []*VehicleMakeWhereInput `json:"hasMakeWith,omitempty"`

	// "model" edge predicates.
	HasModel     *bool                     `json:"hasModel,omitempty"`
	HasModelWith []*VehicleModelWhereInput `json:"hasModelWith,omitempty"`

	// "major_color" edge predicates.
	HasMajorColor     *bool                     `json:"hasMajorColor,omitempty"`
	HasMajorColorWith []*VehicleColorWhereInput `json:"hasMajorColorWith,omitempty"`

	// "minor_color" edge predicates.
	HasMinorColor     *bool                     `json:"hasMinorColor,omitempty"`
	HasMinorColorWith []*VehicleColorWhereInput `json:"hasMinorColorWith,omitempty"`

	// "class" edge predicates.
	HasClass     *bool                     `json:"hasClass,omitempty"`
	HasClassWith []*VehicleClassWhereInput `json:"hasClassWith,omitempty"`
}

// Filter applies the VehicleWhereInput filter on the VehicleQuery builder.
func (i *VehicleWhereInput) Filter(q *VehicleQuery) (*VehicleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vehicles.
// An error is returned if the input is empty or invalid.
func (i *VehicleWhereInput) P() (predicate.Vehicle, error) {
	var predicates []predicate.Vehicle
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vehicle.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Vehicle, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehicle.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Vehicle, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehicle.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, vehicle.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehicle.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehicle.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehicle.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehicle.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehicle.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehicle.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehicle.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vehicle.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vehicle.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vehicle.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vehicle.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vehicle.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vehicle.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vehicle.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vehicle.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, vehicle.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, vehicle.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, vehicle.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, vehicle.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, vehicle.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, vehicle.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, vehicle.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, vehicle.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, vehicle.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, vehicle.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, vehicle.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, vehicle.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, vehicle.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, vehicle.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, vehicle.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, vehicle.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, vehicle.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, vehicle.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, vehicle.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, vehicle.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, vehicle.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, vehicle.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, vehicle.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, vehicle.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, vehicle.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, vehicle.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, vehicle.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, vehicle.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, vehicle.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, vehicle.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, vehicle.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, vehicle.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, vehicle.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, vehicle.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, vehicle.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, vehicle.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, vehicle.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, vehicle.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, vehicle.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, vehicle.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, vehicle.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, vehicle.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, vehicle.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, vehicle.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, vehicle.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, vehicle.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, vehicle.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, vehicle.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, vehicle.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, vehicle.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, vehicle.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, vehicle.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, vehicle.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, vehicle.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, vehicle.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, vehicle.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, vehicle.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, vehicle.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Vin != nil {
		predicates = append(predicates, vehicle.VinEQ(*i.Vin))
	}
	if i.VinNEQ != nil {
		predicates = append(predicates, vehicle.VinNEQ(*i.VinNEQ))
	}
	if len(i.VinIn) > 0 {
		predicates = append(predicates, vehicle.VinIn(i.VinIn...))
	}
	if len(i.VinNotIn) > 0 {
		predicates = append(predicates, vehicle.VinNotIn(i.VinNotIn...))
	}
	if i.VinGT != nil {
		predicates = append(predicates, vehicle.VinGT(*i.VinGT))
	}
	if i.VinGTE != nil {
		predicates = append(predicates, vehicle.VinGTE(*i.VinGTE))
	}
	if i.VinLT != nil {
		predicates = append(predicates, vehicle.VinLT(*i.VinLT))
	}
	if i.VinLTE != nil {
		predicates = append(predicates, vehicle.VinLTE(*i.VinLTE))
	}
	if i.VinContains != nil {
		predicates = append(predicates, vehicle.VinContains(*i.VinContains))
	}
	if i.VinHasPrefix != nil {
		predicates = append(predicates, vehicle.VinHasPrefix(*i.VinHasPrefix))
	}
	if i.VinHasSuffix != nil {
		predicates = append(predicates, vehicle.VinHasSuffix(*i.VinHasSuffix))
	}
	if i.VinIsNil {
		predicates = append(predicates, vehicle.VinIsNil())
	}
	if i.VinNotNil {
		predicates = append(predicates, vehicle.VinNotNil())
	}
	if i.VinEqualFold != nil {
		predicates = append(predicates, vehicle.VinEqualFold(*i.VinEqualFold))
	}
	if i.VinContainsFold != nil {
		predicates = append(predicates, vehicle.VinContainsFold(*i.VinContainsFold))
	}
	if i.Style != nil {
		predicates = append(predicates, vehicle.StyleEQ(*i.Style))
	}
	if i.StyleNEQ != nil {
		predicates = append(predicates, vehicle.StyleNEQ(*i.StyleNEQ))
	}
	if len(i.StyleIn) > 0 {
		predicates = append(predicates, vehicle.StyleIn(i.StyleIn...))
	}
	if len(i.StyleNotIn) > 0 {
		predicates = append(predicates, vehicle.StyleNotIn(i.StyleNotIn...))
	}
	if i.StyleGT != nil {
		predicates = append(predicates, vehicle.StyleGT(*i.StyleGT))
	}
	if i.StyleGTE != nil {
		predicates = append(predicates, vehicle.StyleGTE(*i.StyleGTE))
	}
	if i.StyleLT != nil {
		predicates = append(predicates, vehicle.StyleLT(*i.StyleLT))
	}
	if i.StyleLTE != nil {
		predicates = append(predicates, vehicle.StyleLTE(*i.StyleLTE))
	}
	if i.StyleContains != nil {
		predicates = append(predicates, vehicle.StyleContains(*i.StyleContains))
	}
	if i.StyleHasPrefix != nil {
		predicates = append(predicates, vehicle.StyleHasPrefix(*i.StyleHasPrefix))
	}
	if i.StyleHasSuffix != nil {
		predicates = append(predicates, vehicle.StyleHasSuffix(*i.StyleHasSuffix))
	}
	if i.StyleIsNil {
		predicates = append(predicates, vehicle.StyleIsNil())
	}
	if i.StyleNotNil {
		predicates = append(predicates, vehicle.StyleNotNil())
	}
	if i.StyleEqualFold != nil {
		predicates = append(predicates, vehicle.StyleEqualFold(*i.StyleEqualFold))
	}
	if i.StyleContainsFold != nil {
		predicates = append(predicates, vehicle.StyleContainsFold(*i.StyleContainsFold))
	}
	if i.ExtraFeatures != nil {
		predicates = append(predicates, vehicle.ExtraFeaturesEQ(*i.ExtraFeatures))
	}
	if i.ExtraFeaturesNEQ != nil {
		predicates = append(predicates, vehicle.ExtraFeaturesNEQ(*i.ExtraFeaturesNEQ))
	}
	if len(i.ExtraFeaturesIn) > 0 {
		predicates = append(predicates, vehicle.ExtraFeaturesIn(i.ExtraFeaturesIn...))
	}
	if len(i.ExtraFeaturesNotIn) > 0 {
		predicates = append(predicates, vehicle.ExtraFeaturesNotIn(i.ExtraFeaturesNotIn...))
	}
	if i.ExtraFeaturesGT != nil {
		predicates = append(predicates, vehicle.ExtraFeaturesGT(*i.ExtraFeaturesGT))
	}
	if i.ExtraFeaturesGTE != nil {
		predicates = append(predicates, vehicle.ExtraFeaturesGTE(*i.ExtraFeaturesGTE))
	}
	if i.ExtraFeaturesLT != nil {
		predicates = append(predicates, vehicle.ExtraFeaturesLT(*i.ExtraFeaturesLT))
	}
	if i.ExtraFeaturesLTE != nil {
		predicates = append(predicates, vehicle.ExtraFeaturesLTE(*i.ExtraFeaturesLTE))
	}
	if i.ExtraFeaturesIsNil {
		predicates = append(predicates, vehicle.ExtraFeaturesIsNil())
	}
	if i.ExtraFeaturesNotNil {
		predicates = append(predicates, vehicle.ExtraFeaturesNotNil())
	}
	if i.PrivateNotes != nil {
		predicates = append(predicates, vehicle.PrivateNotesEQ(*i.PrivateNotes))
	}
	if i.PrivateNotesNEQ != nil {
		predicates = append(predicates, vehicle.PrivateNotesNEQ(*i.PrivateNotesNEQ))
	}
	if len(i.PrivateNotesIn) > 0 {
		predicates = append(predicates, vehicle.PrivateNotesIn(i.PrivateNotesIn...))
	}
	if len(i.PrivateNotesNotIn) > 0 {
		predicates = append(predicates, vehicle.PrivateNotesNotIn(i.PrivateNotesNotIn...))
	}
	if i.PrivateNotesGT != nil {
		predicates = append(predicates, vehicle.PrivateNotesGT(*i.PrivateNotesGT))
	}
	if i.PrivateNotesGTE != nil {
		predicates = append(predicates, vehicle.PrivateNotesGTE(*i.PrivateNotesGTE))
	}
	if i.PrivateNotesLT != nil {
		predicates = append(predicates, vehicle.PrivateNotesLT(*i.PrivateNotesLT))
	}
	if i.PrivateNotesLTE != nil {
		predicates = append(predicates, vehicle.PrivateNotesLTE(*i.PrivateNotesLTE))
	}
	if i.PrivateNotesContains != nil {
		predicates = append(predicates, vehicle.PrivateNotesContains(*i.PrivateNotesContains))
	}
	if i.PrivateNotesHasPrefix != nil {
		predicates = append(predicates, vehicle.PrivateNotesHasPrefix(*i.PrivateNotesHasPrefix))
	}
	if i.PrivateNotesHasSuffix != nil {
		predicates = append(predicates, vehicle.PrivateNotesHasSuffix(*i.PrivateNotesHasSuffix))
	}
	if i.PrivateNotesIsNil {
		predicates = append(predicates, vehicle.PrivateNotesIsNil())
	}
	if i.PrivateNotesNotNil {
		predicates = append(predicates, vehicle.PrivateNotesNotNil())
	}
	if i.PrivateNotesEqualFold != nil {
		predicates = append(predicates, vehicle.PrivateNotesEqualFold(*i.PrivateNotesEqualFold))
	}
	if i.PrivateNotesContainsFold != nil {
		predicates = append(predicates, vehicle.PrivateNotesContainsFold(*i.PrivateNotesContainsFold))
	}

	if i.HasMetadata != nil {
		p := vehicle.HasMetadata()
		if !*i.HasMetadata {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasMetadataWith(with...))
	}
	if i.HasRegistrations != nil {
		p := vehicle.HasRegistrations()
		if !*i.HasRegistrations {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegistrationsWith) > 0 {
		with := make([]predicate.VehicleRegistration, 0, len(i.HasRegistrationsWith))
		for _, w := range i.HasRegistrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasRegistrationsWith(with...))
	}
	if i.HasMake != nil {
		p := vehicle.HasMake()
		if !*i.HasMake {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMakeWith) > 0 {
		with := make([]predicate.VehicleMake, 0, len(i.HasMakeWith))
		for _, w := range i.HasMakeWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasMakeWith(with...))
	}
	if i.HasModel != nil {
		p := vehicle.HasModel()
		if !*i.HasModel {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModelWith) > 0 {
		with := make([]predicate.VehicleModel, 0, len(i.HasModelWith))
		for _, w := range i.HasModelWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasModelWith(with...))
	}
	if i.HasMajorColor != nil {
		p := vehicle.HasMajorColor()
		if !*i.HasMajorColor {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMajorColorWith) > 0 {
		with := make([]predicate.VehicleColor, 0, len(i.HasMajorColorWith))
		for _, w := range i.HasMajorColorWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasMajorColorWith(with...))
	}
	if i.HasMinorColor != nil {
		p := vehicle.HasMinorColor()
		if !*i.HasMinorColor {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMinorColorWith) > 0 {
		with := make([]predicate.VehicleColor, 0, len(i.HasMinorColorWith))
		for _, w := range i.HasMinorColorWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasMinorColorWith(with...))
	}
	if i.HasClass != nil {
		p := vehicle.HasClass()
		if !*i.HasClass {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.VehicleClass, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasClassWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate VehicleWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vehicle.And(predicates...), nil
	}
}

// VehicleClassWhereInput represents a where input for filtering VehicleClass queries.
type VehicleClassWhereInput struct {
	Not *VehicleClassWhereInput   `json:"not,omitempty"`
	Or  []*VehicleClassWhereInput `json:"or,omitempty"`
	And []*VehicleClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "vehicles" edge predicates.
	HasVehicles     *bool                `json:"hasVehicles,omitempty"`
	HasVehiclesWith []*VehicleWhereInput `json:"hasVehiclesWith,omitempty"`
}

// Filter applies the VehicleClassWhereInput filter on the VehicleClassQuery builder.
func (i *VehicleClassWhereInput) Filter(q *VehicleClassQuery) (*VehicleClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vehicleclasses.
// An error is returned if the input is empty or invalid.
func (i *VehicleClassWhereInput) P() (predicate.VehicleClass, error) {
	var predicates []predicate.VehicleClass
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vehicleclass.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VehicleClass, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehicleclass.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VehicleClass, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehicleclass.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, vehicleclass.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehicleclass.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehicleclass.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehicleclass.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehicleclass.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehicleclass.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehicleclass.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehicleclass.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vehicleclass.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vehicleclass.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vehicleclass.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vehicleclass.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vehicleclass.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vehicleclass.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vehicleclass.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vehicleclass.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, vehicleclass.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, vehicleclass.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, vehicleclass.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, vehicleclass.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, vehicleclass.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, vehicleclass.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, vehicleclass.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, vehicleclass.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, vehicleclass.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, vehicleclass.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, vehicleclass.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, vehicleclass.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, vehicleclass.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, vehicleclass.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, vehicleclass.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, vehicleclass.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, vehicleclass.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, vehicleclass.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, vehicleclass.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, vehicleclass.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, vehicleclass.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, vehicleclass.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, vehicleclass.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, vehicleclass.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, vehicleclass.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, vehicleclass.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, vehicleclass.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, vehicleclass.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, vehicleclass.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, vehicleclass.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, vehicleclass.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, vehicleclass.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, vehicleclass.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, vehicleclass.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, vehicleclass.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, vehicleclass.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, vehicleclass.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, vehicleclass.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, vehicleclass.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, vehicleclass.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, vehicleclass.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, vehicleclass.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, vehicleclass.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, vehicleclass.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, vehicleclass.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, vehicleclass.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, vehicleclass.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, vehicleclass.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, vehicleclass.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, vehicleclass.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, vehicleclass.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, vehicleclass.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, vehicleclass.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, vehicleclass.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, vehicleclass.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, vehicleclass.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, vehicleclass.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, vehicleclass.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, vehicleclass.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, vehicleclass.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, vehicleclass.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, vehicleclass.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, vehicleclass.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, vehicleclass.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, vehicleclass.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, vehicleclass.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, vehicleclass.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, vehicleclass.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, vehicleclass.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, vehicleclass.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, vehicleclass.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, vehicleclass.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, vehicleclass.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, vehicleclass.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, vehicleclass.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, vehicleclass.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, vehicleclass.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, vehicleclass.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, vehicleclass.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, vehicleclass.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, vehicleclass.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, vehicleclass.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, vehicleclass.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, vehicleclass.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, vehicleclass.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, vehicleclass.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, vehicleclass.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, vehicleclass.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, vehicleclass.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := vehicleclass.HasMetadata()
		if !*i.HasMetadata {
			p = vehicleclass.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicleclass.HasMetadataWith(with...))
	}
	if i.HasVehicles != nil {
		p := vehicleclass.HasVehicles()
		if !*i.HasVehicles {
			p = vehicleclass.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehiclesWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehiclesWith))
		for _, w := range i.HasVehiclesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicleclass.HasVehiclesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate VehicleClassWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vehicleclass.And(predicates...), nil
	}
}

// VehicleColorWhereInput represents a where input for filtering VehicleColor queries.
type VehicleColorWhereInput struct {
	Not *VehicleColorWhereInput   `json:"not,omitempty"`
	Or  []*VehicleColorWhereInput `json:"or,omitempty"`
	And []*VehicleColorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "vehicles_major" edge predicates.
	HasVehiclesMajor     *bool                `json:"hasVehiclesMajor,omitempty"`
	HasVehiclesMajorWith []*VehicleWhereInput `json:"hasVehiclesMajorWith,omitempty"`

	// "vehicles_minor" edge predicates.
	HasVehiclesMinor     *bool                `json:"hasVehiclesMinor,omitempty"`
	HasVehiclesMinorWith []*VehicleWhereInput `json:"hasVehiclesMinorWith,omitempty"`
}

// Filter applies the VehicleColorWhereInput filter on the VehicleColorQuery builder.
func (i *VehicleColorWhereInput) Filter(q *VehicleColorQuery) (*VehicleColorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vehiclecolors.
// An error is returned if the input is empty or invalid.
func (i *VehicleColorWhereInput) P() (predicate.VehicleColor, error) {
	var predicates []predicate.VehicleColor
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vehiclecolor.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VehicleColor, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehiclecolor.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VehicleColor, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehiclecolor.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, vehiclecolor.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehiclecolor.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehiclecolor.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehiclecolor.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehiclecolor.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehiclecolor.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehiclecolor.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vehiclecolor.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vehiclecolor.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vehiclecolor.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vehiclecolor.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vehiclecolor.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vehiclecolor.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vehiclecolor.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, vehiclecolor.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, vehiclecolor.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, vehiclecolor.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, vehiclecolor.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, vehiclecolor.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, vehiclecolor.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, vehiclecolor.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, vehiclecolor.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, vehiclecolor.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, vehiclecolor.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, vehiclecolor.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, vehiclecolor.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, vehiclecolor.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, vehiclecolor.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, vehiclecolor.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, vehiclecolor.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, vehiclecolor.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, vehiclecolor.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, vehiclecolor.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, vehiclecolor.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, vehiclecolor.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, vehiclecolor.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, vehiclecolor.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, vehiclecolor.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, vehiclecolor.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, vehiclecolor.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, vehiclecolor.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, vehiclecolor.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, vehiclecolor.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, vehiclecolor.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, vehiclecolor.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, vehiclecolor.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, vehiclecolor.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, vehiclecolor.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, vehiclecolor.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, vehiclecolor.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, vehiclecolor.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, vehiclecolor.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, vehiclecolor.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, vehiclecolor.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, vehiclecolor.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, vehiclecolor.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, vehiclecolor.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, vehiclecolor.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, vehiclecolor.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, vehiclecolor.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, vehiclecolor.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, vehiclecolor.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, vehiclecolor.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, vehiclecolor.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, vehiclecolor.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, vehiclecolor.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, vehiclecolor.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, vehiclecolor.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, vehiclecolor.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, vehiclecolor.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, vehiclecolor.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, vehiclecolor.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, vehiclecolor.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, vehiclecolor.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, vehiclecolor.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, vehiclecolor.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, vehiclecolor.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, vehiclecolor.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, vehiclecolor.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, vehiclecolor.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, vehiclecolor.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, vehiclecolor.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, vehiclecolor.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, vehiclecolor.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, vehiclecolor.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, vehiclecolor.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := vehiclecolor.HasMetadata()
		if !*i.HasMetadata {
			p = vehiclecolor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehiclecolor.HasMetadataWith(with...))
	}
	if i.HasVehiclesMajor != nil {
		p := vehiclecolor.HasVehiclesMajor()
		if !*i.HasVehiclesMajor {
			p = vehiclecolor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehiclesMajorWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehiclesMajorWith))
		for _, w := range i.HasVehiclesMajorWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehiclecolor.HasVehiclesMajorWith(with...))
	}
	if i.HasVehiclesMinor != nil {
		p := vehiclecolor.HasVehiclesMinor()
		if !*i.HasVehiclesMinor {
			p = vehiclecolor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehiclesMinorWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehiclesMinorWith))
		for _, w := range i.HasVehiclesMinorWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehiclecolor.HasVehiclesMinorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate VehicleColorWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vehiclecolor.And(predicates...), nil
	}
}

// VehicleMakeWhereInput represents a where input for filtering VehicleMake queries.
type VehicleMakeWhereInput struct {
	Not *VehicleMakeWhereInput   `json:"not,omitempty"`
	Or  []*VehicleMakeWhereInput `json:"or,omitempty"`
	And []*VehicleMakeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "vehicles" edge predicates.
	HasVehicles     *bool                `json:"hasVehicles,omitempty"`
	HasVehiclesWith []*VehicleWhereInput `json:"hasVehiclesWith,omitempty"`
}

// Filter applies the VehicleMakeWhereInput filter on the VehicleMakeQuery builder.
func (i *VehicleMakeWhereInput) Filter(q *VehicleMakeQuery) (*VehicleMakeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vehiclemakes.
// An error is returned if the input is empty or invalid.
func (i *VehicleMakeWhereInput) P() (predicate.VehicleMake, error) {
	var predicates []predicate.VehicleMake
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vehiclemake.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VehicleMake, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehiclemake.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VehicleMake, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehiclemake.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, vehiclemake.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehiclemake.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehiclemake.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehiclemake.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehiclemake.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehiclemake.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehiclemake.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehiclemake.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vehiclemake.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vehiclemake.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vehiclemake.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vehiclemake.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vehiclemake.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vehiclemake.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vehiclemake.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vehiclemake.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, vehiclemake.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, vehiclemake.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, vehiclemake.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, vehiclemake.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, vehiclemake.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, vehiclemake.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, vehiclemake.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, vehiclemake.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, vehiclemake.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, vehiclemake.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, vehiclemake.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, vehiclemake.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, vehiclemake.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, vehiclemake.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, vehiclemake.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, vehiclemake.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, vehiclemake.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, vehiclemake.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, vehiclemake.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, vehiclemake.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, vehiclemake.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, vehiclemake.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, vehiclemake.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, vehiclemake.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, vehiclemake.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, vehiclemake.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, vehiclemake.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, vehiclemake.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, vehiclemake.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, vehiclemake.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, vehiclemake.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, vehiclemake.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, vehiclemake.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, vehiclemake.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, vehiclemake.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, vehiclemake.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, vehiclemake.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, vehiclemake.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, vehiclemake.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, vehiclemake.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, vehiclemake.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, vehiclemake.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, vehiclemake.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, vehiclemake.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, vehiclemake.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, vehiclemake.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, vehiclemake.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, vehiclemake.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, vehiclemake.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, vehiclemake.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, vehiclemake.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, vehiclemake.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, vehiclemake.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, vehiclemake.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, vehiclemake.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, vehiclemake.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, vehiclemake.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, vehiclemake.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, vehiclemake.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, vehiclemake.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, vehiclemake.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, vehiclemake.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, vehiclemake.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, vehiclemake.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, vehiclemake.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, vehiclemake.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, vehiclemake.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, vehiclemake.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, vehiclemake.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, vehiclemake.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, vehiclemake.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, vehiclemake.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, vehiclemake.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, vehiclemake.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, vehiclemake.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, vehiclemake.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, vehiclemake.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, vehiclemake.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, vehiclemake.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, vehiclemake.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, vehiclemake.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, vehiclemake.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, vehiclemake.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, vehiclemake.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, vehiclemake.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, vehiclemake.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, vehiclemake.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, vehiclemake.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, vehiclemake.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasVehicles != nil {
		p := vehiclemake.HasVehicles()
		if !*i.HasVehicles {
			p = vehiclemake.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehiclesWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehiclesWith))
		for _, w := range i.HasVehiclesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehiclemake.HasVehiclesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate VehicleMakeWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vehiclemake.And(predicates...), nil
	}
}

// VehicleModelWhereInput represents a where input for filtering VehicleModel queries.
type VehicleModelWhereInput struct {
	Not *VehicleModelWhereInput   `json:"not,omitempty"`
	Or  []*VehicleModelWhereInput `json:"or,omitempty"`
	And []*VehicleModelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "short" field predicates.
	Short             *string  `json:"short,omitempty"`
	ShortNEQ          *string  `json:"shortNEQ,omitempty"`
	ShortIn           []string `json:"shortIn,omitempty"`
	ShortNotIn        []string `json:"shortNotIn,omitempty"`
	ShortGT           *string  `json:"shortGT,omitempty"`
	ShortGTE          *string  `json:"shortGTE,omitempty"`
	ShortLT           *string  `json:"shortLT,omitempty"`
	ShortLTE          *string  `json:"shortLTE,omitempty"`
	ShortContains     *string  `json:"shortContains,omitempty"`
	ShortHasPrefix    *string  `json:"shortHasPrefix,omitempty"`
	ShortHasSuffix    *string  `json:"shortHasSuffix,omitempty"`
	ShortEqualFold    *string  `json:"shortEqualFold,omitempty"`
	ShortContainsFold *string  `json:"shortContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "vehicles" edge predicates.
	HasVehicles     *bool                `json:"hasVehicles,omitempty"`
	HasVehiclesWith []*VehicleWhereInput `json:"hasVehiclesWith,omitempty"`
}

// Filter applies the VehicleModelWhereInput filter on the VehicleModelQuery builder.
func (i *VehicleModelWhereInput) Filter(q *VehicleModelQuery) (*VehicleModelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vehiclemodels.
// An error is returned if the input is empty or invalid.
func (i *VehicleModelWhereInput) P() (predicate.VehicleModel, error) {
	var predicates []predicate.VehicleModel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vehiclemodel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VehicleModel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehiclemodel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VehicleModel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehiclemodel.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, vehiclemodel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehiclemodel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehiclemodel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehiclemodel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehiclemodel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehiclemodel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehiclemodel.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vehiclemodel.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vehiclemodel.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vehiclemodel.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vehiclemodel.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vehiclemodel.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vehiclemodel.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vehiclemodel.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, vehiclemodel.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, vehiclemodel.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, vehiclemodel.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, vehiclemodel.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, vehiclemodel.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, vehiclemodel.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, vehiclemodel.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, vehiclemodel.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, vehiclemodel.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, vehiclemodel.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, vehiclemodel.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, vehiclemodel.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, vehiclemodel.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, vehiclemodel.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, vehiclemodel.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, vehiclemodel.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, vehiclemodel.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, vehiclemodel.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, vehiclemodel.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, vehiclemodel.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, vehiclemodel.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, vehiclemodel.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, vehiclemodel.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, vehiclemodel.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, vehiclemodel.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, vehiclemodel.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, vehiclemodel.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, vehiclemodel.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, vehiclemodel.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, vehiclemodel.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, vehiclemodel.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, vehiclemodel.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, vehiclemodel.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Short != nil {
		predicates = append(predicates, vehiclemodel.ShortEQ(*i.Short))
	}
	if i.ShortNEQ != nil {
		predicates = append(predicates, vehiclemodel.ShortNEQ(*i.ShortNEQ))
	}
	if len(i.ShortIn) > 0 {
		predicates = append(predicates, vehiclemodel.ShortIn(i.ShortIn...))
	}
	if len(i.ShortNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.ShortNotIn(i.ShortNotIn...))
	}
	if i.ShortGT != nil {
		predicates = append(predicates, vehiclemodel.ShortGT(*i.ShortGT))
	}
	if i.ShortGTE != nil {
		predicates = append(predicates, vehiclemodel.ShortGTE(*i.ShortGTE))
	}
	if i.ShortLT != nil {
		predicates = append(predicates, vehiclemodel.ShortLT(*i.ShortLT))
	}
	if i.ShortLTE != nil {
		predicates = append(predicates, vehiclemodel.ShortLTE(*i.ShortLTE))
	}
	if i.ShortContains != nil {
		predicates = append(predicates, vehiclemodel.ShortContains(*i.ShortContains))
	}
	if i.ShortHasPrefix != nil {
		predicates = append(predicates, vehiclemodel.ShortHasPrefix(*i.ShortHasPrefix))
	}
	if i.ShortHasSuffix != nil {
		predicates = append(predicates, vehiclemodel.ShortHasSuffix(*i.ShortHasSuffix))
	}
	if i.ShortEqualFold != nil {
		predicates = append(predicates, vehiclemodel.ShortEqualFold(*i.ShortEqualFold))
	}
	if i.ShortContainsFold != nil {
		predicates = append(predicates, vehiclemodel.ShortContainsFold(*i.ShortContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, vehiclemodel.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, vehiclemodel.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, vehiclemodel.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, vehiclemodel.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, vehiclemodel.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, vehiclemodel.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, vehiclemodel.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, vehiclemodel.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, vehiclemodel.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, vehiclemodel.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, vehiclemodel.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, vehiclemodel.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, vehiclemodel.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, vehiclemodel.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, vehiclemodel.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, vehiclemodel.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, vehiclemodel.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, vehiclemodel.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, vehiclemodel.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, vehiclemodel.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, vehiclemodel.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, vehiclemodel.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, vehiclemodel.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, vehiclemodel.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, vehiclemodel.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, vehiclemodel.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, vehiclemodel.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasMetadata != nil {
		p := vehiclemodel.HasMetadata()
		if !*i.HasMetadata {
			p = vehiclemodel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehiclemodel.HasMetadataWith(with...))
	}
	if i.HasVehicles != nil {
		p := vehiclemodel.HasVehicles()
		if !*i.HasVehicles {
			p = vehiclemodel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehiclesWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehiclesWith))
		for _, w := range i.HasVehiclesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehiclemodel.HasVehiclesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate VehicleModelWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vehiclemodel.And(predicates...), nil
	}
}

// VehicleRegistrationWhereInput represents a where input for filtering VehicleRegistration queries.
type VehicleRegistrationWhereInput struct {
	Not *VehicleRegistrationWhereInput   `json:"not,omitempty"`
	Or  []*VehicleRegistrationWhereInput `json:"or,omitempty"`
	And []*VehicleRegistrationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy       *int  `json:"createdBy,omitempty"`
	CreatedByNEQ    *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int `json:"createdByNotIn,omitempty"`
	CreatedByGT     *int  `json:"createdByGT,omitempty"`
	CreatedByGTE    *int  `json:"createdByGTE,omitempty"`
	CreatedByLT     *int  `json:"createdByLT,omitempty"`
	CreatedByLTE    *int  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  bool  `json:"createdByIsNil,omitempty"`
	CreatedByNotNil bool  `json:"createdByNotNil,omitempty"`

	// "created_with" field predicates.
	CreatedWith             *string  `json:"createdWith,omitempty"`
	CreatedWithNEQ          *string  `json:"createdWithNEQ,omitempty"`
	CreatedWithIn           []string `json:"createdWithIn,omitempty"`
	CreatedWithNotIn        []string `json:"createdWithNotIn,omitempty"`
	CreatedWithGT           *string  `json:"createdWithGT,omitempty"`
	CreatedWithGTE          *string  `json:"createdWithGTE,omitempty"`
	CreatedWithLT           *string  `json:"createdWithLT,omitempty"`
	CreatedWithLTE          *string  `json:"createdWithLTE,omitempty"`
	CreatedWithContains     *string  `json:"createdWithContains,omitempty"`
	CreatedWithHasPrefix    *string  `json:"createdWithHasPrefix,omitempty"`
	CreatedWithHasSuffix    *string  `json:"createdWithHasSuffix,omitempty"`
	CreatedWithIsNil        bool     `json:"createdWithIsNil,omitempty"`
	CreatedWithNotNil       bool     `json:"createdWithNotNil,omitempty"`
	CreatedWithEqualFold    *string  `json:"createdWithEqualFold,omitempty"`
	CreatedWithContainsFold *string  `json:"createdWithContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_with" field predicates.
	UpdatedWith             *string  `json:"updatedWith,omitempty"`
	UpdatedWithNEQ          *string  `json:"updatedWithNEQ,omitempty"`
	UpdatedWithIn           []string `json:"updatedWithIn,omitempty"`
	UpdatedWithNotIn        []string `json:"updatedWithNotIn,omitempty"`
	UpdatedWithGT           *string  `json:"updatedWithGT,omitempty"`
	UpdatedWithGTE          *string  `json:"updatedWithGTE,omitempty"`
	UpdatedWithLT           *string  `json:"updatedWithLT,omitempty"`
	UpdatedWithLTE          *string  `json:"updatedWithLTE,omitempty"`
	UpdatedWithContains     *string  `json:"updatedWithContains,omitempty"`
	UpdatedWithHasPrefix    *string  `json:"updatedWithHasPrefix,omitempty"`
	UpdatedWithHasSuffix    *string  `json:"updatedWithHasSuffix,omitempty"`
	UpdatedWithIsNil        bool     `json:"updatedWithIsNil,omitempty"`
	UpdatedWithNotNil       bool     `json:"updatedWithNotNil,omitempty"`
	UpdatedWithEqualFold    *string  `json:"updatedWithEqualFold,omitempty"`
	UpdatedWithContainsFold *string  `json:"updatedWithContainsFold,omitempty"`

	// "plate" field predicates.
	Plate             *string  `json:"plate,omitempty"`
	PlateNEQ          *string  `json:"plateNEQ,omitempty"`
	PlateIn           []string `json:"plateIn,omitempty"`
	PlateNotIn        []string `json:"plateNotIn,omitempty"`
	PlateGT           *string  `json:"plateGT,omitempty"`
	PlateGTE          *string  `json:"plateGTE,omitempty"`
	PlateLT           *string  `json:"plateLT,omitempty"`
	PlateLTE          *string  `json:"plateLTE,omitempty"`
	PlateContains     *string  `json:"plateContains,omitempty"`
	PlateHasPrefix    *string  `json:"plateHasPrefix,omitempty"`
	PlateHasSuffix    *string  `json:"plateHasSuffix,omitempty"`
	PlateEqualFold    *string  `json:"plateEqualFold,omitempty"`
	PlateContainsFold *string  `json:"plateContainsFold,omitempty"`

	// "expired_at" field predicates.
	ExpiredAt      *time.Time  `json:"expiredAt,omitempty"`
	ExpiredAtNEQ   *time.Time  `json:"expiredAtNEQ,omitempty"`
	ExpiredAtIn    []time.Time `json:"expiredAtIn,omitempty"`
	ExpiredAtNotIn []time.Time `json:"expiredAtNotIn,omitempty"`
	ExpiredAtGT    *time.Time  `json:"expiredAtGT,omitempty"`
	ExpiredAtGTE   *time.Time  `json:"expiredAtGTE,omitempty"`
	ExpiredAtLT    *time.Time  `json:"expiredAtLT,omitempty"`
	ExpiredAtLTE   *time.Time  `json:"expiredAtLTE,omitempty"`

	// "metadata" edge predicates.
	HasMetadata     *bool                 `json:"hasMetadata,omitempty"`
	HasMetadataWith []*MetadataWhereInput `json:"hasMetadataWith,omitempty"`

	// "state" edge predicates.
	HasState     *bool              `json:"hasState,omitempty"`
	HasStateWith []*StateWhereInput `json:"hasStateWith,omitempty"`

	// "person" edge predicates.
	HasPerson     *bool               `json:"hasPerson,omitempty"`
	HasPersonWith []*PersonWhereInput `json:"hasPersonWith,omitempty"`

	// "vehicle" edge predicates.
	HasVehicle     *bool                `json:"hasVehicle,omitempty"`
	HasVehicleWith []*VehicleWhereInput `json:"hasVehicleWith,omitempty"`
}

// Filter applies the VehicleRegistrationWhereInput filter on the VehicleRegistrationQuery builder.
func (i *VehicleRegistrationWhereInput) Filter(q *VehicleRegistrationQuery) (*VehicleRegistrationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vehicleregistrations.
// An error is returned if the input is empty or invalid.
func (i *VehicleRegistrationWhereInput) P() (predicate.VehicleRegistration, error) {
	var predicates []predicate.VehicleRegistration
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vehicleregistration.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VehicleRegistration, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehicleregistration.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VehicleRegistration, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehicleregistration.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, vehicleregistration.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehicleregistration.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehicleregistration.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehicleregistration.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehicleregistration.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehicleregistration.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehicleregistration.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vehicleregistration.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vehicleregistration.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vehicleregistration.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vehicleregistration.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vehicleregistration.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vehicleregistration.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vehicleregistration.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, vehicleregistration.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, vehicleregistration.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, vehicleregistration.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, vehicleregistration.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, vehicleregistration.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, vehicleregistration.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, vehicleregistration.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, vehicleregistration.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, vehicleregistration.CreatedByNotNil())
	}
	if i.CreatedWith != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithEQ(*i.CreatedWith))
	}
	if i.CreatedWithNEQ != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithNEQ(*i.CreatedWithNEQ))
	}
	if len(i.CreatedWithIn) > 0 {
		predicates = append(predicates, vehicleregistration.CreatedWithIn(i.CreatedWithIn...))
	}
	if len(i.CreatedWithNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.CreatedWithNotIn(i.CreatedWithNotIn...))
	}
	if i.CreatedWithGT != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithGT(*i.CreatedWithGT))
	}
	if i.CreatedWithGTE != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithGTE(*i.CreatedWithGTE))
	}
	if i.CreatedWithLT != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithLT(*i.CreatedWithLT))
	}
	if i.CreatedWithLTE != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithLTE(*i.CreatedWithLTE))
	}
	if i.CreatedWithContains != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithContains(*i.CreatedWithContains))
	}
	if i.CreatedWithHasPrefix != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithHasPrefix(*i.CreatedWithHasPrefix))
	}
	if i.CreatedWithHasSuffix != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithHasSuffix(*i.CreatedWithHasSuffix))
	}
	if i.CreatedWithIsNil {
		predicates = append(predicates, vehicleregistration.CreatedWithIsNil())
	}
	if i.CreatedWithNotNil {
		predicates = append(predicates, vehicleregistration.CreatedWithNotNil())
	}
	if i.CreatedWithEqualFold != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithEqualFold(*i.CreatedWithEqualFold))
	}
	if i.CreatedWithContainsFold != nil {
		predicates = append(predicates, vehicleregistration.CreatedWithContainsFold(*i.CreatedWithContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, vehicleregistration.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, vehicleregistration.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, vehicleregistration.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, vehicleregistration.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, vehicleregistration.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, vehicleregistration.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, vehicleregistration.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, vehicleregistration.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, vehicleregistration.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, vehicleregistration.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, vehicleregistration.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, vehicleregistration.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, vehicleregistration.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, vehicleregistration.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, vehicleregistration.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, vehicleregistration.UpdatedByNotNil())
	}
	if i.UpdatedWith != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithEQ(*i.UpdatedWith))
	}
	if i.UpdatedWithNEQ != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithNEQ(*i.UpdatedWithNEQ))
	}
	if len(i.UpdatedWithIn) > 0 {
		predicates = append(predicates, vehicleregistration.UpdatedWithIn(i.UpdatedWithIn...))
	}
	if len(i.UpdatedWithNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.UpdatedWithNotIn(i.UpdatedWithNotIn...))
	}
	if i.UpdatedWithGT != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithGT(*i.UpdatedWithGT))
	}
	if i.UpdatedWithGTE != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithGTE(*i.UpdatedWithGTE))
	}
	if i.UpdatedWithLT != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithLT(*i.UpdatedWithLT))
	}
	if i.UpdatedWithLTE != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithLTE(*i.UpdatedWithLTE))
	}
	if i.UpdatedWithContains != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithContains(*i.UpdatedWithContains))
	}
	if i.UpdatedWithHasPrefix != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithHasPrefix(*i.UpdatedWithHasPrefix))
	}
	if i.UpdatedWithHasSuffix != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithHasSuffix(*i.UpdatedWithHasSuffix))
	}
	if i.UpdatedWithIsNil {
		predicates = append(predicates, vehicleregistration.UpdatedWithIsNil())
	}
	if i.UpdatedWithNotNil {
		predicates = append(predicates, vehicleregistration.UpdatedWithNotNil())
	}
	if i.UpdatedWithEqualFold != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithEqualFold(*i.UpdatedWithEqualFold))
	}
	if i.UpdatedWithContainsFold != nil {
		predicates = append(predicates, vehicleregistration.UpdatedWithContainsFold(*i.UpdatedWithContainsFold))
	}
	if i.Plate != nil {
		predicates = append(predicates, vehicleregistration.PlateEQ(*i.Plate))
	}
	if i.PlateNEQ != nil {
		predicates = append(predicates, vehicleregistration.PlateNEQ(*i.PlateNEQ))
	}
	if len(i.PlateIn) > 0 {
		predicates = append(predicates, vehicleregistration.PlateIn(i.PlateIn...))
	}
	if len(i.PlateNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.PlateNotIn(i.PlateNotIn...))
	}
	if i.PlateGT != nil {
		predicates = append(predicates, vehicleregistration.PlateGT(*i.PlateGT))
	}
	if i.PlateGTE != nil {
		predicates = append(predicates, vehicleregistration.PlateGTE(*i.PlateGTE))
	}
	if i.PlateLT != nil {
		predicates = append(predicates, vehicleregistration.PlateLT(*i.PlateLT))
	}
	if i.PlateLTE != nil {
		predicates = append(predicates, vehicleregistration.PlateLTE(*i.PlateLTE))
	}
	if i.PlateContains != nil {
		predicates = append(predicates, vehicleregistration.PlateContains(*i.PlateContains))
	}
	if i.PlateHasPrefix != nil {
		predicates = append(predicates, vehicleregistration.PlateHasPrefix(*i.PlateHasPrefix))
	}
	if i.PlateHasSuffix != nil {
		predicates = append(predicates, vehicleregistration.PlateHasSuffix(*i.PlateHasSuffix))
	}
	if i.PlateEqualFold != nil {
		predicates = append(predicates, vehicleregistration.PlateEqualFold(*i.PlateEqualFold))
	}
	if i.PlateContainsFold != nil {
		predicates = append(predicates, vehicleregistration.PlateContainsFold(*i.PlateContainsFold))
	}
	if i.ExpiredAt != nil {
		predicates = append(predicates, vehicleregistration.ExpiredAtEQ(*i.ExpiredAt))
	}
	if i.ExpiredAtNEQ != nil {
		predicates = append(predicates, vehicleregistration.ExpiredAtNEQ(*i.ExpiredAtNEQ))
	}
	if len(i.ExpiredAtIn) > 0 {
		predicates = append(predicates, vehicleregistration.ExpiredAtIn(i.ExpiredAtIn...))
	}
	if len(i.ExpiredAtNotIn) > 0 {
		predicates = append(predicates, vehicleregistration.ExpiredAtNotIn(i.ExpiredAtNotIn...))
	}
	if i.ExpiredAtGT != nil {
		predicates = append(predicates, vehicleregistration.ExpiredAtGT(*i.ExpiredAtGT))
	}
	if i.ExpiredAtGTE != nil {
		predicates = append(predicates, vehicleregistration.ExpiredAtGTE(*i.ExpiredAtGTE))
	}
	if i.ExpiredAtLT != nil {
		predicates = append(predicates, vehicleregistration.ExpiredAtLT(*i.ExpiredAtLT))
	}
	if i.ExpiredAtLTE != nil {
		predicates = append(predicates, vehicleregistration.ExpiredAtLTE(*i.ExpiredAtLTE))
	}

	if i.HasMetadata != nil {
		p := vehicleregistration.HasMetadata()
		if !*i.HasMetadata {
			p = vehicleregistration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMetadataWith) > 0 {
		with := make([]predicate.Metadata, 0, len(i.HasMetadataWith))
		for _, w := range i.HasMetadataWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicleregistration.HasMetadataWith(with...))
	}
	if i.HasState != nil {
		p := vehicleregistration.HasState()
		if !*i.HasState {
			p = vehicleregistration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStateWith) > 0 {
		with := make([]predicate.State, 0, len(i.HasStateWith))
		for _, w := range i.HasStateWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicleregistration.HasStateWith(with...))
	}
	if i.HasPerson != nil {
		p := vehicleregistration.HasPerson()
		if !*i.HasPerson {
			p = vehicleregistration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPersonWith))
		for _, w := range i.HasPersonWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicleregistration.HasPersonWith(with...))
	}
	if i.HasVehicle != nil {
		p := vehicleregistration.HasVehicle()
		if !*i.HasVehicle {
			p = vehicleregistration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehicleWith))
		for _, w := range i.HasVehicleWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicleregistration.HasVehicleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/responserms/response/internal/ent: empty predicate VehicleRegistrationWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vehicleregistration.And(predicates...), nil
	}
}
